\section{Protocols}

We shall model a protocol as a finite set of \emph{actions} available to the
attacker. An action represents a basic step of the protocol where
the attacker provides an input, a condition is checked, 
state updates are performed (optionally), and finally an output is emitted.
There exists a natural translation from the applied pi-calculus to a representation using a finite set of actions, reminescent of Proverif's translation to Horn
Clauses or Tamarin's translation to multiset rewriting. We omit the details.

In order to be able to define a protocol, we assume a set of function
symbols $\F$ and a set of name symbols $\N$.
Additionally, we will use channel names from a set of constants $\C$ (known to the attacker),
as well as indexed memory cell symbols from $\States$.

% \begin{definition} \label{def:action} \label{def:proto}
%   A protocol is a finite set of action symbols $\Act$.
%   A \emph{symbolic action} $\alpha = \sfa(i_1,\ldots,i_k)$
%   is the application of an action symbol $\sfa \in \Act_k$
%   to $k$ indices.
%   We assume a partial order on symbolic actions,
%   noted $\beta \leq \alpha$, expressing that $\alpha$ depends on $\beta$ (i.e.\ $\alpha$ must occurs before $\beta$). We require that $\leq$ is stable by substitution\footnote{
%     For any symbolic actions $A$, $A'$ and index substitution $\theta : \I \to \I$,
%     $A \leq A'$ implies $A\theta \leq A'\theta$.
%   }.
%   Finally, each action $\sfa \in \Act_k$ must come with
%   a representative symbolic action $\alpha = \sfa(i_1,\ldots,i_k)$
%   with distinct indices,
%   and the following elements describing its semantics:
%   \begin{itemize}
%     \item a meta-logic formula $\phi_{\alpha}$
%       (the execution condition of this action);
%     \item a meta-logic term $o_{\alpha}$
%       (the output of this action);
%     \item for each memory cell symbol $s \in \States$ of index arity $p$,
%       a meta-logic term $u_{\alpha}^{s[j_1,\ldots,j_p]}$
%       for some index variables $j_1,\ldots,j_p$
%       that are distinct and disjoint from $\vec{i}$
%       (this term describes how the action updates the memory
%       cell, depending on the indices $\vec{i}$ and $\vec{j}$);
%     \item two channel names $\cin_\alpha$ and $\cout_\alpha$
%       (the input and output channels of this action).
%   \end{itemize}
%   We require that
%   $\phi_{\alpha}$, $u_{\alpha}^{s}$ and $o_{\alpha}$ do not contain any
%   timestamp term (and thus, no macro term) and require that
%   free variables occurring in these terms and formulas are
%   of one of the following forms:
%   \begin{itemize}
%     \item $x_{\sfa'(i'_1,\ldots,i'_l)}$
%       with $\sfa'(i'_1,\ldots,i'_l)\leq \alpha$ or
%     \item $x^{s[j_1,\ldots,j_p]}$
%       for some $s \in \States_p$.
%   \end{itemize}
%   Intuitively, the action's behavior depends only on previous inputs of actions, and on the memory.
%   \adrien{I think we also want to say that index variables are only $i_1,\dots,i_k$, plus the index variables of memory updates. We should probably use binders there.}
% \end{definition}

% \adrien{This looks more complicated than it is. I feel like this would be better if actions had index binders.}
% The semantics of each action $\sfa$ is given via an arbitrary
% choice of indices in $\alpha = \sfa(i_1,\ldots,i_k)$.
% We then extended naturally this semantics to all symbolic actions,
% rendering the choice of indices irrelevant:
% for an arbitrary symbolic action $\alpha' =
% \sfa(i'_1,\ldots,i'_k)$ we define
% $o_{\alpha'} = o_\alpha\{i_n\mapsto i'_n\}_{1\leq n \leq k}$
% and similarly for $\phi_{\alpha'}$;
% further, if the update term of $\alpha$ for state $s$ is given
% with indices $j'_1,\ldots,j'_p$ we extend it as follows:
% $$ u_{\alpha'}^{s[j'_1,\ldots,j'_p]} :=
%    u_\alpha^{s[j_1,\ldots,j_p]}\{i_n\mapsto i'_n\}_{1 \leq n \leq k}
%                                 \{j_m\mapsto j'_m\}_{1 \leq m \leq p}.$$

\begin{definition} \label{def:action}
  A action is an element of the form:
    % \begin{minipage}{.4\linewidth}
    \[
      \begin{aligned}
        &\lefteqn{\textsf{action } \sfa(i_1, \dots, i_k) =}\\
        &\quad&&\textsf{condition: } \phi\\
        &     &&\textsf{input on: } \cin\\
        &     &&\textsf{output: } o \textsf{ on } \cout\\
        &     &&\textsf{update: for every $s_{|p} \in \States$}\\
        &     &&\qquad s[j_1,\dots,j_p] \leftarrow u^{s}
      \end{aligned}
    \]
    % \end{minipage}
  where $\sfa$ is the name of the action, $(i_1,\ldots,i_k)$ are distinct indices, $\tau$ is an time-stamp variable and:
  \begin{itemize}
  \item the meta-logic formula $\phi$ is the execution condition of the action, with $\fv{\phi} \subseteq \{i_1,\dots, i_k\}$. % and $\tfv{\phi} \subseteq \{\tau\}$.
  \item the channel $\cin$ is the action's input channel
  \item the meta-logic term $o$ is the the output of this action, on channel $\cout$, with $\fv{o} \subseteq \{i_1,\dots, i_k\}$. % and $\tfv{o} \subseteq \{\tau\}$.
  \item for each memory cell symbol $s \in \States$ of index arity $p$, and distinct index variables $j_1,\ldots,j_p$ (disjoint from $i_1,\dots, i_k$), the memory update $s[j_1,\dots,j_p] \leftarrow u^{s}$, with $\fv{u^s} \subseteq \{i_1,\dots, i_k, j_1, \dots, j_p\}$. % and $\tfv{u^{s}} \subseteq \{\tau\}$.
  \end{itemize}
  % Furthermore, we require that $\tau$ is the only possible sub-term of $\phi$, $o$ and $\{u^{s} \mid s \in \States\}$ of sort $\timestamp$. Therefore, all macros are taken at time $\tau$.
  We let $\Act$ be the set of actions, and $\Act_k$ be the set of actions with exactly $k$ indices. We assume that all actions have disjoint names, so that we can refer to an action by its name $\sfa$. Given an action $\sfa$, we let $\phi_\sfa$, $o_\sfa$ and $\{s[j_1,\dots, j_p] \leftarrow u_\sfa^{s} \mid s \in \States_{p}\}$ denote the meta-logic terms and state update in the definition above. 
  Finally, we use the following short representation for an action:
  \[
    \sfa(i_1,\dots,i_k).(\phi, \cin, o, \cout,
    \{s[j_1,\dots, j_p] \leftarrow u^{s} \mid s \in \States_{p}\})
  \]
\end{definition}

\begin{definition} \label{def:proto}
  A protocol $\calp = (\calp_\sfA, \leq)$ is a finite set of action $\calp_\sfA \subseteq \Act$, equiped with a partial order $\leq$ on action names in $\calp_\sfA$, where $\sfa \leq \sfa'$ states that $\sfa'$ must occurs before $\sfa$. % We lift $\leq$ to symbolic actions built upon $\calp_{\sfA}$, by comparing action names.
  We require that every action in $\calp_\sfA$ uses only actions that occur strictly before it, i.e.\ for every
  \[
    \sfa(i_1,\dots,i_k).(\phi, \cin, o, \cout,
    \{s[j_1,\dots, j_p] \leftarrow u^{s} \mid s \in \States_{p}\})
    \in \calp_{\sfA}
  \]
  the only subterms of $\phi, o, \{u^{s}\mid s\}$ of sort $\timestamp$ are of the form: i) $\sfa'[\pvec{l}]$, where $\sfa' < \sfa$; ii) $\tpred{\sfa[i_1,\dots,i_k]}$; or iii) $\sfa[i_1,\dots,i_k]$ if it occurs in the term $\minp@(\sfa[i_1,\dots,i_k])$.
\end{definition}

\adrien{I an not sure we use the channels in an action description. }

\begin{remark}
  Actions provide an explicit update for each memory cell. This
  allows to easily obtain the value of a memory cell at any given point.

  We allow actions to update memory cells that depend on some free indices.  As
  it will be illustrated later on, this is required to express protocols with
  actions that are conditioned by existential formulas over indices.

  All memory cells are initialized to $0$. If we want a different value, we can use an action to initialize all memory cells (with values that depend on the cells'
  indices), and we can force this action to happen before any other.
  In the tool, we use a different approach, and let the user provide axioms to specify the initial values of the memory.
  % --- but of course we do not have rules to derive the fact that initial
  % values are $0$ as specified here, so we cannot obtain a contradiction.
\end{remark}

\begin{definition}
  Given a protocol $\calp = (\calp_\sfA, \leq)$, a \emph{symbolic action} $\alpha = \sfa(i_1,\ldots,i_k)$ is the application of an action name (corresponding to an action $\sfA \in \Act_k \cap \calp_\sfA$) to $k$ indices.
\end{definition}

\begin{definition}
  Given a protocol $\calp = (\calp_\sfA, \leq)$, a \emph{concrete action} of $\calp$ is an instantiation of a \emph{symbolic action} of $\calp$ with integer variables for index variables. We lift the partial order $\leq$ to concrete actions, by comparing action names.
\end{definition}

\begin{definition}
  \label{def:trace}
  Given a protocol $\calp = (\calp_\sfA, \leq)$,
  an \emph{abstract trace}\footnote{
    It is abstract in the sense that we do not know if the trace
    is executable. \adrien{I believe people will be confused when you tell them that an abstract trace is a sequence of concrete actions. I think it should be called concrete trace.}} is a sequence of concrete actions
  $\alpha_1 \dots \alpha_n$
  in which no action occurs twice, and such that,
  for every $1 \leq i \leq n$,
  for every concrete action $\beta$ such that $\beta \leq \alpha_i$,
  there exists $1 \leq j \leq i$ such that $\beta = \alpha_j$.
\end{definition}

\begin{remark}
  The structure that we have assumed on actions is restrictive and
  does not allow to model e.g.\ phases. It does not matter because we can
  impose other conditions on traces later on as axioms (similar to the
  restrictions of Tamarin).
\end{remark}

\begin{remark}
  Our notion of protocol does not allow to specify a conflict relation
  over actions. Such conflicts might be useful to specify e.g.\ that
  actions corresponding to different branches of a conditional cannot
  be present together in a trace. This is not limiting, since the
  mutually exclusive conditions of such actions have the same effect.
  Conflicts could in principle be useful to model the fact that there is only
  one way to enter the $\mathsf{in}$ branch of a $\mathsf{find}$. However,
  our experience so far is that such details are not necessary to reason
  over protocols. 
\end{remark}

\subsection{Bi-protocols}

In order to model the indistinguishability of two protocols, we will
consider pairs of processes described through a bi-process, i.e.\ a system with
a single set of symbolic actions where each symbolic action describes
simultaneously the left and right processes, using $\diff{\_}{\_}$ terms.
We assume that $\mathsf{diff} \in \F$,
which will be interpreted in a particular way. \adrien{I believe that we do not give a semantics to $\mathsf{diff}$. Instead, we first project to get rid of it, and then interpret}
We use the notation $(\_)^L$ and $(\_)^R$ to denote the left and right
projections of a bi-protocol, bi-term, etc (defined as usual).
For example, $(\phi_{\alpha})^L$ and $(\phi_{\alpha})^R$ will denote
the left and right execution conditions of $\alpha$, and
$(o_{\alpha})^L$ and $(o_{\alpha})^R$ will denote their respective
output messages.

\subsection{Examples}
\adrien{I will update the examples to fit the new syntax}

We give here a few representative examples of (bi)protocols.

\begin{example}
  The process $!_i
  \ain{c,x};\aout{c,h(x,\key[i])};\ain{c,y};\aout{c,h(x,\key[i])}$
  is translated into a protocol with two action symbols $A$ and $B$,
  a partial order generated $A(j) \leq B(j)$, and the following
  semantics:
  \begin{itemize}
    \item $\alpha := A(i)$ with
      \begin{itemize}
        \item $\phi_\alpha := \mathsf{true}$
        \item $o_\alpha := h(x_\alpha,\key[i])$
        \item $u_\alpha^{s[j_1,\ldots,j_p]} = x^{s[j_1,\ldots,j_p]}$
          for all $s\in\States_p$
      \end{itemize}
    \item $\beta := B(i)$ with
      \begin{itemize}
        \item $\phi_\beta := \mathsf{true}$
        \item $o_\beta := h(x_\alpha,\key[i])$
        \item $u_\beta^{s[j_1,\ldots,j_p]} = x^{s[j_1,\ldots,j_p]}$
          for all $s\in\States_p$
      \end{itemize}
  \end{itemize}
  In the next examples, we will not specify update terms
  $u_\alpha^{s[j_1,\ldots,j_p]}$ when they are trivial, as is the case
  here.
\end{example}

\begin{example}[Basic Hash]
  \label{ex:basic-hash-bi-process}
  The bi-protocol $P_{BH}$ is defined by the symbolic actions
  $\{\Sort(i,j),\R_1(k),\R_2(k)\}$, with a trivial dependency relation,
  and the following semantics:
    \begin{itemize}
      \item action $\alpha_1 := \Sort(i,j)$ represents the only
        action of a tag's session $i,j$ with
        \begin{itemize}
          \item $\phi_{\alpha_1} := \true$
          \item $o_{\alpha_1} := \langle n[i,j], \h(n[i,j],\diff{\key[i]}{\key'[i,j]}) \rangle$
        \end{itemize}
      \item action $\alpha_2 := \R_1(k)$ represents the action
        of the reader's session $k$ accepting a tag, with
        \begin{itemize}
          \item $\phi_{\alpha_2} := \exists i,j, \snd(x_{\alpha_2}) =
            \h(\fst(x_{\alpha_2}),\diff{\key[i]}{\key'[i,j]})$
          \item $o_{\alpha_2} := \ok$
        \end{itemize}
      \item action $\alpha_3 := \R_2(k)$ represents the situation
        where the reader does not accept its input, with
        \begin{itemize}
          \item $\phi_{\alpha_3} := \neg (\exists i,j, \snd(x_{\alpha_2}) =  \h(\fst(x_{\alpha_2}),\diff{\key[i]}{\key'[i,j]})$
          \item $o_{\alpha_3} := \error$
        \end{itemize}
    \end{itemize}
  Some abstract traces for this bi-protocol are:
  \begin{itemize}
    \item $\Sort(1,1),\R_1(3)$
    \item $\Sort(1,1).\R_1(3).\Sort(1,2).\R_1(2)$
    \item $\Sort(1,1).\R_1(3).\Sort(2,1).\R_1(2)$
  \end{itemize}
  This protocol is actually obtained in our tool from the following
  bi-process:
  $$\bigl(!_i !_j \aout{c,\langle  n[i,j]} \rangle\bigr) \mid
   \bigl(!_k \ain{c,x}.~ \myif \exists i,j.~ \snd(x) = \ldots \mythen
    out(c,\ok) \myelse out(c,\error)\bigr)$$
\end{example}

\begin{example}
  In the previous example, if we change the reader part of the bi-process into
  $$\ain{c,x}.~ \myfind i,j \mysuchthat \snd(x) = \ldots \mythen
  \aout{c,\ok} \myelse \aout{c,\error}$$
  then action $R_1(k)$ would be replaced by $\alpha_2 := R_1(k,i,j)$
  with:
  \begin{itemize}
    \item $\phi_{\alpha_2} := \snd(x_{\alpha_2}) =
      \h(\fst(x_{\alpha_2}),\diff{\key[i]}{\key'[i,j]})$
    \item $o_{\alpha_2} := \ok$
  \end{itemize}
  In protocols where the output message would depend on the indices $i,j$
  bound by the $\mathsf{find}$ construct, we would also use $\myfind$ in the
  output message to retrieve these indices (more precisely, we would retrieve
  the first such indices).
\end{example}

\begin{example}[OSK]
  \label{ex:osk-bi-process}
  In order to model a simple (and linkable) version of the OSK protocol,
  we consider:
  \begin{itemize}
    \item Two hash functions modelled using unary function symbols
      $f$ and $g$ --- these should in principle be keyed, but that is
      not relevant for the example.
    \item Four memory cell symbols:
      $s_R$ and $s'_R$ of respective index arities 1 and 2 for representing
      an entry in the reader database in the multiple and single session
      scenarios;
      $s_T$ and $s'_T$ of respective index arities 1 and 2 for representing
      the tag's memory in multiple and single session scenarios.
    \item Name symbols $k$ and $k'$ of respective index arities 1 and 2.
  \end{itemize}
  The bi-protocol $P_{OSK}$ is then defined by
  the set of symbolic actions $\{\Sort(i,j),\R_1(k,i,j),\R_2(k)\}$ where:
    \begin{itemize}
      \item action $\alpha_1 := \Sort(i,j)$
        \begin{itemize}
          \item $\phi_{\alpha_1} := \true$
          \item $o_{\alpha_1} := \diff{g(x^{s_T[i]})}{g(x^{s'_T[i,j]})}$
          \item $u_{\alpha_1}^{s_T[i']} :=
              \myif i=i' \mythen h(x^{s_T[i]})
              \myelse x^{s_T[i']}
            \bigr)$
          \item $u_{\alpha_1}^{s'_T[i',j']} :=
              \myif \langle i,j \rangle = \langle i',j' \rangle
              \mythen h(x^{s'_T[i,j]})
              \myelse x^{s'_T[i',j']}$
        \end{itemize}
      \item action $\alpha_2 := \R_1(k,i,j)$
        \begin{itemize}
          \item $\phi_{\alpha_2} := x_{\alpha_2} = \diff{g(x^{s_R[i]})}{g(x^{s'_R[i,j]})}$
          \item $o_{\alpha_2} := \ok$
          \item $u_{\alpha_2}^{s_R[i']} :=
            \myif i=i' \mythen
            h(x^{s_R[i]})
            \myelse x^{s_R[i']}$
          \item $u_{\alpha_2}^{s'_R[i',j']} :=
            \myif\langle i,j\rangle=\langle i',j'\rangle \mythen
            h(x^{s'_R[i,j]})
            \myelse x^{s'_R[i',j']}$
        \end{itemize}
      \item action $\alpha_3 := \R_2(k)$
        \begin{itemize}
          \item $\phi_{\alpha_3} :=
            \forall i,j.~
            x_{\alpha_3} \neq
            \diff{g(x^{s_R[i]})}{g(x^{s'_R[i,j]})}$
          \item $o_{\alpha_3} := \error$
        \end{itemize}
    \end{itemize}
    The initial values of $s_T[i]$ and $s_R[i]$ are $k[i]$ for
    some indexed name symbol $k$; the initial values of
    $s'_T[i,j]$ and $s'_R[i,j]$ are $k'[i,j]$ for some
    indexed name symbol $k'$.

    Note that this semantics means that the left process updates not only
    the values of $s_T[i]$ and $s_R[i]$ but also those of
    $s'_T[i,j]$ and $s'_R[i,j]$, which are unusued in its tests and outputs.
    This imprecision does not have an impact on security properties,
    or indistinguishability.
    It would be possible to write more precise updates using $\mathsf{diff}$
    operators, as would be the case in the protocol resulting from the actual
    translation of the following bi-process:
  \[
  \begin{array}{lll}
  & !_i !_j & \aout{c,\diff{g(s_T[i])}{g(s_{T'}[i,j])}}. \\
  && \diff{s_T[i] := h(s_T[i])}{s_{T'}[i,j] := h(s_{T'}[i,j])} \\
  \mid
  & !_k & \ain{c,x}. \\
  && \myfind i,j \mysuchthat x = \diff{g(s_R[i])}{g(s_{R'}[i,j])} \\
  && \mythen \diff{s_R[i] := h(s_R[i])}{s_{R'}[i,j] := h(s_{R'}[i,j])} .~\aout{c,\ok} \\
  && \myelse \aout{c,\error} \\
  &  & \\
  \end{array}
  \]
\end{example}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
