\section{Protocols and trace logic}

Without entering into the details of the protocol semantics, we can already
restrict the set of meta-interpretations of interest, to justify some of the
rules that we use. We would alternatively impose these conditions from the
beginning in the definition of meta-interpretations.

There exists a natural translation from applied pi-calculus to this notion of 
actions, reminescent of the translation inside Horn Clauses performed by 
Proverif, or the translation inside Multi Set Rewritting rules performed by 
Sapic (a Tamarin extension).

\emph{[David] I have not carefully worked through what follows, and it
probably needs (at least) to be updated following the changes in the previous
section.}

\subsection{Protocols}

We  model a protocol as a set of possible actions available to the
attacker. An action models a basic step of the protocol, where
the attacker provides some input, some condition is checked, some
state updates are performed, and finally an output is emitted.

In this section we assume a fixed set of action symbols $\Actions$.
We assume that macro symbols include $\minp$ and $\mout$,
both of index and term arities zero.
We also assume that all other macro symbols are of term arities zero.
We call them \emph{state macros} as they will be used to model memory cells.

\begin{definition}
  An \emph{action} $a(\ov{n})$ is the application of
  an action symbol $a\in\Actions$ of index arity $k$ to
  some concrete indices $\ov{n}\in\mathbb{N}^k$.
  Actions will be noted $\alpha$, $\beta$, $\gamma$.

  We assume a transitive \emph{sequential dependency} relation
  $\alpha\before\beta$ on actions, which intuitively means that
  $\alpha$ must happen before $\beta$ in any execution,
  and a \emph{conflict} relation $\alpha\conflict\beta$, 
  which intuitively means $\alpha$ and $\beta$ cannot both occur in
  any execution.
  We say that an action $\alpha$ is \emph{enabled} after some (possibly empty)
  sequence of actions $\alpha_1\ldots\alpha_n$ when, for all 
  $\beta\before\alpha$ there exists $i\in[1;n]$ such that $\beta=\alpha_i$.

  To each action $\alpha$ we associate:
  a meta-logic formula $\phi_\alpha$ called the \emph{condition}
  of $\alpha$;
  for each state macro symbol $s$, a term $u^s_\alpha$ called
  the \emph{update} of $s$ by $\alpha$;
  a message term $o_\alpha$ called the \emph{output} of $\alpha$.
  The condition, output and updates of an action $\alpha$ must not contain any
  macro term and the only free variables that can occur in them are
  $x_\alpha$, $x_\beta$ for $\beta\before\alpha$, and $x_s$ where $s$ a
  state macro symbol.
\end{definition}

In our tool, actions are compiled from an applied pi-calculus process.
Sequential dependencies are induced by the syntactic sequences in that 
process, and conflicts are induced by conditionals.

\medskip

We now give a notion of symbolic trace, which intuitively represents
a possible scheduling of the protocol, when ignoring messages.

\begin{definition}
  A symbolic trace $\tr$ is a sequence $\alpha_1\ldots\alpha_n$ of actions
  such that:
  \begin{itemize}
    \item for all $1 \leq i < j \leq n$,
      $\alpha_i \neq \alpha_j$ and it is not the case
      that $\alpha_i \conflict \alpha_j$;
    \item for all $1 \leq i \leq n$,
      for all $\beta \before \alpha_i$,
      there exists $1 \leq j < i$ such that $\beta = \alpha_j$;
  \end{itemize}
\end{definition}

\begin{remark}
  We could get rid of the conflict relationship and still be able to
  model conditionals: we would have more symbolic traces but, when conditions
  are taken into account, the incompatible conditions of actions corresponding
  to different branches of a conditional would allow to discard
  the unwanted branches. For that reason, we should not need a tactic
  relying on the conflict relationship in the prover.
\end{remark}

\begin{remark}
  The structure that we have assumed on actions is restrictive and
  does not allow to model e.g. phases. It does not matter because we can
  impose other conditions on traces later on as axioms (similar to the 
  restrictions of Tamarin).
\end{remark}

\subsection{Meta-interpretation of a trace}

As in the \BC model, we model arbitrary messages produced by the attacker 
using free function symbols $\G = \{g_i | i \in \mathbb{N}\}$. We assume
from now on that our signature contains such symbols.

We construct, for each symbolic trace, a meta-interpretation representing
the trace. Some details of this definition will be understood in the next
section, where we identify some axioms that hold in all such 
meta-interpretations.

\begin{definition}
  Given a symbolic execution $\tr = \alpha_1\ldots\alpha_n$,
  we define the meta-interpretation $I_\tr$ as follows
  (\emph{TODO define the substitution for $x_s$ variables,
  as well as $\hat{s}$\ldots)}):
  \begin{itemize}
    \item $\D_\I$ is the set of indices that occur in $\tr$;
    \item $\D_\XT = \{ t_0 \} \uplus \{ a(\ov{n}) : a\in\Actions_k, 
      \ov{n}\in\D_\I^k \}$;
    \item the order $\leq$ is such that $\epsilon\leq t$ for all $t\in\D_\XT$,
      and $\alpha\leq\beta$ if $\alpha$ occurs before $\beta$ in $\tr$;
    \item the predecessor function $p$ maps $t_0$ to itself and all
      other timestamps to their predecessor according to $\leq$;
    \item $H_\XT$ is the set of actions that occur in $\tr$,
      i.e.\ $H_\XT=\{\alpha_i : i\in[1;n]\}$;
    \item $\sigma_\I$ and $\sigma_\XT$ are arbitrary;
    \item for each $a\in\Actions_k$, $\hat{a}(\ov{n}) = a(\ov{n})$;
    \item $\hat{\minp}$ and $\hat{\mout}$ have arbitrary values on
      $t_0$ and otherwise are uniquely defined by the following
      conditions, for all $i\in[1;n]$:
      $$\hat{\minp}(\alpha_i) = 
      g_{i}(\hat{\mout}(\alpha_1),\ldots,\hat{\mout}(\alpha_{i-1}))
      \text{ and }
      \hat{\mout}(\alpha_i) =
      o_{\alpha_i}\{x_{\alpha_j}\mapsto\hat{\minp}(\alpha_j)\}_{j<i}.$$
  \end{itemize}
\end{definition}

We can now formally define when a protocol satisfies some trace property 
$\phi$:
we require that the property holds in all traces that are actually executable
--- more precisely, we require that $\phi_\tr \Rightarrow \phi$ is almost
always true, where $\phi_\tr$ expresses that the trace is executable.

\begin{definition}
  Given a trace $\tr$, its executability formula
  is $\phi_\tr = \bigwedge_{\alpha\in\tr} 
  \phi_\alpha\{x_\beta\mapsto\minp@\beta\}$.
\end{definition}

\begin{definition}
  A meta-logic formula $\phi$ is valid wrt.\ our protocol when,
  for any symbolic trace $\tr$ of the protocol,
  we have $I_\tr \models \phi_\tr \Rightarrow \phi$.
\end{definition}

In other words, we require that, for any $\tr$ and
for any computational model,
we have $\M \models (\phi_\tr\Rightarrow\phi)^{I_\tr} \sim \true$.

In practice, we do not want to consider all computational models, but
restrict to the ones satisfying some cryptographic assumption: reformulate
what's above so that it's more natural.

\subsection{Trace axioms}

We now identify some valid formulas, which can thus be used as axioms
when trying to derive a trace property.

\begin{proposition}
  The following formulas are valid wrt.\ the protocol:
  \begin{itemize}
    \item for any $\alpha \before \beta$,
      $\happens(\beta) \Rightarrow \happens(\alpha) \wedge \alpha < \beta$;
    \item for any $\alpha \conflict \beta$,
      $\happens(\alpha)\wedge\happens(\beta) \Rightarrow \bot$;
    \item for any $\alpha$,
      $\happens(\alpha) \Rightarrow 
      \phi_\alpha\{x_\beta\mapsto\minp@\beta\}_\beta$.
    \item
      $\forall \tau,\tau',\tau'', \happens(\tau)\wedge\happens(\tau'')\wedge
      \tau\leq\tau'\wedge\tau'\leq\tau''\Rightarrow\happens(\tau')$;
    \item
      $\forall \tau, \happens(\tau) \Rightarrow \pre(\tau)<\tau \wedge
      \forall \tau'.~ \pre(\tau)\leq\tau'<\tau \Rightarrow
      \tau'=\pre(\tau)$;
    \item for any $a\neq b\in\Actions$,
      $\forall \ov{i},\ov{j}, a(\ov{i})\neq b(\ov{j})$;
    \item for any $a\in\Actions$,
      $\forall \ov{i},\ov{j}, a(\ov{i})=a(\ov{j}) \Rightarrow \ov{i}=\ov{j}$.
  \end{itemize}
\end{proposition}

Note that obvious axioms such as the predecessor or injectivity axioms
would not hold for simpler constructions of $I_\tr$.
