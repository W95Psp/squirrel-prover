\section{Protocols}

% Without entering into the details of the protocol semantics, we can already
% restrict the set of meta-interpretations of interest, to justify some of the
% rules that we use. We would alternatively impose these conditions from the
% beginning in the definition of meta-interpretations.

There exists a natural translation from applied pi-calculus to this notion of
actions, reminescent of the translation inside Horn Clauses performed by
Proverif, or the translation inside Multi Set Rewritting rules performed by
Sapic (a Tamarin extension).

\bigskip

We  model a protocol as a set of possible actions available to the
attacker. An action models a basic step of the protocol, where
the attacker provides some input, some condition is checked, some
state updates are performed, and finally an output is emitted.

In this section we assume a fixed set of action symbols $\Actions$,
as well as a fixed set of channel names $\C$.
We assume that macro symbols include $\minp$ and $\mout$,
both of index and term arities zero.
We also assume that all other macro symbols are of term arities zero.
We call them \emph{state macros} as they will be used to model memory cells.

\begin{definition}
  \label{def:action}
A \emph{symbolic action} $\alpha = \sfa(i_1,\dots,i_n)$, where $\sfa \in \Actions$ and $i_1,\dots,i_n \in \I$, is defined by:
\begin{itemize}
  \item a meta-logic formula $\phi_{\alpha}$ (intuitively, the condition of this action)
  \item a meta-logic term $o_{\alpha}$ (intuitively, the output of this action)
  \item for each state macro symbol $s$, a meta-logic term $u_{\alpha}^{s}$ (intuitively, the update of the memory cell $s$ for this action)
  \item two channel names $\cin_\alpha$ and $\cout_\alpha$ (intuitively, the channels used for the input and the output of this action)
\end{itemize}
where $\phi_{\alpha}$, $u_{\alpha}^{s}$ and $o_{\alpha}$ must not contain any
macro term and the only free variables that can occur in them are
$x_\alpha$ (intuitively, the input of this action)
and $x^s_\alpha$ where $s$ is a state macro symbol (intuitively, the value
of the memory cell at the time of this action).
\solene{The sequential dependency is defined only later (in the definition of a
protocol) but we would like to allow as free variables also $x_\beta$ for every
action $\beta$ that must happen before $\alpha$ in an execution.}
% ???
% Names appearing in $\phi_{\alpha}$ and $o_{\alpha}$ are of the form $\sfn(i_1,\dots,i_k)$ with $k \leq n$.
\end{definition}

\begin{definition}
A \emph{concrete action} is an instanciation of a \emph{symbolic action} by giving integer values to index variables.
\end{definition}

\begin{definition}
  \label{def:proto}
  A \emph{protocol} is defined by:
  \begin{itemize}
    \item a finite set of \emph{symbolic actions} with distinct action symbols,
    \item a transitive \emph{sequential dependency} relation $\before$ on \emph{symbolic actions},
    \item a \emph{conflict} relation $\conflict$ on \emph{symbolic actions}.
  \end{itemize}
  Intuitively, $\sfa_1(i)\before\sfa_2(i,j)$ means that, for all $n_i,n_j \in \mathbb{N}$, $\sfa_1(n_i)$ must happen before $\sfa_2(n_i,n_j)$ in any execution
  and $\sfa_1(i,j)\conflict\sfa_2(i,j)$ means that, for all $n_i,n_j \in \mathbb{N}$, $\sfa_1(n_i,n_j)$ and $\sfa_2(n_i,n_j)$ cannot both occur in any execution.
\end{definition}

In our tool, actions are compiled from an applied pi-calculus process.
Sequential dependencies are induced by the syntactic sequences in that
process, and conflicts are induced by conditionals.

\begin{definition}
  \label{def:trace}
  Given a protocol $P$ according to \Cref{def:proto}, an \emph{abstract trace}\footnote{Abstract in the sense that we do not know if the trace is executable.} is a sequence $\sfa_1(\vect {i_1}) \dots \sfa_n(\vect {i_n})$ made of concrete actions such that:
  \begin{itemize}
    \item for all $1 \leq i,j \leq n$, if $\sfa_i = \sfa_j$ then $\vect {i_i} \neq \vect {i_j}$;
    \item for all $1 \leq i < j \leq n$, it is not the case that $\sfa_i(\vect {i_i}) \conflict \sfa_j(\vect {i_j})$;
    \item for all $1 \leq i \leq n$, for all concrete action $\beta$ such that $\beta \before \sfa_i(\vect {i_i})$, there exists $1 \leq j < i$ such that $\beta = \sfa_j(\vect {i_j})$.
  \end{itemize}
\end{definition}

\paragraph{Bi-processes}

When reasoning on indistinguishability of a protocol, we may look at equivalences
between two processes given as a bi-process, i.e. a system with a single set of
symbolic actions, each symbolic action describing an execution step of both the
left and right processes, using $\diff{\_}{\_}$ terms as usual.

In that case, the definition of a symbolic action differs from \Cref{def:action}
in the following way:
\begin{itemize}
  \item $\phi_{\alpha}$ is a meta-logic \emph{bi-formula}
  \item $o_{\alpha}$ and $u_{\alpha}^{\sfs}$ are meta-logic \emph{bi-terms}
\end{itemize}

We define in \Cref{fig:bi-terms} how we extend the syntax in \Cref{fig:terms}
to define meta-logic bi-terms.
Bi-formulas are obtained from the syntax in \Cref{fig:formulas} by allowing
atomic propositions over bi-terms.

\begin{figure}[h]
  \[
  \begin{array}{rclll}
    tt  & := & t &\text{term} & \\
        & \mid & \diff{t_1}{t_2} &\text{bi-term} & \\
        & \mid & f[i_1,\ldots,i_k](tt_1,\dots,tt_n) &\text{function application over bi-terms} & (f\in\F_k)\\
  \end{array}
  \]
  \caption{Syntax of meta-logic bi-terms}\label{fig:bi-terms}
\end{figure}

We use the notation $(\_)^L$ and $(\_)^R$ to denote the left and right projections
(defined as usual), for example: $(\phi_{\alpha})^L$ and $(\phi_{\alpha})^R$,
$(o_{\alpha})^L$ and $(o_{\alpha})^R$.


\begin{example}[Basic Hash]
  \label{ex:basic-hash-bi-process}
  We introduce the bi-process $P_{BH}$ defined by:
  \begin{itemize}
    \item the set of symbolic actions $\{\T(i,j),\R_1(k,i,j),\R_2(k,i,j)\}$ where,
    \begin{itemize}
      \item action $\alpha_1 := \T(i,j)$
        \begin{itemize}
          \item $\phi_{\alpha_1} := \true$
          \item $o_{\alpha_1} := \langle n[i,j], \h(\diff{\key[i]}{\key'[i,j]},n[i,j] \rangle$
        \end{itemize}
      \item action $\alpha_2 := \R_1(k,i,j)$
        \begin{itemize}
          \item $\phi_{\alpha_2} := \exists i,j, \snd(x_{\alpha_2}) =  \h(\diff{\key[i]}{\key'[i,j]},\fst(x_{\alpha_2})$
          \item $o_{\alpha_2} := \ok$
        \end{itemize}
      \item action $\alpha_3 := \R_2(k,i,j)$
        \begin{itemize}
          \item $\phi_{\alpha_3} := \neg (\exists i,j, \snd(x_{\alpha_2}) =  \h(\diff{\key[i]}{\key'[i,j]},\fst(x_{\alpha_2}))$
          \item $o_{\alpha_3} := \error$
        \end{itemize}
    \end{itemize}
    \item a conflict relation $\conflict$ such that $\R_1(k,i,j)\conflict\R_2(k,i,j)$.
  \end{itemize}

\noindent
Some traces for this bi-process are:
  \begin{itemize}
    \item $\T(1,1),\R_1(1,1,1)$
    \item $\T(1,1).\R_1(1,1,1).\T(1,2).\R_1(2,1,2)$
    \item $\T(1,1).\R_1(1,1,1).\T(2,1).\R_1(2,2,1)$
  \end{itemize}
\end{example}

\bigskip
\noindent
\begin{remark}
  We could get rid of the conflict relationship and still be able to
  model conditionals: we would have more symbolic traces but, when conditions
  are taken into account, the incompatible conditions of actions corresponding
  to different branches of a conditional would allow to discard
  the unwanted branches. For that reason, we should not need a tactic
  relying on the conflict relationship in the prover.
\end{remark}

\begin{remark}
  The structure that we have assumed on actions is restrictive and
  does not allow to model e.g. phases. It does not matter because we can
  impose other conditions on traces later on as axioms (similar to the
  restrictions of Tamarin).
\end{remark}
