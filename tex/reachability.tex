\section{Trace properties}

\subsection{Validity and logical consequence}

We have defined a translation from any meta-logic formula $\phi$ to a base logic
boolean term $\interp{\phi}^\TM$. We can now formally define when a protocol
satisfies some trace property $\phi$.  Intuitively, the meta-logic formula is
true when the associated term is true with overwhelming probability in any trace model. % This is made formal in the following definitions.
\begin{definition}
  % Given a protocol $P$, a formula $\phi$ of the meta-logic is said to be valid
  % when, for any trace model $\TM$, the base logic formula
  % $(\phi)^\TM \sim \true$ is valid. \adrien{$P$ is not used in this sentence.}
  % A formula $\phi$ of the meta-logic is valid if for any trace model $\TM$, the base logic formula $(\phi)^\TM \sim \true$ is valid.
  %
  % More generally, a meta-logic formula $\phi$ is a
  % logical consequence of a set $S$ of base logic formulas
  % % (which might themselves be of the form $\interp{\psi}^\TM \sim \true$)
  % when, for all $\TM$, $\Mo$ and $\sigma$ such that
  % $\Mo,\sigma \models \psi$ for all $\psi\in S$,
  % we have
  % $\Mo,\sigma \models(\phi)^\TM\sim\mathsf{true}$.
  Let $\phi$ be a meta-formula. Then for every trace model $\TM$, computational model $\Mo$ and interpretation $\sigma$, $\TM, \Mo, \sigma \models \phi$ if $\Mo, \sigma \models (\phi)^{\TM} \sim \true$.

  We say that $\phi$ is valid if $\TM, \Mo, \sigma \models \phi$ for every $\TM$, $\Mo$, $\sigma$, and for any set of meta-formulas $S$, $S \models \phi$ if for every $\TM$, $\Mo$, $\sigma$ such that $\TM, \Mo, \sigma \models S$, we have $\TM, \Mo, \sigma \models \phi$.
  % we omit $\sigma$ when it is empty (i.e.\ when $\phi$ has no free message variables).
\end{definition}

\begin{remark}
  In the tool, we only allow universal quantification over messages, and
  only allow it at toplevel. The validity of such formulas is the same as
  when the variables are left free.
\end{remark}

In practice, we want to verify that a security property expressed as a
meta-logic formula $\phi$ is satisfied in a class of trace models
$\TM$ and computational models $\Mo$: we will typically restrict computational
models so that cryptographic primitives satisfy some security assumption,
but we may also restrict trace models e.g.\ to force a condition on
abstract traces. In order to verify security in such a class of models,
we will identify axioms that hold in these models, and verify that our
security property is a logical consequence of these axioms.

\begin{remark}
  We have defined a notion of validity that implies that a formula must hold for all abstract traces. Abstract traces can contain actions that are not executable, and we can thus write formulas about outputs that may never be performed. In practice, we will often prove the validity of formulas of the form $\mexec@T \Rightarrow \phi$. This implies that the trace is executable, and allows us to reason over the conditions of the actions.
\end{remark}

\subsection{Sequent calculus}

In the tool, sequents come with an environment which explicitly
declares all the variables that might occur free in the sequent's formulas.
For simplicity, we do not include them here. We shall write $\vdash t:\Sort$
when $t$ is a term of sort $\Sort$ (which might be $\idx$ or $\timestamp$).

\begin{definition}
  A sequent $\Gamma \vdash \phi$ is composed of a set of meta-logic formulas
  $\Gamma$ and a meta-logic formula $\phi$.
  % It is valid when the meta-logic formula
  % $(\wedge\Gamma) \Rightarrow \phi$ is valid.
  The sequent $\Gamma \vdash \phi$ is valid if $\Gamma \models \phi$.
\end{definition}

% \paragraph{Sequent Calculus}
We can now give the basic rules of our meta-logic sequent calculus for reachability, and prove their soundness.
\begin{proposition}
  The generic and name inference rules of \cref{fig:seq-reach} are sound: if the premisses are valid,
  then so is the conclusion.
\end{proposition}


\begin{figure}[tp]
  \textbf{Generic inference rules.} These are the rules of classical
  first-order sequent calculus. In \textsc{$\forall$-R} we require that
  $x$ does not appear free in $\Gamma$.
  % \label{fig:lk}
  \begin{mathpar}
    \inferrule[Axiom]{~}{\Gamma,\phi\vdash\phi}

    \inferrule[Cut]{
      \Gamma \vdash \phi\\
      \Gamma,\phi \vdash \psi
    }{
      \Gamma \vdash \psi
    }
    
    \inferrule[${\wedge}$-L]{
      \Gamma,\phi,\phi'\vdash\psi
    }{
      \Gamma,\phi\wedge\phi'\vdash\psi
    }

    \inferrule[${\wedge}$-R]{
      \Gamma \vdash \phi\\
      \Gamma \vdash \phi'
    }{
      \Gamma \vdash \phi\wedge\phi'
    }

    \inferrule[${\lnot}$-R]{
      \Gamma, \phi \vdash \bot
    }{
      \Gamma \vdash \lnot\phi
    }

    \inferrule[${\lnot}$-L]{
      \Gamma \vdash \phi
    }{
      \Gamma,\lnot\phi \vdash \psi
    }

    \inferrule[Raa]{
      \Gamma, \lnot\phi \vdash \bot
    }{
      \Gamma \vdash \phi
    }
  \end{mathpar}
  \begin{center}
    \emph{other propositional rules of classical sequent calculus}
  \end{center}
  \begin{mathpar}
    \inferrule[${=}$-R]{~}{\Gamma \vdash t=t} \quad\quad
    \inferrule[${=}$-L]{
      (\Gamma\vdash\phi)\{x\mapsto t',x'\mapsto t\}
    }{
      t=t', \Gamma\{x\mapsto t,x'\mapsto t'\} \vdash
      \phi\{x\mapsto t,x'\mapsto t'\}
    }

    \inferrule[$\forall$-L]{
      \Gamma,\phi\{x\mapsto t\} \vdash \psi\\
      \vdash t:\Sort
    }{
      \Gamma,\forall x:\Sort.\phi \vdash \psi}

    \inferrule[$\forall$-R]{
      \Gamma \vdash \phi}{\Gamma \vdash \forall x:\Sort:\phi}
  \end{mathpar}
  % 
  \medskip
  \textbf{Some inference rules for equalities on names.}
  % The last rule only applies when, for any trace model $\TM$,
  % the term $\interp{t}^\TM$ does not contain any message variable and does
  % not contain any occurrence of $\mathsf{n}_{\sigma_\I(\vec i)}$
  % --- this condition will be over-approximated in our implementation.
  % \adrien{Considering how I re-organized the section, this last rule should be given later.}
  % \label{fig:names}  
  \begin{mathpar}
    \inferrule{
      \mathsf{n}\neq\mathsf{m}
    }{
      \Gamma,\mathsf{n}[\vec i]=\mathsf{m}[\vec j]\vdash \phi
    }

    \inferrule{
      \Gamma, i_1=j_1, \ldots, i_k=j_k \vdash \phi
    }{
      \Gamma,\mathsf{n}[i_1,\ldots,i_k]=\mathsf{n}[j_1,\ldots,j_k]\vdash \phi
    }
    %
    % \inferrule{~}{
    %   \Gamma,t=\mathsf{n}[\vec i] \vdash \phi
    % }
  \end{mathpar}

  \textbf{Trace inference rules.}
  % \label{fig:trace-rules}
  \begin{mathpar}
    \inferrule{
      ~
    }{
      \Gamma, b[\vec{i}] \leq a[\vec{i}, \vec{j}] \vdash \phi
    }
    \quad\text{ when } a < b
    
    \inferrule{
      ~
    }{
      \Gamma, a[\vec{i}] = b[\vec{j}] \vdash \phi
    }
    \quad\text{ when } a \ne b

    \inferrule{
      ~
    }{
      \Gamma, \tau \ne \tinit \wedge \tau \le \tpred{\tau} \vdash \phi
    }

    \inferrule{
      \Gamma, \tau' = \pre(\tau) \vee \tau' = \tau \vdash \phi
    }{
      \Gamma, \pre(\tau)\leq\tau'\leq\tau \vdash \phi
    }

    \inferrule{
      \Gamma, \pvec{i}=\pvec{j} \vdash \phi
    }{
      \Gamma, a(\pvec{i})=a(\pvec{j}) \vdash \phi
    }

    \inferrule{
      \Gamma, \forall \tau'.~\tau'\leq \tau \Rightarrow \mcond@\tau \vdash \phi
    }{
      \Gamma, \mexec@\tau \vdash \phi
    }
  \end{mathpar}
  % `
  \medskip
  \textbf{Inference rules for exclusive or.}
  % % The tool does not follow these rules closely, but uses a more high-level
  % % congruence closure algorithm modulo xor. The last rule is not implementated
  % % at all and is here mostly for illustration purposes, and is subject to
  % % the condition that,
  % In the last rule, for any trace model $\TM$,
  % $\interp{\Gamma\vdash\phi}^\TM$ does not contain instances of the names
  % $\mathsf{n}$ and $\mathsf{m}$ and does not contain message variables.
  % This condition would be over-approximated in an implementation. \adrien{and $t$ must be of the same length than names.}
  % \adrien{Again, the last rule should be given in the next sub-section.}
  % \label{fig:xor-reach}
  \begin{mathpar}
    \inferrule{~}{\Gamma \vdash t\oplus t = 0}

    \inferrule{~}{\Gamma \vdash t\oplus t' = t'\oplus t}

    \inferrule{~}{\Gamma \vdash t\oplus (t'\oplus t'') = (t\oplus t')\oplus t''}

    % \inferrule{
    %   (\Gamma \vdash \phi)\{x\mapsto \mathsf{m}[\vec j]\}
    % }{
    %   (\Gamma \vdash \phi)\{x\mapsto t\oplus\mathsf{n}[\vec i]\}
    % }
  \end{mathpar}
  \caption{Sequent Calculus for Reachability}
  \label{fig:seq-reach}
\end{figure}

\paragraph{Trace Rules}
We have rules related to the trace semantics of our protocols.

\begin{proposition}
  For any protocol $\calp = (\calp_\sfA, \le)$, the trace inference rules in \cref{fig:seq-reach} are sound.
\end{proposition}


The first axiom holds because for any trace model, we asks that $\leq_\XT$ is compatible with the ordering $\leq$ over symbolic actions.
As $\pre$ is always interpreted as the natural notion of predecessor over some discrete sequence, the second axiom is natural. The next two axioms hold for all trace models, because we ask that the ordered sequence of concrete actions produced by $\leq_\XT$ represent an abstract trace of the protocol. This yields the injectivity axiom. The last axiom holds naturally by the definition of $\mexec$.

\paragraph{Exclusive-Or}
We handle the exclusive-or operator $\oplus$.

\begin{proposition}
  The exclusive-or rules of \cref{fig:seq-reach} are sound w.r.t.\ computational models
  where $\oplus$ is interpreted as exclusive or.
  % \emph{Do we need to impose a condition on message lengths?}
  % Adrien: no we dont, except for the last rule.
\end{proposition}

\subsection{Advanced Rules}
We now describe more the more advanced rules of our reachability sequent calculus. These rules deal with cryptographic assumptions, and probabilistic independence.

We recall the base logic \textsc{euf-cma} rule from~\cite{DBLP:conf/eurosp/Koutsos19}. Before starting, we introduce a notation we use to give syntax side-conditions of rules.
\begin{definition}
  \label{def:occ-sc}
  Let $C$ be a base logic many-holed context with one distinguished hole variable $\cdot$ that occurs exactly once in $C$. Let $u$ be a \textbf{ground} base logic term. For every term $s$, we let $s \tpos_{C} u$ holds whenever $s$ appears in $u$ only in subterms of the form $C[\pvec{w},s]$.
  % \[
  %   \forall p \in \pos(u), u_{|p} = s \ra
  %   \exists \pvec{w},
  %   \exists q \in \pos(u) \text{ s.t. }
  %   q \le p \wedge
  %   u_{|q} \equiv C[\pvec{w},s]
  % \]
\end{definition}

\begin{example}
  We give two examples:
  \begin{itemize}
  \item $\mathsf{n} \tpos_{\mypk(\cdot)} u$ states that the name $\mathsf{n}$ appears only in terms of the form $\mypk(\mathsf{n})$ in $u$.
  \item $\mysk(\mathsf{n}) \tpos_{\mydec(\_,\cdot)} u$ states that the secret key $\mysk(\mathsf{n})$ appears only in decryption position in $u$.
  \end{itemize}
\end{example}

We can now give the rule:
\begin{definition}
  \label{def:euf-base}
  For any ground base terms $s,u,m$ and name $sk$, we let \textsc{euf-cma} be the rule:
  \[
    \begin{gathered}[c]
      \inferrule% [\textsc{euf-cma}]
      {
        \textstyle
        \Gamma, \bigvee_{h(u,sk) \in \st(s,m)} m \deq u \vdash \phi
      }{
        \Gamma, s \deq h(m,sk) \vdash \phi
      }
    \end{gathered}
    \quad\text{ when }
      sk \tpos_{h(\_,\cdot)} s,m
  \]
\end{definition}

Roughly, it states that if $s$ is a valid hash of $m$, then $m$ must be equal to some honestly hashed message appearing in $s$ or $m$.

To lift the above rule to the meta-logic, we first lift the occurence side-condition $\tpos_{h(\_,\cdot)}$ of \cref{def:occ-sc} to terms of the meta-logic:

\begin{definition}
  \label{def:occ-sc-meta}
  Let $\calp$ be a protocol, $C$ be a macros-free context, and $u$ a term of the meta-logic with \textbf{no message variables}. For every term $s$, we let $s \tpos^{\calp}_{C} u$ holds if and only if $s \tpos_{C} \interp{u}^\TM$ holds in any $\calp$-trace model $\TM$.
  % Let $\calp$ be a protocol, and $C$ be a macros-free many-holed context with one distinguished hole variable $\cdot$ that occurs exactly once in $C$. Let $u$ be a term of the meta-logic with \textbf{no message variables}. For every macros-free term $s$ of the meta-logic, we let $s \tpos^{\calp}_{C} u$ holds if and only if $s \tpos^{\calp}_{C} \interp{u}^\TM$ holds in any $\calp$-trace model $\TM$.
\end{definition}

The base-logic side-condition $\tpos_{C}$ is fully syntactic, and can easily be implemented. This is no longer the case with $s \tpos^{\calp}_{C} u$, as it requires to check a property on all occurrences of $s$ in all interpretations $u$, in any $\calp$-trace model. Therefore, instead of checking directly whether $s \tpos^{\calp}_{C} u$, we are going to check the property on the direct occurrences of $s$ in $u$ (i.e.\ $s \tpos_{C} u$), and on the occurrences of $s$ in any action of the protocol. The idea is that this must over-approximate all occurrences of $s$ in any interpretation of $u$ in a $\calp$-trace model $\TM$. Actually, this is not true for any context $C$, because $C$ can be matched in $\interp{u}^\TM$ accross several macros unrolling. But this is true for well-behaved context $C$. 

\begin{definition}
  Let $\calp$ be a protocol. A context $C$ is $\calp$-well behaved if:
  \begin{itemize}
  \item $C$ has no subterms of sort $\idx$ or $\timestamp$;
  \item $C$ does not contain the function symbols $0$, $\true$, $\dand$, $\mathsf{if}$, $\att(\_)$ or $\langle \_,\_\rangle$;
  \item the function symbols appearing in $C$ (except for $C$ head symbol) do not appear in head position of any of the terms in $\{\phi_a,o_a,u^s_a \mid a \in \calp_{\sfA}, s \in\States\}$;
  \end{itemize}
\end{definition}

\david{Item 3 might be too restrictive. We need to check that what we're doing
in the code is sound, and formalize this.}

\begin{definition}
  Let $\calp$ be a protocol, and $C$ a $\calp$-well behaved context. For every $s$, we let $s \tpos_{C} \calp$ hold whenever $s \tpos_{C} \{\phi_a,o_a,u^s_a \mid a \in \calp_{\sfA}, s \in\States\}$.
\end{definition}

The following proposition gives a sufficient condition to check $s \tpos^{\calp}_{C} u$ for a $\calp$-well behaved context $C$.

\begin{proposition}
  Let $\calp$ be a protocol, and $C$ a $\calp$-well behaved context. Then for every $s,u$, if $s \tpos_{C} u$ and $s \tpos_{C} \calp_{\sfA}$ then $s \tpos^{\calp}_{C} u$.
\end{proposition}

\begin{proof}
  \adrien{If we keep the proposition, I will do the proof. }
\end{proof}

\begin{remark}
  This is not a necessary condition. For example, take a protocol $\calp = (\calp_\sfA,\le)$ that never leaks a key $sk$, except for some action $a$. Because of $a$, we do not have $sk \tpos_{\cdot} \calp$. But if the term $u$ uses only actions that must occur before $a$ (w.r.t. $\le$), then $sk \tpos^\calp_{\cdot} u$. In practice, we never had this problem, and the approximation above was always sufficient. If necessary, it can be made finer by considering only actions that can occur before $u$.
\end{remark}

Then, we need to characterize the set of all honest hashes that can appear in the interpretation of a term $s$ of the meta-logic:
\[
  S = \{u \mid h(u,sk) \in \st(\interp{s}^\TM),
  \TM \text{ a $\calp$-trace model}\}
\]
There are two issue there: the set $S$ can be infinite, and we must be able to compute it (or at least an over-approximation of it). As for $\tpos^{\calp}_{C}$, we look for all possible occurrences of $h(u,sk)$ either directly in $s$, or in an action $\sfa$ of $\calp$. In the latter case, we will also need a formula of the logic that characterizes the fact that $\sfa$ happened before the moment where $u$ was computed. This motivates the following definitions.

\begin{definition}
  For every terms $\tau_0$ of sort $\timestamp$ and term $u$ of the meta-logic, we define the happens-before formula of the meta-logic $\tau_0 \lehb u$:
  \begin{alignat*}{2}
    \tau_0 \lehb u &\;\;\overset{\text{def}}{=}\;\;&
    \bigvee_{m[\pvec{i}]@\tau \in \st(u)}
    \tau_0 \lehb m[\pvec{i}]@\tau\\
    \text{where }\tau_0 \lehb m[\pvec{i}]@\tau  &\;\;\overset{\text{def}}{=}\;\;&
    \begin{cases}
      \tau_0 < \tau &\text{ if } m = \minp\\
      \tau_0 \le \tau &\text{ otherwise}
    \end{cases}
  \end{alignat*} 
\end{definition}

\begin{definition}
  For every protocol $\calp$ and term $u$ of the meta-logic, we define:
  \begin{alignat*}{2}
    \ost_{\calp}(u) &\;\;=\;\;&&
    \left\{
      (t, \emptyset, \true) \mid t \in \st(u)
    \right\}
    \cup\\
    &&&\bigcup_{\sfa \in \calp_{\sfA}}
    \left\{
      (t, \vec{i}, \sfa[\vec{i}] \lehb u) \mid
      t \in \st\big(\{\phi_{\alpha},o_{\alpha},u^s_{\alpha} \mid s \in\States\},
      \alpha = \sfa[\vec{i}]
      \big)
    \right\}
  \end{alignat*}
  Where, for every entry, $\vec{i}$ is a vector of index variables, assumed fresh in $u$, and all disjoint.
\end{definition}

$\ost_{\calp}(u)$ is a set of triples $(t,\vec{i},c)$ such that, for any $\calp$-trace model $\TM$, the interpretation in $\TM$ of the terms of $\ost_{\calp}(u)$ such that $c$ holds in $\TM$ contains all the subterms of~$\interp{u}^\TM$. Moreover, $\vec{i}$ is the set of new (index) variables in $t$ and $c$: $\fv{t,c} \subseteq \fv{u} \cup \{\pvec{i}\}$.
\david{Note that $t$ can contain the ``bound indices'' $\vec{i}$ in the
second case. We are however not trying to formalize the situation where
occurrences have indices bound by constructs inside the action descriptions.}

\begin{proposition}
  \label{prop:ost-sound}
  For any protocol $\calp$ and term $u$ of the meta-logic, the set $\ost_{\calp}(u)$ is finite. Moreover, for any $\calp$-trace model $\TM = (\D_\I, \D_\XT, \leq_\XT, \sigma_\I, \sigma_\XT)$:
  \[
    \st(\interp{u}^\TM) \subseteq
    \left\{
      \interp{t}^{\TM'}
      \mid
      \pvec{e} \subseteq \D_\I,\;
      \TM' = \TM[\pvec{i}\mapsto\pvec{e}],\;
      (t,\pvec{i},c) \in \ost_{\calp}(u),\;
      \TM' \models \interp{c}^{\TM'}
    \right\}
  \]
\end{proposition}

\begin{proof}
  The finiteness property is immediate. The second point is harder.   \adrien{If we keep the proposition, I will do the proof. }
\end{proof}


\newcommand{\eufcma}{\textsc{EUF-CMA}}

We can now state the meta-logic version of the $\eufcma$ rule of \cref{def:euf-base}.
\begin{proposition}
  Let $\calp = (\calp_{\sfa}, \le)$ be a protocol.  In any computational model where $h$ is interpreted as a $\eufcma$ keyed hash-function, the following rule is valid: % for all term $t,m$ and name $sk$ such that all ocurences of $sk$ in $t$ or $\calp$ are of the form $h(\_,sk)$:
  \[
    \inferrule{
      \textstyle
      \Gamma,
      \bigvee_{(h(u,sk),\vec{i},c) \in \ost_{\calp}(t,m)}
      \exists \vec{i},
      c \wedge u = m \vdash \phi
    }{
      \Gamma, t=h(m,sk) \vdash \phi
    }
    \quad\text{ when }
    sk \tpos^{\calp}_{h(\_,\cdot)} t,m
  \]
  % \begin{gather*}
  %   \inferrule{
  %     \textstyle
  %     \Gamma,
  %     \bigvee_{h(x,sk) \in \st(t)} m=x  \vdash \phi
  %   }{
  %     \Gamma, t=h(m,sk) \vdash \phi
  %   }
  %   \tag{if $t$ contains no macros}\\
  %   \inferrule{
  %     \textstyle
  %     \Gamma,
  %     \bigvee_{\sfa \in \calp_{\sfA}, \vec{i} \text{ fresh}}
  %     \bigvee_{h(x,sk) \in o_{\sfa}[\pvec{i}] }
  %     \big(
  %     m=x \wedge \sfa(\vec{i}) < \tau\big)
  %     \vdash \phi
  %   }{
  %     \Gamma, \minp@\tau=h(m,sk) \vdash \phi
  %   }
  %   \tag{macros case}
  % \end{gather*}
\end{proposition}

\begin{proof}
  \adrien{Todo: reduce the meta-logic rule to the base logic rule using \cref{prop:ost-sound} (plus something similar for the syntactic side-condition).}
\end{proof}


\begin{figure}[t]
  \[
    \begin{array}{|l|l|}
      \hline
      \text{Base logic Rule} &
      \text{Meta-logic Rule}\\
      \hline
      \inferrule{~}{
        \Gamma, t = \mathsf{n} \vdash \phi
      }
      \text{ when }
      \mathsf{n} \not \in \st(t)
      &
      \inferrule{~\\\\
        \textstyle
        \Gamma,
        \bigvee_{(\mathsf{n}[\vec{j}],\vec{k},c) \in \ost_{\calp}(t)}
        \exists \vec{k},
        c \wedge \vec{i} = \vec{j}
        \vdash \phi
      }{
        \Gamma, t = \mathsf{n}[\vec{i}]\vdash \phi
      }
      \\\hline
    \end{array}
  \]
  \caption{Base Logic and Corresponding Meta-Logic Rules.}

\end{figure}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
