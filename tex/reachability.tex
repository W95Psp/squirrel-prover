\section{Trace properties}

\subsection{Validity and logical consequence}

We have defined a translation from any meta-logic formula $\phi$ to a base logic
boolean term $\interp{\phi}^\TM$. We can now formally define when a protocol
satisfies some trace property $\phi$.  Intuitively, the meta-logic formula is
true when the associated term is true with overwhelming probability in any trace model. % This is made formal in the following definitions.
\begin{definition}
  % Given a protocol $P$, a formula $\phi$ of the meta-logic is said to be valid
  % when, for any trace model $\TM$, the base logic formula
  % $(\phi)^\TM \sim \true$ is valid. \adrien{$P$ is not used in this sentence.}
  % A formula $\phi$ of the meta-logic is valid if for any trace model $\TM$, the base logic formula $(\phi)^\TM \sim \true$ is valid.
  %
  % More generally, a meta-logic formula $\phi$ is a
  % logical consequence of a set $S$ of base logic formulas
  % % (which might themselves be of the form $\interp{\psi}^\TM \sim \true$)
  % when, for all $\TM$, $\Mo$ and $\sigma$ such that
  % $\Mo,\sigma \models \psi$ for all $\psi\in S$,
  % we have
  % $\Mo,\sigma \models(\phi)^\TM\sim\mathsf{true}$.
  Let $\phi$ be a meta-formula. Then for every trace model $\TM$, computational model $\Mo$ and interpretation $\sigma$, $\TM, \Mo, \sigma \models \phi$ if $\Mo, \sigma \models (\phi)^{\TM} \sim \true$.

  We say that $\phi$ is valid if $\TM, \Mo, \sigma \models \phi$ for every $\TM$, $\Mo$, $\sigma$, and for any set of meta-formulas $S$, $S \models \phi$ if for every $\TM$, $\Mo$, $\sigma$ such that $\TM, \Mo, \sigma \models S$, we have $\TM, \Mo, \sigma \models \phi$.
  % we omit $\sigma$ when it is empty (i.e.\ when $\phi$ has no free message variables).
\end{definition}

\begin{remark}
  In the tool, we only allow universal quantification over messages, and
  only allow it at toplevel. The validity of such formulas is the same as
  when the variables are left free.
\end{remark}

In practice, we want to verify that a security property expressed as a
meta-logic formula $\phi$ is satisfied in a class of trace models
$\TM$ and computational models $\Mo$: we will typically restrict computational
models so that cryptographic primitives satisfy some security assumption,
but we may also restrict trace models e.g.\ to force a condition on
abstract traces. In order to verify security in such a class of models,
we will identify axioms that hold in these models, and verify that our
security property is a logical consequence of these axioms.

\begin{remark}
  We have defined a notion of validity that implies that a formula must hold for all abstract traces. Abstract traces can contain actions that are not executable, and we can thus write formulas about outputs that may never be performed. In practice, we will often prove the validity of formulas of the form $\mexec@T \Rightarrow \phi$. This implies that the trace is executable, and allows us to reason over the conditions of the actions.
\end{remark}

\subsection{Sequent calculus}

In the tool, sequents come with an environment which explicitly
declares all the variables that might occur free in the sequent's formulas.
For simplicity, we do not include them here. We shall write $\vdash t:\Sort$
when $t$ is a term of sort $\Sort$ (which might be $\idx$ or $\timestamp$).

\begin{definition}
  A sequent $\Gamma \vdash \phi$ is composed of a set of meta-logic formulas
  $\Gamma$ and a meta-logic formula $\phi$.
  % It is valid when the meta-logic formula
  % $(\wedge\Gamma) \Rightarrow \phi$ is valid.
  The sequent $\Gamma \vdash \phi$ is valid if $\Gamma \models \phi$.
\end{definition}


\paragraph{Base Logic Subterms of all Instantiations of a Meta-Term}
We recall the base logic \textsc{euf-cma} rule from~\cite{DBLP:conf/eurosp/Koutsos19}. Before starting, we introduce a notation we use to give syntax side-conditions of rules.
\begin{definition}
  \label{def:occ-sc}
  Let $C$ be a base logic many-holed context with one distinguished hole variable $\cdot$ that occurs exactly once in $C$. Let $u$ be a \textbf{ground} base logic term. For every term $s$, we let $s \tpos_{C} u$ holds whenever $s$ appears in $u$ only in subterms of the form $C[\pvec{w},s]$.
  % \[
  %   \forall p \in \pos(u), u_{|p} = s \ra
  %   \exists \pvec{w},
  %   \exists q \in \pos(u) \text{ s.t. }
  %   q \le p \wedge
  %   u_{|q} \equiv C[\pvec{w},s]
  % \]
\end{definition}

\begin{example}
  We give two examples:
  \begin{itemize}
  \item $\mathsf{n} \tpos_{\mypk(\cdot)} u$ states that the name $\mathsf{n}$ appears only in terms of the form $\mypk(\mathsf{n})$ in $u$.
  \item $\mysk(\mathsf{n}) \tpos_{\mydec(\_,\cdot)} u$ states that the secret key $\mysk(\mathsf{n})$ appears only in decryption position in $u$.
  \end{itemize}
\end{example}

We can now give the rule:
\begin{definition}
  For any ground base terms $s,u,m$ and name $sk$, we let \textsc{euf-cma} be the rule:
  \[
    \begin{gathered}[c]
      \inferrule% [\textsc{euf-cma}]
      {~}{
        s \deq h(m,sk) \dimpl
        \bigvee_{u \in S} s \deq u
      }
    \end{gathered}
    \quad\text{ when }
    \begin{cases}
      sk \tpos_{h(\_,\cdot)} s,m\\
      S = \{u \mid h(u,sk) \in \st(s,m)\}
    \end{cases}
  \]
\end{definition}

To lift the above rule to the meta-logic, we first lift the occurence side-condition $\tpos_{h(\_,\cdot)}$ of \cref{def:occ-sc} to terms of the meta-logic:

\begin{definition}
  \label{def:occ-sc-meta}
  Let $\calp$ be a protocol, $C$ be a macros-free context, and $u$ a term of the meta-logic with \textbf{no message variables}. For every term $s$, we let $s \tpos^{\calp}_{C} u$ holds if and only if $s \tpos^{\calp}_{C} \interp{u}^\TM$ holds in any $\calp$-trace model $\TM$.
  % Let $\calp$ be a protocol, and $C$ be a macros-free many-holed context with one distinguished hole variable $\cdot$ that occurs exactly once in $C$. Let $u$ be a term of the meta-logic with \textbf{no message variables}. For every macros-free term $s$ of the meta-logic, we let $s \tpos^{\calp}_{C} u$ holds if and only if $s \tpos^{\calp}_{C} \interp{u}^\TM$ holds in any $\calp$-trace model $\TM$.
\end{definition}

The base-logic side-condition $\tpos_{C}$ is fully syntactic, and can easily be implemented. This is no longer the case with $s \tpos^{\calp}_{C} u$, as it requires to check a property on all occurrences of $s$ in all interpretations $u$, in any $\calp$-trace model. Therefore, instead of checking directly whether $s \tpos^{\calp}_{C} u$, we are going to check the property on the direct occurrences of $s$ in $u$ (i.e.\ $s \tpos_{C} u$), and on the occurrences of $s$ in any action of the protocol. The idea is that this must over-approximate all occurrences of $s$ in any interpretation of $u$ in a $\calp$-trace model $\TM$. Actually, this is not true for any context $C$, because $C$ can be matched in $\interp{u}^\TM$ accross several macros unrolling. But this is true for well-behaved context $C$. 

\begin{definition}
  Let $\calp$ be a protocol. A context $C$ is $\calp$-well behaved if:
  \begin{itemize}
  \item $C$ has no subterms of sort $\idx$ or $\timestamp$;
  \item $C$ does not contain the function symbols $0$, $\true$, $\dand$, $\mathsf{if}$, $\att(\_)$ or $\langle \_,\_\rangle$;
  \item the function symbols appearing in $C$ (except for $C$ head symbol) do not appear in head position of any of the terms in $\{\phi_a,o_a,u^s_a \mid a \in \calp_{\sfA}, s \in\States\}$;
  \end{itemize}
\end{definition}

\begin{definition}
  Let $\calp$ be a protocol, and $C$ a $\calp$-well behaved context. For every $s$, we let $s \tpos_{C} \calp$ hold whenever $s \tpos_{C} \{\phi_a,o_a,u^s_a \mid a \in \calp_{\sfA}, s \in\States\}$.
\end{definition}

The following proposition gives a sufficient condition to check $s \tpos^{\calp}_{C} u$ for a $\calp$-well behaved context $C$.

\begin{proposition}
  Let $\calp$ be a protocol, and $C$ a $\calp$-well behaved context. Then for every $s,u$, if $s \tpos_{C} u$ and $s \tpos_{C} \calp_{\sfA}$ then $s \tpos^{\calp}_{C} u$.
\end{proposition}

\begin{proof}
  \adrien{If we keep the proposition, I will do the proof. }
\end{proof}

\begin{remark}
  This is not a necessary condition. For example, take a protocol $\calp = (\calp_\sfA,\le)$ that never leaks a key $sk$, except for some action $a$. Because of $a$, we do not have $sk \tpos_{\cdot} \calp$. But if the term $u$ uses only actions that must occur before $a$ (w.r.t. $\le$), then $sk \tpos^\calp_{\cdot} u$. In practice, we never had this problem, and the approximation above was always sufficient. If necessary, it can be made finer by considering only actions that can occur before $u$.
\end{remark}

Then, we need to characterize the set of all occurences of a term in a meta-logic term.

\adrien{TODO}


\paragraph{Sequent Calculus}
We can now give the rules of our meta-logic sequent calculus, and prove their soundness.
\begin{proposition}
  The rules of \cref{fig:lk,fig:names} are sound: if the premisses are valid,
  then so is the conclusion.
\end{proposition}

% TO BE REMOVED
\clearpage

\begin{figure}
  \begin{mathpar}
    \inferrule[Axiom]{~}{\Gamma,\phi\vdash\phi}
    \quad\quad
    \inferrule[Cut]{
      \Gamma \vdash \phi
      \quad
      \Gamma,\phi \vdash \psi
    }{
      \Gamma \vdash \psi
    }
  \end{mathpar}
  \begin{mathpar}
  \inferrule[${\wedge}$-L]{
    \Gamma,\phi,\phi'\vdash\psi
  }{
    \Gamma,\phi\wedge\phi'\vdash\psi
  }
  \quad\quad
  \inferrule[${\wedge}$-R]{
    \Gamma \vdash \phi
    \quad
    \Gamma \vdash \phi'
  }{
    \Gamma \vdash \phi\wedge\phi'
  }
  \end{mathpar}
  \begin{mathpar}
    \inferrule[${\lnot}$-R]{
      \Gamma, \phi \vdash \bot
    }{
      \Gamma \vdash \lnot\phi
    }
    \quad\quad
    \inferrule[${\lnot}$-L]{
      \Gamma \vdash \phi
    }{
      \Gamma,\lnot\phi \vdash \psi
    }
    \quad\quad
    \inferrule[Raa]{
      \Gamma, \lnot\phi \vdash \bot
    }{
      \Gamma \vdash \phi
    }
  \end{mathpar}
  \begin{center}
  \emph{other propositional rules of classical sequent calculus}
  \end{center}
  \begin{mathpar}
      \inferrule[${=}$-R]{~}{\Gamma \vdash t=t} \quad\quad
      \inferrule[${=}$-L]{
        (\Gamma\vdash\phi)\{x\mapsto t',x'\mapsto t\}
      }{
        t=t', \Gamma\{x\mapsto t,x'\mapsto t'\} \vdash
        \phi\{x\mapsto t,x'\mapsto t'\}
      }
  \end{mathpar}
  \begin{mathpar}
     \inferrule[$\forall$-L]{
       \Gamma,\phi\{x\mapsto t\} \vdash \psi
       \quad
       \vdash t:\Sort
     }{
       \Gamma,\forall x:\Sort.\phi \vdash \psi}
     \quad\quad
     \inferrule[$\forall$-R]{
       \Gamma \vdash \phi}{\Gamma \vdash \forall x:\Sort:\phi}
  \end{mathpar}
   \caption{Generic inference rules. These are the rules of classical
   first-order sequent calculus. In \textsc{$\forall$-R} we require that
   $x$ does not appear free in $\Gamma$.}
   \label{fig:lk}
\end{figure}

\begin{figure}
  \begin{mathpar}
  \inferrule{
    \mathsf{n}\neq\mathsf{m}
  }{
    \Gamma,\mathsf{n}[\vec i]=\mathsf{m}[\vec j]\vdash \phi
  }
  \quad\quad
  \inferrule{
    \Gamma, i_1=j_1, \ldots, i_k=j_k \vdash \phi
  }{
    \Gamma,\mathsf{n}[i_1,\ldots,i_k]=\mathsf{n}[j_1,\ldots,j_k]\vdash \phi
  }
  \end{mathpar}
  \begin{mathpar}
    \inferrule{~}{
      \Gamma,t=\mathsf{n}[\vec i] \vdash \phi
    }
  \end{mathpar}
  \caption{Inference rules for equalities on names.
  The last rule only applies when, for any trace model $\TM$,
  the term $\interp{t}^\TM$ does not contain any message variable and does
  not contain any occurrence of $\mathsf{n}_{\sigma_\I(\vec i)}$
  --- this condition will be over-approximated in our implementation.}
  \label{fig:names}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \inferrule{
      \Gamma,% t=\mathsf{n}[\vec {j_0}],
      \big(
        \bigvee_{\mathsf{n}[\vec j] \in t}
          \exists \vec j_b, \vec j = \vec {j_0}
      \big)
      \vee
      \big(
        \bigvee_{A(\vec i) \in S}
          \big(
            \bigvee_{\mathsf{n}[\vec j] \in A(\vec i)}
              \exists \vec i, \vec j_b,
              \big( \bigvee_{\tau \in t}
                A(\vec i) \leq \tau
              \big)
              \wedge
              \big( \vec j = \vec {j_0} \big)
          \big)
      \big)
      \vdash \phi
    }{
      \Gamma,t=\mathsf{n}[\vec {j_0}] \vdash \phi
    }
  \end{mathpar}
  \center{
    where $\vec j_b$ represents indices from $\vec j$ that are bound
    (in $t$ for direct cases, in the action for indirect cases)
  }
  \caption{Another inference rule for equalities on names.
  This rule only applies when, for any trace model $\TM$,
  the term $\interp{t}^\TM$ does not contain any message variable.
  If $\tau$ refers to an input macro, then the inequality over timestamps
  is strict.}
\adrien{What is $S$ in the rule? The condition \textit{If $\tau$ refers to an input macro [...]} is not very nice.}
\end{figure}

\begin{proposition}
  The rules of \cref{fig:xor-reach} are sound w.r.t.\ computational models
  where $\oplus$ is interpreted as exclusive or:
  if the premisses are valid in all such computational models,
  then so is the conclusion.
  % \emph{Do we need to impose a condition on message lengths?}
  % Adrien: no we dont, except for the last rule.
\end{proposition}

\begin{figure}
  \begin{mathpar}
    \inferrule{~}{\Gamma \vdash t\oplus t = 0}
    \quad\quad
    \inferrule{~}{\Gamma \vdash t\oplus t' = t'\oplus t}
    \quad\quad
    \inferrule{~}{\Gamma \vdash t\oplus (t'\oplus t'') = (t\oplus t')\oplus t''}
  \end{mathpar}
  \begin{mathpar}
    \inferrule{
      (\Gamma \vdash \phi)\{x\mapsto \mathsf{m}[\vec j]\}
    }{
      (\Gamma \vdash \phi)\{x\mapsto t\oplus\mathsf{n}[\vec i]\}
    }
  \end{mathpar}
  \caption{Inference rules for exclusive or.
  The tool does not follow these rules closely, but uses a more high-level
  congruence closure algorithm modulo xor. The last rule is not implementated
  at all and is here mostly for illustration purposes, and is subject to
  the condition that, for any trace model $\TM$,
  $\interp{\Gamma\vdash\phi}^\TM$ does not contain instances of the names
  $\mathsf{n}$ and $\mathsf{m}$ and does not contain message variables.
  This condition would be over-approximated in an implementation. \adrien{There is another condition: $t$ must be of the same length than names.}}
  \label{fig:xor-reach}
\end{figure}

\newcommand{\eufcma}{\textsc{EUF-CMA}}
\begin{proposition}
  Let $\calp = (\calp_{\sfa}, \le)$ be a protocol.  In any computational model where $h$ is interpreted as a $\eufcma$ keyed hash-function, the following rule is valid for all term $t,m$ and name $sk$ such that all ocurences of $sk$ in $t$ or $\calp$ are of the form $h(\_,sk)$:
  \begin{gather*}
    \inferrule{
      \textstyle
      \Gamma,
      \bigvee_{h(x,sk) \in \st(t)} m=x  \vdash \phi
    }{
      \Gamma, t=h(m,sk) \vdash \phi
    }
    \tag{if $t$ contains no macros}\\
    \inferrule{
      \textstyle
      \Gamma,
      \bigvee_{\sfa \in \calp_{\sfA}, \vec{i} \text{ fresh}}
      \bigvee_{h(x,sk) \in o_{\sfa}[\pvec{i}] }
      \big(
      m=x \wedge \sfa(\vec{i}) < \tau\big)
      \vdash \phi
    }{
      \Gamma, \minp@\tau=h(m,sk) \vdash \phi
    }
    \tag{macros case}
  \end{gather*}
\end{proposition}

\subsection{Trace axioms}

We now identify some valid formulas, which can thus be used as axioms
when trying to derive a trace property. \adrien{Why don't we present these rules as axioms then?}

\begin{proposition}
  The following formulas are valid w.r.t.\ the protocol:
  \begin{itemize}
    \item for any $\alpha \leq \beta$ (partial ordering of the symbolic actions imposed by the protocol), $\alpha \leq \beta$.

    \item
      $\forall \tau.~ \pre(\tau)<\tau \wedge
      \forall \tau'.~ \pre(\tau)\leq\tau'<\tau \Rightarrow
      \tau'=\pre(\tau)$; \adrien{this is not true for init}
    \item for any $a\neq b\in\Act$,
      $\forall \ov{i},\ov{j}, a(\ov{i})\neq b(\ov{j})$; \adrien{we already have an axiom for this one}
    \item for any $a\in\Act$,
      $\forall \ov{i},\ov{j}, a(\ov{i})=a(\ov{j}) \Rightarrow \ov{i}=\ov{j}$.
      \adrien{idem}
      \item $\forall \tau.~ \mexec@\tau \Rightarrow \forall \tau'.~\tau'\leq \tau \Rightarrow \mcond@\tau$
  \end{itemize}
\end{proposition}


The first axiom holds because for any trace model, we asks that $\leq_\XT$ is compatible with the ordering $\leq$ over symbolic actions.
As $\pre$ is always interpreted as the natural notion of predecessor over some discrete sequence, the second axiom is natural. The next two axioms hold for all trace models, because we ask that the ordered sequence of concrete actions produced by $\leq_\XT$ represent an abstract trace of the protocol. This yields the injectivity axiom. The last axiom holds naturally by the definition of $\mexec$.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
