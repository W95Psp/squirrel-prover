\section{Trace properties}

\subsection{Validity and logical consequence}

We have defined a translation from any meta-logic formula $\phi$ to a base logic
boolean term $\interp{\phi}^\TM$. We can now formally define when a protocol
satisfies some trace property $\phi$.  Intuitively, the meta-logic formula is
true when the associated term is true with overwhelming probability. This is
made formal in the following definitions.


\begin{definition}
  Given a protocol $P$, a formula $\phi$ of the meta-logic is said to be valid
  when, for any trace model $\TM$, the base logic formula
  $(\phi)^\TM \sim \true$ is valid.

  More generally, a meta-logic formula $\phi$ is a
  logical consequence of a set $S$ of base logic formulas
  (which might themselves be of the form $\interp{\psi}^\TM \sim \true$)
  when, for all $\TM$, $\Mo$ and $\sigma$ such that
  $\Mo,\sigma \models \psi$ for all $\psi\in S$,
  we have
  $\Mo,\sigma \models(\phi)^\TM\sim\mathsf{true}$.
\end{definition}

\begin{remark}
  In the tool, we only allow universal quantification over messages, and
  only allow it at toplevel. The validity of such formulas is the same as
  when the variables are left free.
\end{remark}

In practice, we want to verify that a security property expressed as a
meta-logic formula $\phi$ is satisfied in a class of trace models
$\TM$ and computational models $\Mo$: we will typically restrict computational
models so that cryptographic primitives satisfy some security assumption,
but we may also restrict trace models e.g.\ to force a condition on
abstract traces. In order to verify security in such a class of models,
we will identify axioms that hold in these models, and verify that our
security property is a logical consequence of these axioms.

\begin{remark}
  We have defined a notion of validity that implies that a formula must hold for all abstract traces. Abstract traces can contain actions that are not executable, and we can thus write formulas about outputs that may never be performed. In practice, we will often prove the validity of formulas of the form $\mexec@T \Rightarrow \phi$. This implies that the trace is executable, and allows us to reason over the conditions of the actions.
\end{remark}

\subsection{Sequent calculus}

In the tool, sequents come with an environment which explicitly
declares all the variables that might occur free in the sequent's formulas.
For simplicity, we do not include them here. We shall write $\vdash t:\Sort$
when $t$ is a term of sort $\Sort$ (which might be $\idx$ or $\timestamp$).

\begin{definition}
  A sequent $\Gamma \vdash \phi$ is composed of a set of meta-logic formulas
  $\Gamma$ and a meta-logic formula $\phi$.
  It is valid when the meta-logic formula
  $(\wedge\Gamma) \Rightarrow \phi$ is valid.
\end{definition}

\begin{proposition}
  The rules of \cref{fig:lk,fig:names} are sound: if the premisses are valid,
  then so is the conclusion.
\end{proposition}

\begin{figure}
  \begin{mathpar}
    \inferrule[Axiom]{~}{\Gamma,\phi\vdash\phi}
    \quad\quad
    \inferrule[Cut]{
      \Gamma \vdash \phi
      \quad
      \Gamma,\phi \vdash \psi
    }{
      \Gamma \vdash \psi
    }
  \end{mathpar}
  \begin{mathpar}
  \inferrule[${\wedge}$-L]{
    \Gamma,\phi,\phi'\vdash\psi
  }{
    \Gamma,\phi\wedge\phi'\vdash\psi
  }
  \quad\quad
  \inferrule[${\wedge}$-R]{
    \Gamma \vdash \phi
    \quad
    \Gamma \vdash \phi'
  }{
    \Gamma \vdash \phi\wedge\phi'
  }
  \end{mathpar}
  \begin{mathpar}
    \inferrule[${\lnot}$-R]{
      \Gamma, \phi \vdash \bot
    }{
      \Gamma \vdash \lnot\phi
    }
    \quad\quad
    \inferrule[${\lnot}$-L]{
      \Gamma \vdash \phi
    }{
      \Gamma,\lnot\phi \vdash \psi
    }
    \quad\quad
    \inferrule[Raa]{
      \Gamma, \lnot\phi \vdash \bot
    }{
      \Gamma \vdash \phi
    }
  \end{mathpar}
  \begin{center}
  \emph{other propositional rules of classical sequent calculus}
  \end{center}
  \begin{mathpar}
      \inferrule[${=}$-R]{~}{\Gamma \vdash t=t} \quad\quad
      \inferrule[${=}$-L]{
        (\Gamma\vdash\phi)\{x\mapsto t',x'\mapsto t\}
      }{
        t=t', \Gamma\{x\mapsto t,x'\mapsto t'\} \vdash
        \phi\{x\mapsto t,x'\mapsto t'\}
      }
  \end{mathpar}
  \begin{mathpar}
     \inferrule[$\forall$-L]{
       \Gamma,\phi\{x\mapsto t\} \vdash \psi
       \quad
       \vdash t:\Sort
     }{
       \Gamma,\forall x:\Sort.\phi \vdash \psi}
     \quad\quad
     \inferrule[$\forall$-R]{
       \Gamma \vdash \phi}{\Gamma \vdash \forall x:\Sort:\phi}
  \end{mathpar}
   \caption{Generic inference rules. These are the rules of classical
   first-order sequent calculus. In \textsc{$\forall$-R} we require that
   $x$ does not appear free in $\Gamma$.}
   \label{fig:lk}
\end{figure}

\begin{figure}
  \begin{mathpar}
  \inferrule{
    \mathsf{n}\neq\mathsf{m}
  }{
    \Gamma,\mathsf{n}[\vec i]=\mathsf{m}[\vec j]\vdash \phi
  }
  \quad\quad
  \inferrule{
    \Gamma, i_1=j_1, \ldots, i_k=j_k \vdash \phi
  }{
    \Gamma,\mathsf{n}[i_1,\ldots,i_k]=\mathsf{n}[j_1,\ldots,j_k]\vdash \phi
  }
  \end{mathpar}
  \begin{mathpar}
    \inferrule{~}{
      \Gamma,t=\mathsf{n}[\vec i] \vdash \phi
    }
  \end{mathpar}
  \caption{Inference rules for equalities on names.
  The last rule only applies when, for any trace model $\TM$,
  the term $\interp{t}^\TM$ does not contain any message variable and does
  not contain any occurrence of $\mathsf{n}_{\sigma_\I(\vec i)}$
  --- this condition will be over-approximated in our implementation.}
  \label{fig:names}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \inferrule{
      \Gamma,t=\mathsf{n}[\vec {j_0}],
      \big(
        \bigvee_{\mathsf{m}[\vec j] \in t}
          \mathsf{m}[\vec j] = \mathsf{n}[\vec {j_0}]
      \big)
      \vee
      \big(
        \bigvee_{\tau \in t}
          \big(
            \bigvee_{A(\vec i) \in S, \mathsf{n}[\vec j] \in A(\vec i)}
              A(\vec i\{\vec j \mapsto \vec {j_0}\}) \leq \tau
          \big)
      \big)
      \vdash \phi
    }{
      \Gamma,t=\mathsf{n}[\vec {j_0}] \vdash \phi
    }
  \end{mathpar}
  \caption{Another inference rule for equalities on names.
  This rule only applies when, for any trace model $\TM$,
  the term $\interp{t}^\TM$ does not contain any message variable.
  If $\tau$ refers to an input macro, then the inequality over timestamps
  is strict.}
\end{figure}

\begin{proposition}
  The rules of \cref{fig:xor} are sound wrt.\ computational models
  where $\oplus$ is interpreted as exclusive or:
  if the premisses are valid in all such computational models,
  then so is the conclusion.
  \emph{Do we need to impose a condition on message lengths?}
\end{proposition}

\begin{figure}
  \begin{mathpar}
    \inferrule{~}{\Gamma \vdash t\oplus t = 0}
    \quad\quad
    \inferrule{~}{\Gamma \vdash t\oplus t' = t'\oplus t}
    \quad\quad
    \inferrule{~}{\Gamma \vdash t\oplus (t'\oplus t'') = (t\oplus t')\oplus t''}
  \end{mathpar}
  \begin{mathpar}
    \inferrule{
      (\Gamma \vdash \phi)\{x\mapsto \mathsf{m}[\vec j]\}
    }{
      (\Gamma \vdash \phi)\{x\mapsto t\oplus\mathsf{n}[\vec i]\}
    }
  \end{mathpar}
  \caption{Inference rules for exclusive or.
  The tool does not follow these rules closely, but uses a more high-level
  congruence closure algorithm modulo xor. The last rule is not implementated
  at all and is here mostly for illustration purposes, and is subject to
  the condition that, for any trace model $\TM$,
  $\interp{\Gamma\vdash\phi}^\TM$ does not contain instances of the names
  $\mathsf{n}$ and $\mathsf{m}$ and does not contain message variables.
  This condition would be over-approximated in an implementation.}
  \label{fig:xor}
\end{figure}

\newcommand{\eufcma}{\textsc{EUF-CMA}}
\begin{proposition}
Let $P$ be a protocol.  In any computational model where $h$ is interpreted as a $\eufcma$ keyed hash-function, the following rule is valid for all term $t,m$ and name $sk$ such that all ocurences of $sk$ in $t$ or $P$ are of the form $h(\_,sk)$:
  \begin{mathpar}
    \inferrule{
      (\Gamma,
      \big(\bigvee_{h(x,sk) \in t} m=x \big)
    }{
      (\Gamma, t=h(m,sk) \vdash \phi)
    }
  \end{mathpar}
    \begin{mathpar}
    \inferrule{
      (\Gamma,
      \big(\bigvee_{A(\vec{i}) \in S} \bigvee_{h(x,sk) \in o_{A(\vec{i})} } m=x \wedge A(\vec{i}) \leq \tau\big)
      ,\vdash \phi)
    }{
      (\Gamma, \minp@\tau=h(m,sk) \vdash \phi)
    }
    \end{mathpar}
  \end{proposition}
\subsection{Trace axioms}

We now identify some valid formulas, which can thus be used as axioms
when trying to derive a trace property.

\begin{proposition}
  The following formulas are valid w.r.t.\ the protocol:
  \begin{itemize}
    \item for any $\alpha \leq \beta$ (partial ordering of the symbolic actions imposed by the protocol), $\alpha \leq \beta$.

    \item
      $\forall \tau.~ \pre(\tau)<\tau \wedge
      \forall \tau'.~ \pre(\tau)\leq\tau'<\tau \Rightarrow
      \tau'=\pre(\tau)$;
    \item for any $a\neq b\in\Act$,
      $\forall \ov{i},\ov{j}, a(\ov{i})\neq b(\ov{j})$;
    \item for any $a\in\Act$,
      $\forall \ov{i},\ov{j}, a(\ov{i})=a(\ov{j}) \Rightarrow \ov{i}=\ov{j}$.
      \item $\forall \tau.~ \mexec@\tau \Rightarrow \forall \tau'.~\tau'\leq \tau \Rightarrow \mcond@\tau$
  \end{itemize}
\end{proposition}


The first axiom holds because for any trace model, we asks that $\leq_\XT$ is compatible with the ordering $\leq$ over symbolic actions.
As $\pre$ is always interpreted as the natural notion of predecessor over some discrete sequence, the second axiom is natural. The next two axioms hold for all trace models, because we ask that the ordered sequence of concrete actions produced by $\leq_\XT$ represent an abstract trace of the protocol. This yields the injectivity axiom. The last axiom holds naturally by the definition of $\mexec$.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
