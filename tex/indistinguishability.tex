% Move to macros.tex
\newcommand{\lreach}[1]{\textsf{l-reach}(#1)}
\newcommand{\rreach}[1]{\textsf{r-reach}(#1)}
\newcommand{\phifresh}[3]{\textsf{n-fresh}_{#1}(#2; #3)}
\newcommand{\phihfresh}[4]{\textsf{h-fresh}_{#1}^{#2}(#3; #4)}

\section{Indistinguishability}

\newcommand{\pair}[1]{\langle #1 \rangle}

% We now define indistinguishability of processes, and how we could verify it.
% We make a distinction between symbolic and observable traces:
% symbolic ones are sequences of action names as in \cref{def:trace},
% while observable traces are sequences of pairs $\pair{c_i,c_o}$.
% Intuitively, such a pair describes the input and output channels of an
% action; several actions might have the same input and output channels.
% We write $A : \pair{c_i,c_o}$ when action $A$ inputs on channel $c_i$ and
% outputs on channel $c_o$.

% For convenience, we talk of processes, though in reality the definitions
% deal with abstract systems described by sets of actions.

\newcommand{\fold}{\mathsf{fold}}

% \begin{definition}
%   Given an observable trace $t$ and a process $P$,
%   we define $\fold(P,t)$ as the frame describing all possible
%   executions of $P$ along $t$:
%   \begin{eqnarray*}
%     \fold(P,\epsilon) &=& \epsilon \\
%     \fold(P,(c_i,c_o).t') &=&
%     \mathsf{if}_{A:(c_i,c_o)}
%     \ldots
%   \end{eqnarray*}
% \end{definition}

% \begin{definition}
%   Two processes $P$ and $Q$ are indistinguishable when,
%   for all observable traces $t$,
%   for all computational model $\Mo$,
%   we have
%   $\Mo \models \fold(P,t) \sim \fold(Q,t)$.
%   This itself means that no attacker can distinguish,
%   with non-negligible probability, between the left- and right-hand sides.
% \end{definition}

% This notion of equivalence should coincide with the usual computational
% indistinguishability for bounded processes. In the unbounded case, it
% is restrictive to quantify on traces in this way
% and ask for indistinguishability only for each trace.

\begin{definition}
  A meta-logic equivalence formula is an element of the form $\pvec{u} \sim \pvec{v}$, where $\pvec{u}$ and $\pvec{v}$ are two vectors of terms of the meta-logic of the same length.
\end{definition}

\begin{definition}
  Two protocoles $\calp_1 = (\calp_{1,\cala},\leq_1)$ and $\calp_2 = (\calp_{2,\cala}, \leq_2)$, defined over the same signature, are compatible if
  \begin{itemize}
  \item   the set of action names of $\calp_{1,\cala}$ is equal to the set of action names of  $\calp_{2,\cala}$;
    \item  for any action names $\sfa,\sfa'$ in  $\calp_{1,\cala}$, we have that $ \sfa \leq_1 \sfa' \Leftrightarrow \sfa \leq_2 \sfa'$.
  \end{itemize}

\end{definition}

From this Definition, the following Lemma instantly follows.
\begin{lemma}
  If $\calp_1$ and $\calp_2$ are compatible then they have the same trace models.
\end{lemma}

\begin{definition}
  Let $\calp_1$ and $\calp_2$ be two compatible protocoles, and $\pvec{u} \sim \pvec{v}$ be a meta-formula equivalence formula. Then, for every $\calp_1$-trace model $\TM$, computational model $\Mo$ and interpretation~$\sigma$:
  \begin{align*}
    \TM, \Mo, \sigma \models_{\calp_1,\calp_2}
    \pvec{u} \sim \pvec{v}
    &&\text{ iff }&&
    \Mo, \sigma \models
    \interp{\pvec{u}}{\TM}{\calp_1} \sim \interp{\pvec{v}}{\TM}{\calp_2}
  \end{align*}
  Moreover, we say that $\pvec{u} \sim \pvec{v}$ is $(\calp_1,\calp_2)$-valid if $\TM, \Mo, \sigma \models_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}$ for every $\TM$, $\Mo$, $\sigma$.

  Finally, for any set of meta-formulas $S$, $S \models \pvec{u} \sim \pvec{v}$ if for every $\TM$, $\Mo$, $\sigma$ such that $\TM, \Mo, \sigma \models_{\calp_1,\calp_2} S$, we have $\TM, \Mo, \sigma \models_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}$.
\end{definition}


Remark that in the Tool, rather than asking the user to input a pair of protocol, he must specify a bi-protocol. From a bi-protocol, it is straightforward to obtain the corresponding pair of protocol through projection, and a bi-protocol is by essence a pair of two compatible protocols.


Now that we can interpret equivalence for pairs of protocol, we can now define the notion of diff-equivalence, such that no attacker can distinguish between the two protocols.

\begin{definition}
  \label{def:process-equiv}
  A pair of compatible protocols $\calp_1,\calp_2$ is diff-equivalent when,
  for any $\calp$-trace model $\TM$, the formula $\mframe@\tau  \sim \mframe@\tau$ is $(\calp_1,\calp_2)$-valid.
\end{definition}

As the $\tau$ is not quantified, the previous formula is equivalent to  \[
    \dand_{v\in D_\XT}
    \interp{\mframe@\tau}{\TM[\tau\mapsto v]}{\calp_1}
    \sim
    \interp{\mframe@\tau}{\TM[\tau \mapsto v]}{\calp_2}
  \]
  for any trace model. This means that for any possible trace, and any possible timestamp in this trace, the sequence of outputs of the messages and the executability of the trace up to this point must be indistinguishable. Our indistinguishability, as it is interpreted in the CCSA model, is computationally sounds. It thus corresponds to the classical notion of computational indistinguishability.

Note that this equivalence cannot hold if there exists a trace whose probability
of execution significantly differs between the two projections of the
bi-protocol. Hence this imposes a form of synchronization on the execution of
conditionals on the two sides of bi-protocoles. This stems from the fact that we
consider protocols as pair of visible actions, where the attacker can know
whether an action succeeded or failed.


% \newcommand{\In}{\mathsf{in}}
% \newcommand{\Out}{\mathsf{out}}

% \begin{example}
%   Consider the bi-protocol
%   $\In(c,x).\myif x=\diff{0}{1} \mythen \Out(c,n) \myelse \Out(c,m)$
%   where $n$ and $m$ are arbitrary, possibly equal names.
%   Its two projections are indistinguishable, but the
%   bi-protocol is not diff-equivalent.
%   \adrien{I do not agree. If you write the process using actions (as we do), then it is equivalent. When you are translating from the pi-process to an representation using actions, you cannot change the visible actions (or this is not a sound translation).}
%   Indeed we have
%   $\myif g()=0 \mythen \Out(c,n) \not\sim
%   \myif g()=1 \mythen \Out(c,m)$: the attacker can simply choose
%   $g()=0$ to distinguish the two sides.
%   Our bi-protocol can however easily be
%   rewritten into a diff-equivalent process, e.g. by pushing the conditional
%   inside the output.

%   If we modify our bi-protocol into
%   $\In(c,x).\myif x=\diff{0}{1} \mythen \Out(c,n) \myelse \Out(c,0)$
%   then the two projections become distinguishable.
%   The attack is obtained with an execution
%   where one process outputs a name while the other outputs $0$. Such
%   desynchronized executions are not taken into account with diff-equivalence,
%   but diff-equivalence still fails due to the desynchronized condition,
%   as before.
% \end{example}

% In the next examples, we omit the $\myelse$ branch when it consists of a null
% process. In these examples, there is a coincidence between diff-equivalence
% and indistinguishability, because observable actions coincide with symbolic
% actions.

% \begin{example} \label{ex:negl}
%   Consider the bi-protocol
%   $\In(c,x).\myif x=\diff{n}{m} \mythen \Out(c,\ok)$.
%   It is diff-equivalent, and its projections are
%   indistinguishable as expected.
%   In the bi-protocol, the condition $x=\diff{n}{m}$ does not pass
%   with the same inputs on the left and right, but it passes with
%   the same negligible probability.
% \end{example}

% \begin{example} \label{ex:sync}
%   Consider
%   $\In(c,x).\myif x=(\diff{n}{m})_0 \mythen \Out(c,n)$
%   where $(t)_0$ denotes the first bit of $t$.
%   This bi-protocol is not diff-equivalent because
%   $\myif x=(n)_0 \mythen n \not\sim \myif x=(m)_0 \mythen n$, and
%   the two projections are distinguishable for the same
%   reason: the attacker sends $0$;
%   on the left he receives with probability $1\over 2$ a bitstring whose
%   first bit is $0$;
%   on the right process he receives with probably only $1\over 4$
%   a bitstring whose last bit is $0$.
%   If we change $\Out(c,n)$ into $\Out(c,\ok)$,
%   we have indistinguishable processes and diff-equivalence holds.
% \end{example}

% \begin{example} \label{ex:problem}
%   Consider $\Out(c,\diff{n}{m}).
%   \In(c,x).
%   \myif x=\diff{n}{m} \mythen \Out(c,\ok)$.
%   The projections are observationally equivalent and diff-equivalence
%   holds -- in fact they are $\alpha$-equivalent.
% \end{example}


\subsection{Reasoning about equivalences}

We extend our sequent calculus with rules to prove the equivalence formulas of the meta-logic.

\begin{definition}
  Let $\calp_1,\calp_2$ be compatible protocols. An equivalence sequent $\Gamma \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}$ comprises a set of hypotheses $\Gamma$ and a goal $\pvec{u} \sim \pvec{v}$, where $\Gamma$ and $\pvec{u} \sim \pvec{v}$ are all equivalence formulas of the meta-logic.

  The sequent  $\Gamma \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}$ is valid whenever $(\Gamma \Rightarrow \pvec{u} \sim \pvec{v})$ is $(\calp_1,\calp_2)$-valid.
\end{definition}

\begin{lemma}
  A pair of compatible protocols $\calp_1,\calp_2$ is diff-equivalent if and only if
  \[
    \mframe@\pre(\tau) \sim \mframe@\pre(\tau)
    \vdash_{\calp_1,\calp_2}
    \mframe@\tau \sim \mframe@\tau
  \]
\end{lemma}
\begin{proof}
  This is by induction on the length of the traces.
\end{proof}

% \begin{lemma}
%   A bi-protocol is diff-equivalent if and only if,
%   \[ \emptyset \vdash  \mframe^L@\tau \sim \mframe^R@\tau\]
%   Equivalently, is it diff-equivalent if and only if:
%   \[\mframe^L@\pre(\tau) \sim \mframe^R@\pre(\tau) \vdash \mframe^L@\tau \sim \mframe^R@\tau\]
% \end{lemma}
% \begin{proof}
%   We prove the first equivalence, which is essentially an unfolding of definitions.
%   \[
%     \begin{array}{l@{~}l}
%       $P$\text{ is diff-equivalent} & \Leftrightarrow \text{for all } \TM,\ \stackrel{.}{\wedge}_{v\in D_\XT} (\mframe@\tau^L)^{\TM[\tau\mapsto v]} \sim (\mframe@\tau^R)^{\TM[\tau \mapsto v]}\text{ is valid}\\
%       & \Leftrightarrow \text{for all } \TM\text{ and } v\in D_\XT,\ (\mframe@\tau^L)^{\TM[\tau\mapsto v]} \sim (\mframe@\tau^R)^{\TM[\tau \mapsto v]}\text{ is valid}\\
%       & \Leftrightarrow \text{for all } \TM\text{ and } v\in D_\XT,\ \true \stackrel{.}{\Rightarrow} (\mframe@\tau^L)^{\TM[\tau\mapsto v]} \sim (\mframe@\tau^R)^{\TM[\tau \mapsto v]}\text{ is valid}\\
%       & \Leftrightarrow  \emptyset \vdash  \mframe^L@\tau \sim \mframe@\tau^R\text{ is valid}\\

%     \end{array}
%   \]

%   The second equivalence is a direct induction on the length of the traces.
% \end{proof}

We provide in \cref{fig:lk-ind} a set of rules for equivalence sequent. These rules are independent of the protocoles $\calp_1,\calp_2$. Note that:
\begin{itemize}
\item the rule $\textsc{Sym}$ swaps the two protocols.
\item the $\textsc{Refl}$ rule checks that the term $t$ is macro-free, which ensures that $\interp{\pvec{t}}{\TM}{\calp_1}$ and $\interp{\pvec{t}}{\TM}{\calp_2}$ are \emph{syntactically} the same (base logic) terms in any $\calp_1$-trace model $\TM$.
\item the rule $\textsc{Trans}$ introduces an intermediate protocol $\calp_3$ which must be compatible with $\calp_1$ and $\calp_2$.
\end{itemize}


\begin{figure}
  \begin{mathpar}
    \inferrule[Expand]{
      \Gamma \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}
    }{\Gamma \cup \phi \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}}

    \inferrule[F-Cut]{
      \Gamma \vdash_{\calp_1,\calp_2} \phi\\
      \Gamma \cup \phi \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}
    }{
      \Gamma \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}
    }

    \inferrule[Sym]{
      \Gamma \vdash_{\calp_2,\calp_1} \pvec{u} \sim \pvec{v}
    }{\Gamma \vdash_{\calp_1,\calp_2} \pvec{v} \sim \pvec{u}}

    \inferrule[Refl]{~}
    { \Gamma \vdash_{\calp_1,\calp_2} \pvec{t} \sim \pvec{t} }
    \quad\text{$\pvec{t}$ is macro-free}

    \inferrule[Trans]{
      \Gamma \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{t}\\
      \Gamma \vdash_{\calp_1,\calp_3} \pvec{t} \sim \pvec{v}
    }{\Gamma \vdash_{\calp_1,\calp_3} \pvec{u} \sim \pvec{v}}
    \quad\text{$\calp_1,\calp_2,\calp_3$ are compatible}

    \inferrule[Subst]{
      \Gamma \cup \{t_1 \deq t_2\sim \true \}  \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}
    }{
      \Gamma \cup \{t_1 \deq t_2\sim \true \} \vdash_{\calp_1,\calp_2}
      \pvec{u}[ t_1 / t_2] \sim  \pvec{v}[ t_1 / t_2]
    }

    \inferrule[if-reach]{
      \phi \vdash_{\calp_1,\calp_2} \false
    }{
      \Gamma  \vdash_{\calp_1,\calp_2} \myif \phi \mythen {u} \sim  \myif \phi \mythen {v}
    }

    \inferrule[if-equiv]{
      \phi \vdash_{\calp_1,\calp_2} \psi \Leftrightarrow \psi'
    }{
      \Gamma \vdash_{\calp_1,\calp_2}
      \myif  \phi \wedge \psi \mythen t \sim \myif \phi \wedge \psi' \mythen t
    }

    \inferrule[${\lnot}$-R]{
      \Gamma \vdash_{\calp_1,\calp_2} \false \sim \true
    }{
      \Gamma \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}
    }

    \inferrule[fresh]{
      n,m \not \in \Gamma
    }{
      \Gamma \vdash_{\calp_1,\calp_2} n \sim m
    }

    \inferrule[if-weak]{
      \Gamma \vdash_{\calp_1,\calp_2} \phi, \pvec{u} \sim \phi, \pvec{v}
    }{
      \Gamma \vdash_{\calp_1,\calp_2} \myif  \phi \mythen \pvec{u} \sim \myif \phi \mythen \pvec{v}
    }

    \inferrule[Dup]{
      \Gamma \vdash_{\calp_1,\calp_2} \pvec{u},s \sim \pvec{v},t
    }{
      \Gamma \vdash_{\calp_1,\calp_2} \pvec{u},s,s \sim \pvec{v},t,t
    }
  \end{mathpar}
  \caption{Generic inference rules for indistinguishability.}
  \label{fig:lk-ind}
\end{figure}

\begin{lemma}
  The rules presented in Figure~\ref{fig:lk-ind} are sound.
\end{lemma}

Remark that $\textsc{Subst}$,  $\textsc{if-weak}$ and $\textsc{if-equiv}$ are rules that leverages the reachability prover to obtain proofs of indistinguishability. This is a powerful tool: in an authentication protocol, one may prove in the reachability prover that the condition of an action is equivalent to a formula that expresses the well-authentication of the protocol, and once the condition is replaced inside the indistinguishability goal, the goal may become easy to prove.

\paragraph{Other rules.}

\cref{fig:rules-corresp-equiv} presents the rules for Fresh, PRF and XOR tactics.
We use the following notations:
\begin{itemize}
\item $A \in S$ stands for every action in the system (or protocol)
\item $A(\pvec i)^L$ represents the left projection of meta-logic bi-terms and bi-formulas describing the action $A(\pvec k)$ (outputs, updates and conditions)
\item $k(\_) \sqsubseteq_{\h(\_,\cdot)} u$ means that the indexed key $k$ appears only in key positions in $u$
\item indices $\pvec i$ in $A(\pvec i)$ are chosen fresh with relation to the appropriate environment (i.e. indices appearing in $u, C, t, k, \pvec {j_0}$)
\end{itemize}

\begin{figure}[h]
  \textbf{Fresh rule:}
  {\small\[\arraycolsep=10pt
      \begin{array}{|c|c|}
        \hline
        \text{Base logic Rule} &
        \text{Meta-logic Rule}\\
        \hline
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Fresh
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        \inferrule{
          \Gamma \vdash \pvec{u}, C[0] \sim \pvec{v}, C[0]
        }{
          \Gamma \vdash \pvec{u}, C[\mathsf{n}] \sim \pvec{v}, C[\mathsf{n}']
        }
        &
        \inferrule{
          \Gamma \vdash_{\calp_1,\calp_2}
          {\begin{alignedat}[t]{2}
              &
              \pvec{u},
              C\big[
              \myif \phifresh{\calp_1}{\mathsf{n}[\pvec{i}]}{\pvec{u},C}
              \mythen 0 \myelse \mathsf{n}[\pvec{i}]
              \big]\\
              \sim\;\;&
              \pvec{v},
              C\big[
              \myif \phifresh{\calp_2}{\mathsf{n}'[\pvec{i}']}{\pvec{v},C}
              \mythen 0 \myelse \mathsf{n}'[\pvec{i}']
              \big]
            \end{alignedat}}
        }{
          \Gamma \vdash_{\calp_1,\calp_2}
          \pvec{u}, C[\mathsf{n}[\pvec{i}]] \sim \pvec{v}, C[\mathsf{n}'[\pvec{i}']]
        }\\[2em]
        \text{where }
        \mathsf{n} \not \in \st(\pvec{u},C)
        \text{ and }
        \mathsf{n}' \not \in \st(\pvec{v},C)
        &
        \text{where }
        \begin{alignedat}[t]{2}
          &\phifresh{\calp}{\mathsf{n}[\pvec{i}]}{\pvec{u}}
          &\;\;\overset{def}{=}\;\;&
          \quad
          \bigwedge_{\mathclap{(\mathsf{n}[\pvec{j}],\pvec{j},c) \in \ost_{\calp}(\pvec{u})}}
          \quad
          \forall \pvec{j}, c \rightarrow \pvec{i} \ne \pvec{j}
        \end{alignedat}
        \\\hline
      \end{array}
    \]}

  \textbf{PRF Rule:}
  {\small\[\arraycolsep=10pt
      \begin{array}{|c|c|}
        \hline
        \text{Base logic Rule} &
        \text{Meta-logic Rule}\\
        \hline
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % PRF
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        \inferrule{
          \Gamma \vdash
          \pvec{u},
          C\Big[\;
          {\begin{alignedat}[c]{1}
              \myif \phihfresh{}{\mathsf{k}}{t}{\pvec{u},C,t}
              &\mythen \mathsf{n}\\[-0.5em] &\myelse h(t,\mathsf{k})
            \end{alignedat}}
          \;\Big]
          \sim
          \pvec{v}, s
        }{
          \Gamma \vdash
          \pvec{u}, C[h(t,\mathsf{k})] \sim \pvec{v}, s
        }
        &
        \inferrule{
          \Gamma \vdash_{\calp_1,\calp_2}
          \pvec{u},
          C\Big[\;
          {\begin{alignedat}[c]{1}
              \myif \phihfresh{\calp_1}{\mathsf{k}[\pvec{i}]}{t}{\pvec{u},C,t}
              &\mythen \mathsf{n}\\[-0.5em] &\myelse h(t,\mathsf{k}[\pvec{i}])
            \end{alignedat}}
          \;\Big]
          \sim
          \pvec{v}, s
        }{
          \Gamma \vdash_{\calp_1,\calp_2}
          \pvec{u}, C[h(t,\mathsf{k}[\pvec{i}])] \sim \pvec{v}, s
        }
        \\[2em]
        \text{when }
        \mathsf{n} \text{ fresh},
        \mathsf{k} \tpos_{h(\_,\cdot)} \st(\pvec{u},C,t)
        &
        \text{when }
        \mathsf{n} \text{ fresh},
        \mathsf{k} \tpos^{\calp_1}_{h(\_,\cdot)} \st(\pvec{u},C,t)
        \\[1em]
        \text{and }
        \begin{alignedat}[t]{2}
          &\phihfresh{}{\mathsf{k}}{t}{\pvec{u}}
          &\;\;\overset{def}{=}\;\;&
          \quad
          \bigwedge_{\mathclap{h(m,\mathsf{k}) \in \st(\pvec{u})}}
          \quad
          m \ne t
        \end{alignedat}
        &
        \text{and }
        \begin{alignedat}[t]{2}
          &\phihfresh{\calp}{\mathsf{k}[\pvec{i}]}{t}{\pvec{u}}
          &\;\;\overset{def}{=}\;\;&
          \quad
          \bigwedge_{\mathclap{(h(m,\mathsf{k}[\pvec{i_0}]),\pvec{j},c) \in \ost_{\calp}(\pvec{u})}}
          \quad
          \forall \pvec{j},
          (c \wedge \pvec{i} = \pvec{i_0})
          \rightarrow m \ne t
        \end{alignedat}
        \\\hline
      \end{array}
    \]}

  \textbf{XOR Rule:}
  {\small
    \[\arraycolsep=10pt
      \begin{array}{|c|c|}
        \hline
        \text{Base logic Rule} &
        \text{Meta-logic Rule}\\
        \hline
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % XOR
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        \inferrule{
          \Gamma \vdash \mylen(t) = \mylen(\mathsf{n})\\\\
          \Gamma \vdash
          \pvec{u}, C[\mathsf{m}] \sim \pvec{v}, s
        }{
          \Gamma \vdash
          \pvec{u}, C[t \oplus \mathsf{n}[\pvec{j}]] \sim \pvec{v}, s
        }
        &
        \inferrule{
          \lreach{\Gamma} \vdash_{\calp_1}
          \mylen(t) = \mylen(\mathsf{n}[\pvec{j}])\\\\
          \Gamma \vdash_{\calp_1,\calp_2}
          \pvec{u},
          C\Big[\;
          {\begin{alignedat}[c]{1}
              \myif \phifresh{\calp_1}{\mathsf{n}[\pvec{j}]}{\pvec{u},C,t}
              &\mythen \mathsf{m}\\[-0.5em] &\myelse t \oplus \mathsf{n}[\pvec{j}]
            \end{alignedat}}
          \;\Big]
          \sim
          \pvec{v}, s
        }{
          \Gamma \vdash_{\calp_1,\calp_2}
          \pvec{u}, C[t \oplus \mathsf{n}[\pvec{j}]] \sim \pvec{v}, s
        }
        \\[2em]
        \text{when }
        \mathsf{m} \text{ fresh and }
        \mathsf{n} \not \in \st(\pvec{u},C,t)
        &
        \text{when }
        \mathsf{m} \text{ fresh and }
        \begin{alignedat}[t]{2}
          &\phifresh{\calp}{\mathsf{n}[\pvec{i}]}{\pvec{u}}
          &\;\;\overset{def}{=}\;\;&
          \quad
          \bigwedge_{\mathclap{(\mathsf{n}[\pvec{j}],\pvec{j},c) \in \ost_{\calp}(\pvec{u})}}
          \quad
          \forall \pvec{j}, c \rightarrow \pvec{i} \ne \pvec{j}
        \end{alignedat}
        \\\hline
      \end{array}
    \]}

  \adrien{I use the function $\lreach{\Gamma}$ in the XOR rule, which extracts from $\Gamma$ the \emph{left} reachability statements. If we keep it, I will add the definition.}

  \caption{Rules of the base logic, and corresponding meta-logic rules.}
  \label{fig:rules-corresp-equiv}
\end{figure}


\begin{figure}[h]
  \begin{mathpar}
    \inferrule[FA-DUP]{
      \inferrule{
        \Gamma \vdash_{\calp_1,\calp_2} u,
        \mframe @ \pre(A(\pvec i)),
        \mexec @ \pre(A(\pvec i))
      }{
        \Gamma \vdash_{\calp_1,\calp_2} u,
        \mframe @ \pre(A(\pvec i)),
        \myif \mexec @ \pre(A(\pvec i)) \mythen \phi_{h} \myelse \bot
      }
    }{
      \Gamma \vdash_{\calp_1,\calp_2} u,
      \mframe @ \pre(A(\pvec i)),
      \mexec @ \pre(A(\pvec i)) \wedge \phi_{h}
    }
  \end{mathpar}

  We ask that $\phi_h \in H_{\{\pre(A(\pvec i))\}}$ where, for any set of
  timestamps $T$, $H_T$ is the least set of formulas and messages
  closed under function application, boolean connectives, and the
  following rules:
  $$ \inferrule{
    B(\pvec j) \in T
    \quad
    \phi \in H_{T\cup\{C(\pvec {k})\}}
  }{
    (\forall \pvec k.~ C(\pvec k)\leq B(\pvec j) \Rightarrow \phi) \in H_T
  }
  \quad\quad
  \inferrule{
    B(\pvec j) \in T
    \quad
    \phi \in H_{T\cup\{C(\pvec k)\}}
  }{
    (\exists \pvec k.~ C(\pvec k)\leq B(\pvec j) \wedge \phi) \in H_T
  }
  $$
  $$\inferrule{B(\pvec j) \in T}{
    \minp @ B(\pvec j) \in H_T
  }\quad\quad
  \inferrule{ }{
    \minp @ A(\pvec i) \in H_T
  }\quad\quad
  \inferrule{B(\pvec j) \in T}{
    \mout @ B(\pvec j) \in H_T
  }$$
  $$
  \inferrule{\phi \in H_T \quad B(\pvec j) \in T}{
    (\myif \mexec @ B(\pvec j) \mythen \phi \myelse \psi) \in H_T}
  $$
  \caption{FA-DUP rule.
  }
  \label{fig:fadup}
\end{figure}

\clearpage
\section{Archives}
\subsection{A proof technique}

Diff-equivalence is usually proved by induction and case analysis on
the timestamp. Even cases where the left and right actions are locally
identical are not trivial: it may be e.g.\ that the same name is outputted
by the action on both sides, but that each side has previously released
different information on that name.

To prove diff-equivalence, it can be interesting to prove that:
\[
  \phi^L_\tr, \phi^R_\tr
  \vdash_{\calp_1,\calp_2}
  \phi^L_\alpha \Leftrightarrow \phi^R_\alpha
\]

Then, in the induction step, we can directly replace the previous conditions by the same one.


This condition is only used to help for proving diff-equivalence, it is not necessary.
The gap comes from the fact that we are requiring conditions to be
synchronized for all random samplings.

\begin{example}
  With the bi-protocol of \cref{ex:negl} we would have to prove
  $\vdash_{\calp_1,\calp_2} g() = n \Leftrightarrow g() = m$ and
  $g()=n, g()=m \vdash_{\calp_1,\calp_2} \ok \sim \ok$, both of which hold.
  With the bi-protocol of \cref{ex:sync} we would have to prove
  $\vdash_{\calp_1,\calp_2} g() = (n)_0 \Leftrightarrow g() = (m)_0$ which does not hold.
\end{example}

\begin{example} \label{ex:indep}
  This proof technique does not work for \cref{ex:problem}.
  The same problem appears with the Basic-Hash protocol, even if we work around
  the problem described in \cref{sec:refined-diff}, we won't be able to show
  that conditionals are synchronized.  In the simple case of the trace
  $T(i,j).R(k,i,j)$ we have
  on the single-session side
  $$\pi_2(g_2(\pair{n_T(i,j),h(n_T(i,j),k'(i,j))})) =
  h(\pi_1(g_2(\ldots)),k'(i,j))$$
  and we would like this to imply (in the meta-logic)
  the same equality with $k(i)$ instead of $k'(i,j)$.
  This implication does not hold with overwhelming probability in all
  computational models: as in \cref{ex:problem}, $g_2(x)$ could be the second
  projection of $x$ with its first bit changed to $0$; if the hash is PRF,
  there should be a probability of roughly $1 \over 4$ that this leaves
  the hash unchanged with $k'(i,j)$ but not with $k(i)$.
\end{example}

\section{Outdated example : a signed DDH key exchange}
\charlie{abus de notations dans cette partie}

We briefly show how one can prove the security of a signed DDH key exchange. The protocol in pi-calculus is provided in Figure~\ref{fig:signed_ddh} and the run of an honest execution in Figure~\ref{fig:dh_ke}. This example is a simplified instance of classical key-exchange security. Notably, we assume that identities are already fixed.

\begin{figure}
  % \setlength{\belowcaptionskip}{-15pt}
  \setmsckeyword{} \drawframe{no}
  \setmscscale{0.9}
  \begin{center}
    \begin{msc}{}
      \setlength{\instwidth}{0\mscunit}
      \setlength{\instdist}{7cm}
      \setlength{\topheaddist}{0cm}
      \declinst{initiator}{
        \begin{tabular}[c]{c}
          \textsc{A} \\
          \colorbox{gray}{{\;\; $sk_A,a_i$\;\;}}
        \end{tabular}}{}

      \declinst{receiver}{
        \begin{tabular}[c]{c}
          \textsc{B} \\
          \colorbox{gray}{{\;\;  $sk_B,b_i$ \;\;}}
        \end{tabular}}{}

      \nextlevel[-1]
      \mess{$\mysign(g^{a_i},sk_A)$}{initiator}{receiver}
      \nextlevel[1.5]
      \mess{$\mysign(<g^{a_i},g^{b_i}>,sk_B)$}{receiver}{initiator}
      \nextlevel[1.5]
      \mess{$\mysign(<g^{a_i},g^{b_i}>,sk_A)$}{initiator}{receiver}




    \end{msc}
  \end{center}
  \caption{Diffie Hellman key exchange}\label{fig:dh_ke}
\end{figure}

\begin{figure}
  \[
    \begin{array}{cc}
      \begin{array}[t]{l@{~}l}
        A_i := & \aout{\mysign(g^{a_i},sk_A)} : \alpha_1; \\
        &\ain{x}; \\
        & \myif \mycsign(x,pk(sk_B)) \\
        & ~ \wedge \pi_1(\mygetmess(x))=g^{a_i}  \mythen \\
        & \quad \aout{\mysign(\mygetmess(x),sk_A) } : \alpha_2; \\
        & \quad \myfind j \mysuchthat g^{b_j} = \pi_2(\mygetmess(x)) \\
        & \qquad \aout{\diff{\pi_2(\mygetmess(x))^{a_i}}{k_{i,j}}} : \alpha_3\\
        & \quad \myelse \\
        & \qquad \aout{\diff{\pi_2(\mygetmess(x))^{a_i}}{\bot}}  : \alpha_4 \\
        & \myelse \\
        & \bot
      \end{array}
      &
      \begin{array}[t]{l@{~}l}
        B_i := &\ain{x}; \\
        & \myif \mycsign(x,pk(sk_A)) \mythen \\
        & \quad \aout{\mysign(<\mygetmess(x), g^{b_i}>,sk_B)} : \beta_1; \\
        & \quad \ain{y}; \\
        & \quad \myif \mycsign(y,pk(sk_A))\\
        & \quad ~ \wedge \mygetmess(y) = <\mygetmess(x), g^{b_i}> \mythen \\
        & \quad \quad \myfind j \mysuchthat g^{a_j} = \mygetmess(x) \\
        & \quad \qquad \aout{\diff{\mygetmess(x)^{b_i}}{k_{j,i}}} : \beta_2 \\
        & \quad \quad \myelse \\
        & \quad \qquad \aout{\diff{\mygetmess(x)^{b_i}}{\bot}} : \beta_3 \\
        & \quad \myelse \\
        & \quad \bot \\
        & \myelse \\
        & \bot
      \end{array}
    \end{array}
  \]
  \label{fig:signed_ddh}
  \caption{A signed DDH key exchange}
\end{figure}

We outline the proof of the fact that $!_i A_i \| B_i$ is diff-equivalent. There are four actions with choices in the output, thus, we have to show that, for all trace $\tr$, for all $i,j$:
\begin{enumerate}
\item $\begin{array}[t]{l}
    \phi_\tr,  \mycsign(x,pk(sk_B)), \mygetmess(x)=<g^{a_i}, g^{b_j}>, \mouts_\tr^L \sim \mouts_\tr^R,  \\
    \quad \vDash \mouts_\tr^L, \pi_2(\mygetmess(x))^{a_i} \sim \mouts_\tr^R, k_{i,j}
  \end{array}
  $ ($\alpha_3$)

\item $\begin{array}[t]{l}
    \phi_\tr,  \mycsign(x,pk(sk_B)),  \not \exists j. \pi_2(mygetmess(x))= g^{b_j},  \mouts_\tr^R \sim \mouts_\tr^L \\
    \quad \vDash \mouts_\tr^L, \pi_2(\mygetmess(x))^{a_i} \sim \mouts_\tr^R, \bot
  \end{array} $ ($\alpha_4$)
\item $\begin{array}[t]{l}
    \phi_\tr,  \mycsign(y,pk(sk_A)), \mycsign(x,pk(sk_A)), \mygetmess(y)=<g^{a_j}, g^{b_i}>,  \mouts_\tr^R \sim \mouts_\tr^L \\ \quad \vDash \mouts_\tr^L, \pi_2(\mygetmess(x))^{b_i} \sim \mouts_\tr^R, k_{j,i}
  \end{array}$ ($\beta_2$)
\item $\begin{array}[t]{l}
    \phi_\tr,  \mycsign(y,pk(sk_A)), \mycsign(x,pk(sk_A)),  \not \exists j. \pi_2(mygetmess(x))= g^{b_j},  \mouts_\tr^R \sim \mouts_\tr^L\\
    \vDash \mouts_\tr^L, \pi_2(\mygetmess(x))^{b_i} \sim \mouts_\tr^R, \bot
  \end{array}$ ($\beta_3$)
\end{enumerate}

Regarding goal $(2)$ and $(4)$, we remark that it is a case where $\Gamma \vdash \false$. Indeed, for $(2)$ applying EUFCMA yields that there exists $j$ such that $x = \mysign(<g^{a_i},g^{b_j}>,sk_B)$ which is in contradiction with  $\not \exists j. \pi_2(mygetmess(x))= g^{b_j}$.

Regarding goals $(1)$ and $(3)$, we mainly use DDH. To this end, we first use EUFMCA, to ensure that we have a matching conversation between the two sessions, and then use DDH. \charlie{je détail pas, ça prend du temps de formaliser proprement DDH vis à vis des actions, et je pense pas que ce soit l'objectif actuel}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
