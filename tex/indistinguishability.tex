\section{Indistinguishability}

\newcommand{\pair}[1]{\langle #1 \rangle}

% We now define indistinguishability of processes, and how we could verify it.
% We make a distinction between symbolic and observable traces:
% symbolic ones are sequences of action names as in \cref{def:trace},
% while observable traces are sequences of pairs $\pair{c_i,c_o}$.
% Intuitively, such a pair describes the input and output channels of an
% action; several actions might have the same input and output channels.
% We write $A : \pair{c_i,c_o}$ when action $A$ inputs on channel $c_i$ and
% outputs on channel $c_o$.

% For convenience, we talk of processes, though in reality the definitions
% deal with abstract systems described by sets of actions.

\newcommand{\fold}{\mathsf{fold}}

% \begin{definition}
%   Given an observable trace $t$ and a process $P$,
%   we define $\fold(P,t)$ as the frame describing all possible
%   executions of $P$ along $t$:
%   \begin{eqnarray*}
%     \fold(P,\epsilon) &=& \epsilon \\
%     \fold(P,(c_i,c_o).t') &=&
%     \mathsf{if}_{A:(c_i,c_o)}
%     \ldots
%   \end{eqnarray*}
% \end{definition}

% \begin{definition}
%   Two processes $P$ and $Q$ are indistinguishable when,
%   for all observable traces $t$,
%   for all computational model $\Mo$,
%   we have
%   $\Mo \models \fold(P,t) \sim \fold(Q,t)$.
%   This itself means that no attacker can distinguish,
%   with non-negligible probability, between the left- and right-hand sides.
% \end{definition}

% This notion of equivalence should coincide with the usual computational
% indistinguishability for bounded processes. In the unbounded case, it
% is restrictive to quantify on traces in this way
% and ask for indistinguishability only for each trace.

\subsection{Straightforward diff-equivalence}

We define the diff-equivalence of a process, by asking the equivalence of the projected frames for all possible traces.

\begin{definition}
  \label{def:process-equiv}
  A bi-process $P$ is diff-equivalent when,
  for any trace model $\TM$, the formula

  \[\stackrel{.}{\wedge}_{v\in D_\XT} (\mframe@\tau^L)^{\TM[\tau\mapsto v]} \sim (\mframe@\tau^R)^{\TM[\tau \mapsto v]}\]
  is valid.
  \adrien{Why not just take the last action?}
\end{definition}
\charlie{Notice that we could also extend $\phi^\TM$ to formulas containing the $\sim$ symbol, and consider the formula $\forall \tau. \mframe@\tau^L \sim \mframe@\tau^R$.}
Note that this equivalence cannot hold if there exists a trace
whose probability of execution significantly differs between the two
projections of the bi-process.
Hence this imposes a form of synchronization on the execution of
conditionals on the two sides of bi-processes.
The interest of imposing this artificial constraint is that we
can stop considering executions where one process goes to $\mythen$
branch while the other goes to its $\myelse$ branch. \adrien{The constraint is not artificial. Indeed, since the actions are visible, the adversary sees whether the process is going right or left. There is no loss of generality there.}
\begin{lemma}
  A bi-process $P$ is diff-equivalent if,
  for any trace model $\TM$, the formula

  \[\stackrel{.}{\wedge}_{v\in D_\XT} (\pair{\mframe@\tau^L,\mexec@\tau^L})^{\TM[\tau\mapsto v]} \sim (\pair{\mframe@\tau^R, \mexec@\tau^R} )^{\TM[\tau \mapsto v]}\]
  is valid.
  \adrien{This just complicated to show than what Definition~\ref{def:process-equiv} requires. Maybe there is a typo?}
\end{lemma}

\newcommand{\In}{\mathsf{in}}
\newcommand{\Out}{\mathsf{out}}

\begin{example}
  Consider the bi-process
  $\In(c,x).\myif x=\diff{0}{1} \mythen \Out(c,n) \myelse \Out(c,m)$
  where $n$ and $m$ are arbitrary, possibly equal names.
  Its two projections are indistinguishable, but the
  bi-process is not diff-equivalent.
  \adrien{I do not agree. If you write the process using actions (as we do), then it is equivalent. When you are translating from the pi-process to an representation using actions, you cannot change the visible actions (or this is not a sound translation).}
  Indeed we have
  $\myif g()=0 \mythen \Out(c,n) \not\sim
  \myif g()=1 \mythen \Out(c,m)$: the attacker can simply choose
  $g()=0$ to distinguish the two sides.
  Our bi-process can however easily be
  rewritten into a diff-equivalent process, e.g. by pushing the conditional
  inside the output.

  If we modify our bi-process into
  $\In(c,x).\myif x=\diff{0}{1} \mythen \Out(c,n) \myelse \Out(c,0)$
  then the two projections become distinguishable.
  The attack is obtained with an execution
  where one process outputs a name while the other outputs $0$. Such
  desynchronized executions are not taken into account with diff-equivalence,
  but diff-equivalence still fails due to the desynchronized condition,
  as before.
\end{example}

In the next examples, we omit the $\myelse$ branch when it consists of a null
process. In these examples, there is a coincidence between diff-equivalence
and indistinguishability, because observable actions coincide with symbolic
actions.

\begin{example} \label{ex:negl}
  Consider the bi-process
  $\In(c,x).\myif x=\diff{n}{m} \mythen \Out(c,\ok)$.
  It is diff-equivalent, and its projections are
  indistinguishable as expected.
  In the bi-process, the condition $x=\diff{n}{m}$ does not pass
  with the same inputs on the left and right, but it passes with
  the same negligible probability.
\end{example}

\begin{example} \label{ex:sync}
  Consider
  $\In(c,x).\myif x=(\diff{n}{m})_0 \mythen \Out(c,n)$
  where $(t)_0$ denotes the first bit of $t$.
  This bi-process is not diff-equivalent because
  $\myif x=(n)_0 \mythen n \not\sim \myif x=(m)_0 \mythen n$, and
  the two projections are distinguishable for the same
  reason: the attacker sends $0$;
  on the left he receives with probability $1\over 2$ a bitstring whose
  first bit is $0$;
  on the right process he receives with probably only $1\over 4$
  a bitstring whose last bit is $0$.
  If we change $\Out(c,n)$ into $\Out(c,\ok)$,
  we have indistinguishable processes and diff-equivalence holds.
\end{example}

\begin{example} \label{ex:problem}
  Consider $\Out(c,\diff{n}{m}).
  \In(c,x).
  \myif x=\diff{n}{m} \mythen \Out(c,\ok)$.
  The projections are observationally equivalent and diff-equivalence
  holds -- in fact they are $\alpha$-equivalent.
\end{example}


\subsection{Reasoning about equivalences}

We extend the sequent calculus, to also reason about diff-equivalence.

\begin{definition}
  A sequent $\Gamma \vdash t_L \sim t_R $ is composed of a set of indistinguishability $\Gamma$, and sequences of terms $t_L,t_R$.
  It is valid when, for any trace model $\TM$, for any evaluations $\sigma_\XT',\sigma_I'$ of the free variables in $t_L,t_R$ to well typed elements in $\TM$, the formula $ (\wedge \Gamma)^{\TM'} \Rightarrow (t_L)^{\TM'} \sim  (t_R)^{\TM'}$, where $\TM'=\TM \cup \sigma_\XT'\cup \sigma_I'$.
\end{definition}

This definition of sequent calculus can of course be used to reason about diff-equivalence.
\begin{lemma}
  A bi-process is diff-equivalent if and only if,
  \[ \emptyset \vdash  \mframe^L@\tau \sim \mframe^R@\tau\]
  Equivalently, is it diff-equivalent if and only if:
  \[\mframe^L@\pre(\tau) \sim \mframe^R@\pre(\tau) \vdash \mframe^L@\tau \sim \mframe^R@\tau\]
\end{lemma}
\begin{proof}We prove the first equivalence, which is essentially an unfolding of definitions.

  \[
    \begin{array}{l@{~}l}
      $P$\text{ is diff-equivalent} & \Leftrightarrow \text{for all } \TM,\ \stackrel{.}{\wedge}_{v\in D_\XT} (\mframe@\tau^L)^{\TM[\tau\mapsto v]} \sim (\mframe@\tau^R)^{\TM[\tau \mapsto v]}\text{ is valid}\\
      & \Leftrightarrow \text{for all } \TM\text{ and } v\in D_\XT,\ (\mframe@\tau^L)^{\TM[\tau\mapsto v]} \sim (\mframe@\tau^R)^{\TM[\tau \mapsto v]}\text{ is valid}\\
      & \Leftrightarrow \text{for all } \TM\text{ and } v\in D_\XT,\ \true \stackrel{.}{\Rightarrow} (\mframe@\tau^L)^{\TM[\tau\mapsto v]} \sim (\mframe@\tau^R)^{\TM[\tau \mapsto v]}\text{ is valid}\\
      & \Leftrightarrow  \emptyset \vdash  \mframe^L@\tau \sim \mframe@\tau^R\text{ is valid}\\

    \end{array}
  \]

  The second equivalence is a direct induction on the length of the traces.
\end{proof}

Adding the execution condition to the sequent is also a valid proof technique.
\begin{lemma}
  A bi-process is diff-equivalent if,
  \[ \emptyset \vdash  \pair{\mframe^L@\tau,\mexec@\tau^L} \sim \pair{\mframe@\tau^R,\mexec@\tau^R}\]
  \adrien{It is harder to prove the formula above than to prove $\emptyset \vdash  \mframe^L@\tau \sim \mframe^R@\tau$. Maybe there is a typo?}
\end{lemma}
We provide in \cref{fig:lk-ind} a set of sound rules for this second sequent calculus.

\begin{figure}
  \begin{mathpar}
    \inferrule[Expand]{\Gamma \vdash t_L \sim t_R
      \quad
    }{\Gamma \cup \phi \vdash t_L \sim t_R}
    \quad\quad
    \inferrule[Cut]{
      \Gamma \vdash t_L \sim t_R
      \quad
      \Gamma \vdash t_R \sim t_S
    }{\Gamma \vdash t_L \sim t_S}
  \end{mathpar}
  \begin{mathpar}
    \inferrule[Subst]{
      \Gamma \cup \{\EQ(t_1,t_2)\sim \true \}  \vdash t^L \sim t^R
    }{
      \Gamma \cup \{\EQ(t_1,t_2)\sim \true \} \vdash t^L[ t_1 / t_2] \sim  t^R[ t_1 / t_2]
    }

  \end{mathpar}

  \begin{mathpar}
    \inferrule[\myif-reach]{
      \phi \vdash \false
    }{
      \Gamma  \vdash \myif \phi \mythen t_L \sim  \myif \phi \mythen t_R
    }
    \quad\quad
    \inferrule[\myif-equiv]{
      \phi \vdash \psi \Leftrightarrow \psi'
    }{
      \Gamma \vdash \myif  \phi \wedge \psi \mythen t \sim \myif \phi \wedge \psi' \mythen t
    }
  \end{mathpar}
  \begin{mathpar}
    \inferrule[${\lnot}$-R]{
      \Gamma \vdash \false \sim \true
    }{
      \Gamma \vdash t^L \sim t^R
    }
    \quad\quad
    \inferrule[fresh]{
      n,m \not \in \Gamma
    }{
      \Gamma \vdash n \sim m
    }
    \quad\quad
    \inferrule[\myif-weak]{
      \Gamma \vdash \phi, t_L \sim \phi, t_R
    }{
      \Gamma \vdash \myif  \phi \mythen t_L \sim \myif \phi \mythen t_R
    }
  \end{mathpar}
  \begin{mathpar}
    \inferrule[F-Cut]{
      \Gamma \vdash \phi
      \quad
      \Gamma \cup \phi \vdash t^L \sim t^R
    }{
      \Gamma \vdash t^L \sim t^R
    }
    \quad\quad
    \inferrule[Dup]{
      \Gamma \vdash t^L,u \sim t^R,v
    }{
      \Gamma \vdash t^L,u,u \sim t^R,v,v
    }
  \end{mathpar}


  \caption{Generic inference rules for indistinguishability}
  \label{fig:lk-ind}
\end{figure}
\begin{lemma}
  The rules presented in Figure~\ref{fig:lk-ind} are sound.


\end{lemma}

\paragraph{Other rules.}

\Cref{fig:fresh,fig:prf,fig:xor} presents the rules for Fresh, PRF and XOR tactics.
We use the following notations:
\begin{itemize}
\item $\Gamma \vdash u$ stands for $\Gamma^L \sim \Gamma^R \vdash u^L \sim u^R$
\item $A \in S$ stands for every action in the system (or protocol)
\item $A(\vec i)^L$ represents the left projection of meta-logic bi-terms and bi-formulas describing the action $A(\vec k)$ (outputs, updates and conditions)
\item $k(\_) \sqsubseteq_{\h(\_,\cdot)} u$ means that the indexed key $k$ appears only in key positions in $u$
\item indices $\vec i$ in $A(\vec i)$ are chosen fresh with relation to the appropriate environment (i.e. indices appearing in $u, C, t, k, \vec {j_0}$)
\end{itemize}

\begin{figure}[h]
  \begin{mathpar}
    \inferrule[Fresh]{
      \Gamma \vdash u, C[\myif \phi_L \wedge \phi_R \mythen 0 \myelse n(\vec {j_0})]
    }{
      \Gamma \vdash u, C[n(\vec {j_0})]
    }
  \end{mathpar}
  \begin{mathpar}
    \phi_L = \big( \displaystyle\bigwedge_{n^L(\vec {j}) \in u^L,C^L} \vec {j} \neq {\vec {j_0}^L} \big)
    \wedge
    \big(
    \displaystyle\bigwedge_{A \in S}
    \forall \vec i \
    \big(\displaystyle\bigvee_{\tau \in u^L,C^L} A(\vec i) \leq \tau \big)
    \Rightarrow
    \big(\displaystyle\bigwedge_{n^L(\vec j) \in A(\vec i)^L} \vec j \neq {\vec {j_0}^L} \big)
    \big)
  \end{mathpar}
  \begin{mathpar}
    \phi_R = ... \ \text{(similar, replacing $L$ by $R$)}
  \end{mathpar}
  \caption{Fresh rule.\solene{Not yet implemented with the context $C$.}}
  \label{fig:fresh}
\end{figure}

\begin{figure}[h]
  \begin{mathpar}
    \inferrule[PRF]{
      \Gamma \vdash u, C[\myif \diff{\phi_L}{\phi_R} \mythen n \myelse \h(t,k(\vec {j_0}))]
      \quad \quad
      k(\_) \sqsubseteq_{\h(\_,\cdot)} u,C,A(\vec i)
    }{
      \Gamma \vdash u, C[\h(t,k(\vec {j_0}))]
    }
  \end{mathpar}
  \begin{mathpar}
    \phi_L = \big( \displaystyle\bigwedge_{\h(m,k(\vec j)) \in u^L,C^L,t^L} (\vec j = {\vec {j_0}}^L \Rightarrow t^L \neq m) \big)
    \wedge
    \big(
    \displaystyle\bigwedge_{A \in S}
    \forall \vec i \
    \big(\displaystyle\bigvee_{\tau \in u^L,C^L,t^L} A(\vec i) < \tau \big)
    \Rightarrow
    \big(\displaystyle\bigwedge_{\h(m,k(\vec j)) \in A(\vec i)^L} (\vec j = {\vec {j_0}}^L \Rightarrow t^L \neq m) \big)
    \big)
  \end{mathpar}
  \begin{mathpar}
    \phi_R = ... \ \text{(similar, replacing $L$ by $R$)}
  \end{mathpar}
  \caption{PRF rule.\solene{Not yet implemented with the context $C$.}}
  \label{fig:prf}
\end{figure}

\begin{figure}[h]
  \begin{mathpar}
    \inferrule[XOR-ind]{
      \Gamma \vdash u, C[\myif \phi_L \wedge \phi_R \mythen m \myelse t \oplus n(\vec {j_0})]
    }{
      \Gamma \vdash u, C[t \oplus n(\vec {j_0})]
    }
  \end{mathpar}
  \begin{mathpar}
    \phi_L = \big( \displaystyle\bigwedge_{n^L(\vec j) \in u^L,C^L,t^L} \vec j \neq {\vec {j_0}}^L \big)
    \wedge
    \big(
    \displaystyle\bigwedge_{A \in S}
    \forall \vec i \
    \big(\displaystyle\bigvee_{\tau \in u^L,C^L,t^L} A(\vec i) \leq \tau \big)
    \Rightarrow
    \big(\displaystyle\bigwedge_{n^L(\vec j) \in A(\vec i)^L} \vec j \neq {\vec {j_0}}^L \big)
    \big)
  \end{mathpar}
  \begin{mathpar}
    \phi_R = ... \ \text{(similar, replacing $L$ by $R$)}
  \end{mathpar}
  \caption{XOR-ind rule.\solene{Not yet implemented with the context $C$.}}
  \label{fig:xor}
\end{figure}

\begin{figure}[h]
  \begin{mathpar}
    \inferrule[FA-DUP]{
      \inferrule{
        \Gamma \vdash u,
        \mframe @ \pre(A(\vec i)),
        \mexec @ \pre(A(\vec i))
      }{
        \Gamma \vdash u,
        \mframe @ \pre(A(\vec i)),
        \myif \mexec @ \pre(A(\vec i)) \mythen \phi_{h} \myelse \bot
      }
    }{
      \Gamma \vdash u,
      \mframe @ \pre(A(\vec i)),
      \mexec @ \pre(A(\vec i)) \wedge \phi_{h}
    }
  \end{mathpar}

  We ask that $\phi_h \in H_{\{\pre(A(\vec i))\}}$ where, for any set of
  timestamps $T$, $H_T$ is the least set of formulas and messages
  closed under function application, boolean connectives, and the
  following rules:
  $$ \inferrule{
    B(\vec j) \in T
    \quad
    \phi \in H_{T\cup\{C(\vec {k})\}}
  }{
    (\forall \vec k.~ C(\vec k)\leq B(\vec j) \Rightarrow \phi) \in H_T
  }
  \quad\quad
  \inferrule{
    B(\vec j) \in T
    \quad
    \phi \in H_{T\cup\{C(\vec k)\}}
  }{
    (\exists \vec k.~ C(\vec k)\leq B(\vec j) \wedge \phi) \in H_T
  }
  $$
  $$\inferrule{B(\vec j) \in T}{
    \minp @ B(\vec j) \in H_T
  }\quad\quad
  \inferrule{ }{
    \minp @ A(\vec i) \in H_T
  }\quad\quad
  \inferrule{B(\vec j) \in T}{
    \mout @ B(\vec j) \in H_T
  }$$
  $$
  \inferrule{\phi \in H_T \quad B(\vec j) \in T}{
    (\myif \mexec @ B(\vec j) \mythen \phi \myelse \psi) \in H_T}
  $$
  \caption{FA-DUP rule.
  }
  \label{fig:fadup}
\end{figure}

\clearpage
\section{Archives}
\subsection{A proof technique}

Diff-equivalence is usually proved by induction and case analysis on
the timestamp. Even cases where the left and right actions are locally
identical are not trivial: it may be e.g.\ that the same name is outputted
by the action on both sides, but that each side has previously released
different information on that name.

To prove diff-equivalence, it can be interesting to prove that:
$$ \phi^L_\tr, \phi^R_\tr \vdash \phi^L_\alpha \Leftrightarrow \phi^R_\alpha $$

Then, in the induction step, we can directly replace the previous conditions by the same one.


This condition is only used to help for proving diff-equivalence, it is not necessary.
The gap comes from the fact that we are requiring conditions to be
synchronized for all random samplings.

\begin{example}
  With the bi-process of \cref{ex:negl} we would have to prove
  $\vdash g() = n \Leftrightarrow g() = m$ and
  $g()=n, g()=m \vdash \ok \sim \ok$, both of which hold.
  With the bi-process of \cref{ex:sync} we would have to prove
  $\vdash g() = (n)_0 \Leftrightarrow g() = (m)_0$ which does not hold.
\end{example}

\begin{example} \label{ex:indep}
  This proof technique does not work for \cref{ex:problem}.
  The same problem appears with the Basic-Hash protocol, even if we work around
  the problem described in \cref{sec:refined-diff}, we won't be able to show
  that conditionals are synchronized.  In the simple case of the trace
  $T(i,j).R(k,i,j)$ we have
  on the single-session side
  $$\pi_2(g_2(\pair{n_T(i,j),h(n_T(i,j),k'(i,j))})) =
  h(\pi_1(g_2(\ldots)),k'(i,j))$$
  and we would like this to imply (in the meta-logic)
  the same equality with $k(i)$ instead of $k'(i,j)$.
  This implication does not hold with overwhelming probability in all
  computational models: as in \cref{ex:problem}, $g_2(x)$ could be the second
  projection of $x$ with its first bit changed to $0$; if the hash is PRF,
  there should be a probability of roughly $1 \over 4$ that this leaves
  the hash unchanged with $k'(i,j)$ but not with $k(i)$.
\end{example}

\section{Outdated example : a signed DDH key exchange}
\charlie{abus de notations dans cette partie}

We brieffly show how one can prove the security of a signed DDH key exchange. The protocol in pi-calculus is provided in Figure~\ref{fig:signed_ddh} and the run of an honnest execution in Figure~\ref{fig:dh_ke}. This example is a simplified instance of classical key-exchange security. Notably, we assume that identities are already fixed.

\begin{figure}
  % \setlength{\belowcaptionskip}{-15pt}
  \setmsckeyword{} \drawframe{no}
  \setmscscale{0.9}
  \begin{center}
    \begin{msc}{}
      \setlength{\instwidth}{0\mscunit}
      \setlength{\instdist}{7cm}
      \setlength{\topheaddist}{0cm}
      \declinst{initiator}{
        \begin{tabular}[c]{c}
          \textsc{A} \\
          \colorbox{gray}{{\;\; $sk_A,a_i$\;\;}}
        \end{tabular}}{}

      \declinst{receiver}{
        \begin{tabular}[c]{c}
          \textsc{B} \\
          \colorbox{gray}{{\;\;  $sk_B,b_i$ \;\;}}
        \end{tabular}}{}

      \nextlevel[-1]
      \mess{$\mysign(g^{a_i},sk_A)$}{initiator}{receiver}
      \nextlevel[1.5]
      \mess{$\mysign(<g^{a_i},g^{b_i}>,sk_B)$}{receiver}{initiator}
      \nextlevel[1.5]
      \mess{$\mysign(<g^{a_i},g^{b_i}>,sk_A)$}{initiator}{receiver}




    \end{msc}
  \end{center}
  \caption{Diffie Hellman key exchange}\label{fig:dh_ke}
\end{figure}

\begin{figure}
  \[
    \begin{array}{cc}
      \begin{array}[t]{l@{~}l}
        A_i := & \aout{\mysign(g^{a_i},sk_A)} : \alpha_1; \\
        &\ain{x}; \\
        & \myif \mycsign(x,pk(sk_B)) \\
        & ~ \wedge \pi_1(\mygetmess(x))=g^{a_i}  \mythen \\
        & \quad \aout{\mysign(\mygetmess(x),sk_A) } : \alpha_2; \\
        & \quad \myfind j \mysuchthat g^{b_j} = \pi_2(\mygetmess(x)) \\
        & \qquad \aout{\diff{\pi_2(\mygetmess(x))^{a_i}}{k_{i,j}}} : \alpha_3\\
        & \quad \myelse \\
        & \qquad \aout{\diff{\pi_2(\mygetmess(x))^{a_i}}{\bot}}  : \alpha_4 \\
        & \myelse \\
        & \bot
      \end{array}
      &
      \begin{array}[t]{l@{~}l}
        B_i := &\ain{x}; \\
        & \myif \mycsign(x,pk(sk_A)) \mythen \\
        & \quad \aout{\mysign(<\mygetmess(x), g^{b_i}>,sk_B)} : \beta_1; \\
        & \quad \ain{y}; \\
        & \quad \myif \mycsign(y,pk(sk_A))\\
        & \quad ~ \wedge \mygetmess(y) = <\mygetmess(x), g^{b_i}> \mythen \\
        & \quad \quad \myfind j \mysuchthat g^{a_j} = \mygetmess(x) \\
        & \quad \qquad \aout{\diff{\mygetmess(x)^{b_i}}{k_{j,i}}} : \beta_2 \\
        & \quad \quad \myelse \\
        & \quad \qquad \aout{\diff{\mygetmess(x)^{b_i}}{\bot}} : \beta_3 \\
        & \quad \myelse \\
        & \quad \bot \\
        & \myelse \\
        & \bot
      \end{array}
    \end{array}
  \]
  \label{fig:signed_ddh}
  \caption{A signed DDH key exchange}
\end{figure}

We outline the proof of the fact that $!_i A_i \| B_i$ is diff-equivalent. There are four actions with choices in the output, thus, we have to show that, for all trace $\tr$, for all $i,j$:
\begin{enumerate}
\item $\begin{array}[t]{l}
    \phi_\tr,  \mycsign(x,pk(sk_B)), \mygetmess(x)=<g^{a_i}, g^{b_j}>, \mouts_\tr^L \sim \mouts_\tr^R,  \\
    \quad \vDash \mouts_\tr^L, \pi_2(\mygetmess(x))^{a_i} \sim \mouts_\tr^R, k_{i,j}
  \end{array}
  $ ($\alpha_3$)

\item $\begin{array}[t]{l}
    \phi_\tr,  \mycsign(x,pk(sk_B)),  \not \exists j. \pi_2(mygetmess(x))= g^{b_j},  \mouts_\tr^R \sim \mouts_\tr^L \\
    \quad \vDash \mouts_\tr^L, \pi_2(\mygetmess(x))^{a_i} \sim \mouts_\tr^R, \bot
  \end{array} $ ($\alpha_4$)
\item $\begin{array}[t]{l}
    \phi_\tr,  \mycsign(y,pk(sk_A)), \mycsign(x,pk(sk_A)), \mygetmess(y)=<g^{a_j}, g^{b_i}>,  \mouts_\tr^R \sim \mouts_\tr^L \\ \quad \vDash \mouts_\tr^L, \pi_2(\mygetmess(x))^{b_i} \sim \mouts_\tr^R, k_{j,i}
  \end{array}$ ($\beta_2$)
\item $\begin{array}[t]{l}
    \phi_\tr,  \mycsign(y,pk(sk_A)), \mycsign(x,pk(sk_A)),  \not \exists j. \pi_2(mygetmess(x))= g^{b_j},  \mouts_\tr^R \sim \mouts_\tr^L\\
    \vDash \mouts_\tr^L, \pi_2(\mygetmess(x))^{b_i} \sim \mouts_\tr^R, \bot
  \end{array}$ ($\beta_3$)
\end{enumerate}

Regarding goal $(2)$ and $(4)$, we remark that it is a case where $\Gamma \vdash \false$. Indeed, for $(2)$ applying EUFCMA yields that there exists $j$ such that $x = \mysign(<g^{a_i},g^{b_j}>,sk_B)$ which is in contradiction with  $\not \exists j. \pi_2(mygetmess(x))= g^{b_j}$.

Regarding goals $(1)$ and $(3)$, we mainly use DDH. To this end, we first use EUFMCA, to ensure that we have a matching conversation between the two sessions, and then use DDH. \charlie{je détail pas, ça prend du temps de formaliser proprement DDH vis à vis des actions, et je pense pas que ce soit l'objectif actuel}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
