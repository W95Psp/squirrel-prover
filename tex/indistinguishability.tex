\section{Indistinguishability}
\charlie{not up to date}
\newcommand{\pair}[1]{\langle #1 \rangle}

We now define indistinguishability of processes, and how we could verify it.
We make a distinction between symbolic and observable traces:
symbolic ones are sequences of action names as in \cref{def:trace},
while observable traces are sequences of pairs $\pair{c_i,c_o}$.
Intuitively, such a pair describes the input and output channels of an
action; several actions might have the same input and output channels.
We write $A : \pair{c_i,c_o}$ when action $A$ inputs on channel $c_i$ and
outputs on channel $c_o$.

For convenience, we talk of processes, though in reality the definitions
deal with abstract systems described by sets of actions.

\newcommand{\fold}{\mathsf{fold}}

\begin{definition}
  Given an observable trace $t$ and a process $P$,
  we define $\fold(P,t)$ as the frame describing all possible
  executions of $P$ along $t$:
  \begin{eqnarray*}
    \fold(P,\epsilon) &=& \epsilon \\
    \fold(P,(c_i,c_o).t') &=&
      \mathsf{if}_{A:(c_i,c_o)}
      \ldots
  \end{eqnarray*}
\end{definition}

\begin{definition}
  Two processes $P$ and $Q$ are indistinguishable when,
  for all observable traces $t$,
  for all computational model $\Mo$,
  we have
  $\Mo \models \fold(P,t) \sim \fold(Q,t)$.
  This itself means that no attacker can distinguish,
  with non-negligible probability, between the left- and right-hand sides.
\end{definition}

This notion of equivalence should coincide with the usual computational
indistinguishability for bounded processes. In the unbounded case, it
is restrictive to quantify on traces in this way
and ask for indistinguishability only for each trace.

\subsection{Straightforward diff-equivalence}

Two processes may be given as a bi-process, i.e. a system with a single set of
symbolic actions, each symbolic action describing an execution step of both the
left and right processes, using $\diff{\_}{\_}$ terms as usual. In that case, we
may define a stronger equivalence, where processes have the same set of possible
actions, and may only differ on some terms, inside actions outputs or
conditions. Diff-equivalence then ask that for any sequence of such symbolic
actions, the observable traces are indistinguishable.

We
use $(\_)^L$ and $(\_)^R$ to denote the left and right projections,
e.g. $\phi_\tr^L$ is the conjunction of all the left-hand side conditions for
the left side of the bi-process.  We can the use the notations $\minp^L$, $\minp^R$, $\mout^L$
and $\mout^R$, where for instance, $\minp^L@A$ represents the input term for
the left at timestamp $A$ in a trace.

For concision, we write $\myif \phi \mythen t$ for
$\myif \phi \mythen t \myelse \mathsf{error}$, with an error constant that is
unused elsewhere.

\begin{definition}
  We define inductively the frame of a trace, where for any action $\alpha$ and any trace $\tr$,
  \[\begin{array}{l}
     \mouts_{\alpha} = \myif \phi_{\alpha} \mythen \mout(\alpha) \\
     \mouts_{\tr . \alpha} = \pair{\mouts_\alpha,\dots, \myif \phi_{\tr . \alpha} \mythen \mout(\alpha)}
     \end{array}\]
  as the sequence of outputs produced by the trace.
\end{definition}

The definition of the meta interpretation $I_\tr$ of a trace is similar to previously, with only a change for inputs:
\[\hat{\minp}^L(A_n) = g_n( (\mouts_{A_1\cdots A_{n-1}})^{\I_\tr})\]

  Remark that for reachability, we assume that the trace can occur, and thus,
  that all conditionals $\phi_{\tr . \alpha}$ are true. Then,
  $\mouts_{A_1\cdots A_{n-1}}$ is syntactically equal to
    $\mout(A_1),\cdot,\mout(A_{n-1})$, as we can remove the true
    conditionals. For indistinguishability, we need to verify that the
    conditionals are synchronized on both sides, and we must keep them inside
    the terms.

We now define the equivalence,


\begin{definition}
  A bi-process is diff-equivalent when,
  for any symbolic trace $\tr$ of the protocol and
  for any computational model $\Mo$,
  we have:
  \[\Mo \models (\mouts_{\tr}^L)^{I_\tr}  \sim (\mouts_{\tr}^R)^{I_\tr}\]
\end{definition}

Note that this equivalence cannot hold if there exists a $\tr$
whose probability of execution significantly differs between the two
projections of the bi-process.
Hence this imposes a form of synchronization on the execution of
conditionals on the two sides of bi-processes.
The interest of imposing this artificial constraint is that we
can stop considering executions where one process goes to $\mythen$
branch while the other goes to its $\myelse$ branch: this is implicit
in the fact that we consider here symbolic and not observable traces.

\newcommand{\In}{\mathsf{in}}
\newcommand{\Out}{\mathsf{out}}

\begin{example}
  Consider the bi-process
  $\In(c,x).\myif x=\diff{0}{1} \mythen \Out(c,n) \myelse \Out(c,m)$
  where $n$ and $m$ are arbitrary, possibly equal names.
  Its two projections are indistinguishable, but the
  bi-process is not diff-equivalent.
  Indeed we have
  $\myif g()=0 \mythen \Out(c,n) \not\sim
   \myif g()=1 \mythen \Out(c,m)$: the attacker can simply choose
  $g()=0$ to distinguish the two sides.
  Our bi-process can however easily be
  rewritten into a diff-equivalent process, e.g. by pushing the conditional
  inside the output.

  If we modify our bi-process into
  $\In(c,x).\myif x=\diff{0}{1} \mythen \Out(c,n) \myelse \Out(c,0)$
  then the two projections become distinguishable.
  The attack is obtained with an execution
  where one process outputs a name while the other outputs $0$. Such
  desynchronized executions are not taken into account with diff-equivalence,
  but diff-equivalence still fails due to the desynchronized condition,
  as before.
\end{example}

In the next example, we omit the $\myelse$ branch when it consists of a null
process. In these examples, there is a coincidence between diff-equivalence
and indistinguishability, because observable actions coincide with symbolic
actions.

\begin{example} \label{ex:negl}
  Consider the bi-process
  $\In(c,x).\myif x=\diff{n}{m} \mythen \Out(c,\ok)$.
  It is diff-equivalent, and its projections are
  indistinguishable as expected.
  In the bi-process, the condition $x=\diff{n}{m}$ does not pass
  with the same inputs on the left and right, but it passes with
  the same negligible probability.
\end{example}

\begin{example} \label{ex:sync}
  Consider
  $\In(c,x).\myif x=(\diff{n}{m})_0 \mythen \Out(c,n)$
  where $(t)_0$ denotes the first bit of $t$.
  This bi-process is not diff-equivalent because
  $\myif x=(n)_0 \mythen n \not\sim \myif x=(m)_0 \mythen n$, and
  the two projections are distinguishable for the same
  reason: the attacker sends $0$;
  on the left he receives with probability $1\over 2$ a bitstring whose
  first bit is $0$;
  on the right process he receives with probably only $1\over 4$
  a bitstring whose last bit is $0$.
  If we change $\Out(c,n)$ into $\Out(c,\ok)$,
  we have indistinguishable processes and diff-equivalence holds.
\end{example}

\begin{example} \label{ex:problem}
  Consider $\Out(c,\diff{n}{m}).
  \In(c,x).
  \myif x=\diff{n}{m} \mythen \Out(c,\ok)$.
  The projections are observationally equivalent and diff-equivalence
  holds -- in fact they are $\alpha$-equivalent.
\end{example}


\subsection{Reasoning about equivalences}

We leverage the meta-logic, to reason abstractly on all possible traces.
Given a bi-process $B$, we should be able to give a meaning to its inputs
and outputs along a trace using macros $\minp^L$, $\minp^R$, $\mout^L$
and $\mout^R$. For instance, $\minp^L@A$ represents the input term for
the left at timestamp $A$ in a trace --- the meta-interpretation will
be such that
$\hat{\minp}^L(A_n) = g_n( \mouts_{A_1\cdots A_{n-1}})$.

We extend the sequent calculus, to also reason about diff-equivalence.

\begin{definition}
  A sequent $\Gamma \vdash t_L \sim t_R $ is composed of a set of indistinguishability $\Gamma$, and sequences of terms $t_L,t_R$.
  It is valid when, for any meta-interpretation $I$, for any evaluation of the free variables in $t_L,t_R$ to well typed elements in $I$ and computational model $\Mo$, $\Mo \models (\wedge \Gamma)^I \Rightarrow (t_L)^I \sim  (t_R)^I $
\end{definition}

To reason abstractly on all possible traces, we define the macros $\mouts^X@A$, which given a trace $\tr = \tr_1 . A . \tr_2$, are interpreted by:
$$\hat{\mouts}^X(A) = (\mouts_{\tr_1.A}^X)^{I_\tr} $$

We will write for concision $\happens(A)$ for $\happens(A) \sim \true$.
\begin{lemma}
  A bi-process is diff-equivalent if,
  \[ \happens(\tau)\vdash  \mouts^L@\tau \sim \mouts^R@\tau\]
  Equivalently, is it diff-equivalent if:
  \[\mouts^L@\pre(\tau) \sim \mouts^R@\pre(\tau) \wedge \happens(\tau) \vdash \mouts^L@\tau \sim \mouts^R@\tau\]
\end{lemma}
\begin{proof}We prove the first implication, which is essentially an unfolding of definitions.

  Let $\Mo$ be a computational model and $\tr = A_1 \cdots A_n$ a symbolic trace of a bi-process.
  We assume that  $ \happens (\tau)  \vdash \mouts^L@\tau \sim \mouts^R@\tau$, i.e that for any-meta interpretation $I$ and model $\Mo'$, $\Mo' \models (\happens(\tau))^I \rightarrow (\mouts^L@\tau \sim \mouts^R@\tau)^I$. We instantiate $\Mo'$ with $\Mo$ , and $I$ with the meta interpretation $\I_\tr$ such that $\tau \mapsto A_n$. Then, as $\happens(A_n)^I = \true$, we conclude that $\Mo' \models  (\mouts^L@A_n \sim \mouts^R@A_n)^I$.\\

  The second implication is a direct induction on the length of the traces.
  \end{proof}

We provide in \cref{fig:lk-ind} a set of sound rules for this second sequent calculus.

\begin{figure}
  \begin{mathpar}
    \inferrule[Expand]{\Gamma \vdash t_L \sim t_R
\quad
    }{\Gamma \cup \phi \vdash t_L \sim t_R}
    \quad\quad
    \inferrule[Cut]{
      \Gamma \vdash t_L \sim t_R
      \quad
      \Gamma \vdash t_R \sim t_S
    }{\Gamma \vdash t_L \sim t_S}
  \end{mathpar}
  \begin{mathpar}
  \inferrule[\myif-explicit]{
\Gamma \vdash \myif \phi \mythen t_L \sim \myif \psi \mythen t_R
  }{
 \Gamma  \vdash \phi, \myif \phi \mythen t_L \sim \psi, \myif \psi \mythen t_R
  }
  \quad\quad
  \inferrule[\myif-weak]{
 \Gamma \vdash \phi, t_L \sim \phi, t_R
  }{
\Gamma \vdash \myif  \phi \mythen t_L \sim \myif \phi \mythen t_R
  }
\end{mathpar}

  \begin{mathpar}
  \inferrule[\myif-reach]{
\phi \vdash \false
  }{
 \Gamma  \vdash \myif \phi \mythen t_L \sim  \myif \phi \mythen t_R
  }
  \quad\quad
  \inferrule[\myif-equiv]{
 \phi \vdash \psi \Leftrightarrow \psi'
  }{
\Gamma \vdash \myif  \phi \wedge \psi \mythen t \sim \myif \phi \wedge \psi' \mythen t
  }
  \end{mathpar}
  \begin{mathpar}
    \inferrule[${\lnot}$-R]{
      \Gamma \vdash \false \sim \true
    }{
      \Gamma \vdash t^L \sim t^R
    }
    \quad\quad
    \inferrule[fresh]{
n,m \not \in \Gamma
    }{
      \Gamma \vdash n \sim m
    }
    \quad\quad
    \inferrule[Subst]{
      \Gamma \cup \{\EQ(t_1,t_2)\sim \true \}  \vdash t^L \sim t^R
    }{
      \Gamma \cup \{\EQ(t_1,t_2)\sim \true \} \vdash t^L[ t_1 / t_2] \sim  t^R[ t_1 / t_2]
    }
  \end{mathpar}
  \begin{mathpar}
  \inferrule[F-Cut]{
    \Gamma \vdash \phi
    \quad
    \Gamma \cup \phi \vdash t^L \sim t^R
  }{
 \Gamma \vdash t^L \sim t^R
  }
  \quad\quad
  \inferrule[Dup]{
 \Gamma \vdash t^L,u \sim t^R,v
  }{
 \Gamma \vdash t^L,u,u \sim t^R,v,v
  }
  \end{mathpar}


   \caption{Generic inference rules for indistinguishability}
   \label{fig:lk-ind}
\end{figure}
\begin{lemma}
The rules presented in Figure~\ref{fig:lk-ind} are sound.


\end{lemma}
\begin{proof}
  \begin{itemize}
    \item $\textsc{\myif-explicit}$
      We assume that we have a model and an interpretation such that
      $\Mo,\Gamma \not \models  \phi^I, (\myif  \phi \mythen t_L)^I \sim \psi^I, (\myif \phi \mythen t_R)^I $.
      It means we have a distinguisher $\B$ against this equivalence.
      We define $\B'$, which on input $x$:
      \begin{enumerate}
      \item if $x = \mathsf{error}$, sets a variable $y$ to $\false$, else to $\true$;
      \item simulates $\B$ with input $y,x$ and returns its result.
      \end{enumerate}
      When $x$ is equal to $(\myif \phi \mythen t_L)^I $ (resp. $(\myif \phi \mythen t_R)^I$ ), the computed $y$ has exactly the same distribution as the interpretation of $\phi^I$ (resp. $\psi^I)$) in $\Mo$.
      Thus $\B'$ is a distinguisher which shows that:
    $\Mo,\Gamma \not \models (\myif  \phi \mythen t_L)^I \sim  (\myif \phi \mythen t_R)^I $.
      It concludes that $\Gamma \not \vdash \myif  \phi \mythen t_L \sim \myif  \phi \mythen t_R$.

    \end{itemize}
\end{proof}


We can then use those rules to prove diff-equivalence of a bi-process, by defining a well chosen set of axioms. We can reuse most of the trace axioms defined previously, the only one which is not pertinent anymore is, for any $\alpha$:
\[   (\happens(\alpha) \Rightarrow
  \phi_\alpha\{x_\beta\mapsto\minp@\beta\}_\beta) \sim \true\]
Indeed, this version is useful and sound for reachability, but is not sound for indistinguishability, where we need to shows that conditionals are synchronized on both sides, which becomes trivial if we assume them to be equal to $\true$.

\paragraph{Other rules.}

\Cref{fig:fresh,fig:prf} presents the rules for Fresh and PRF tactics.
We use the following notations:
\begin{itemize}
  \item $\Gamma \vdash u$ stands for $\Gamma^L \sim \Gamma^R \vdash u^L \sim u^R$
  \item $A \in S$ stands for every action in the system (or protocol)
  \item $A(\vec i)^L$ represents the left projection of meta-logic bi-terms and bi-formulas describing the action $A(\vec k)$ (outputs, updates and conditions)
  \item $k \sqsubseteq_{\h(\_,\cdot)} u$ means that $k$ appears only in key positions in $u$
  \item indices $\vec i$ are chosen fresh related to the appropriate environment ($u, C, \vec {j_L}, \vec {j_R}$ for Fresh and $u, C, t, k$ for PRF)
\end{itemize}

\begin{figure}[h]
  \begin{mathpar}
  \inferrule[Fresh]{
    \Gamma \vdash u, C[\myif \phi_L \wedge \phi_R \mythen 0 \myelse \diff{n_L(\vec {j_L})}{n_R(\vec {j_R})}]
  }{
    \Gamma \vdash u, C[\diff{n_L(\vec {j_L})}{n_R(\vec {j_R})}]
  }
  \end{mathpar}
  \begin{mathpar}
    \phi_L = \big( \displaystyle\bigwedge_{n_L(\vec j) \in u^L,C^L} \vec j \neq \vec {j_L} \big)
    \wedge
    \big(
      \displaystyle\bigwedge_{A \in S}
      \forall \vec i \
      \big(\displaystyle\bigvee_{\tau \in u^L,C^L} A(\vec i) \leq \tau \big)
      \Rightarrow
      \big(\displaystyle\bigwedge_{n_L(\vec j) \in A(\vec i)^L} \vec j \neq \vec {j_L} \big)
    \big)
  \end{mathpar}
  \begin{mathpar}
  \phi_R = ... \ \text{(similar, replacing $L$ by $R$)}
  \end{mathpar}
\caption{Fresh rule.}
\label{fig:fresh}
\end{figure}

\begin{figure}[h]
  \begin{mathpar}
  \inferrule[PRF]{
    \Gamma \vdash u, C[\myif \diff{\phi_L}{\phi_R} \mythen n \myelse \h(t,k)]
    \quad \quad
    k \sqsubseteq_{\h(\_,\cdot)} u,C,A(\vec i)
  }{
    \Gamma \vdash u, C[\h(t,k)]
  }
  \end{mathpar}
  \begin{mathpar}
  \phi_L = \big( \displaystyle\bigwedge_{\h(m,k) \in u^L,C^L,t^L} t^L \neq m \big)
  \wedge
  \big(
    \displaystyle\bigwedge_{A \in S}
    \forall \vec i \
    \big(\displaystyle\bigvee_{\tau \in u^L,C^L,t^L} A(\vec i) < \tau \big)
    \Rightarrow
    \big(\displaystyle\bigwedge_{\h(m,k) \in A(\vec i)^L} t^L \neq m \big)
  \big)
  \end{mathpar}
  \begin{mathpar}
  \phi_R = ... \ \text{(similar, replacing $L$ by $R$)}
  \end{mathpar}
\caption{PRF rule.}
\label{fig:prf}
\end{figure}


\subsection{A proof technique}

Diff-equivalence is usually proved by induction and case analysis on
the timestamp. Even cases where the left and right actions are locally
identical are not trivial: it may be e.g.\ that the same name is outputted
by the action on both sides, but that each side has previously released
different information on that name.

To prove diff-equivalence, it can be interesting to prove that:
$$ \phi^L_\tr, \phi^R_\tr \vdash \phi^L_\alpha \Leftrightarrow \phi^R_\alpha $$

Then, in the induction step, we can directly replace the previous conditions by the same one.


This condition is only used to help for proving diff-equivalence, it is not necessary.
The gap comes from the fact that we are requiring conditions to be
synchronized for all random samplings.

\begin{example}
  With the bi-process of \cref{ex:negl} we would have to prove
  $\vdash g() = n \Leftrightarrow g() = m$ and
  $g()=n, g()=m \vdash \ok \sim \ok$, both of which hold.
  With the bi-process of \cref{ex:sync} we would have to prove
  $\vdash g() = (n)_0 \Leftrightarrow g() = (m)_0$ which does not hold.
\end{example}

\begin{example} \label{ex:indep}
  This proof technique does not work for \cref{ex:problem}.
  The same problem appears with the Basic-Hash protocol, even if we work around
the problem described in \cref{sec:refined-diff}, we won't be able to show
that conditionals are synchronized.  In the simple case of the trace
$T(i,j).R(k,i,j)$ we have
on the single-session side
$$\pi_2(g_2(\pair{n_T(i,j),h(n_T(i,j),k'(i,j))})) =
 h(\pi_1(g_2(\ldots)),k'(i,j))$$
and we would like this to imply (in the meta-logic)
the same equality with $k(i)$ instead of $k'(i,j)$.
This implication does not hold with overwhelming probability in all
computational models: as in \cref{ex:problem}, $g_2(x)$ could be the second
projection of $x$ with its first bit changed to $0$; if the hash is PRF,
there should be a probability of roughly $1 \over 4$ that this leaves
the hash unchanged with $k'(i,j)$ but not with $k(i)$.
\end{example}

\section{Outdated example : a signed DDH key exchange}
\charlie{abus de notations dans cette partie}

We brieffly show how one can prove the security of a signed DDH key exchange. The protocol in pi-calculus is provided in Figure~\ref{fig:signed_ddh} and the run of an honnest execution in Figure~\ref{fig:dh_ke}. This example is a simplified instance of classical key-exchange security. Notably, we assume that identities are already fixed.

\begin{figure}
    % \setlength{\belowcaptionskip}{-15pt}
    \setmsckeyword{} \drawframe{no}
    \setmscscale{0.9}
    \begin{center}
    \begin{msc}{}
        \setlength{\instwidth}{0\mscunit}
        \setlength{\instdist}{7cm}
        \setlength{\topheaddist}{0cm}
        \declinst{initiator}{
            \begin{tabular}[c]{c}
                \textsc{A} \\
                \colorbox{gray}{{\;\; $sk_A,a_i$\;\;}}
        \end{tabular}}{}

        \declinst{receiver}{
            \begin{tabular}[c]{c}
                \textsc{B} \\
                \colorbox{gray}{{\;\;  $sk_B,b_i$ \;\;}}
        \end{tabular}}{}

        \nextlevel[-1]
        \mess{$\mysign(g^{a_i},sk_A)$}{initiator}{receiver}
        \nextlevel[1.5]
        \mess{$\mysign(<g^{a_i},g^{b_i}>,sk_B)$}{receiver}{initiator}
         \nextlevel[1.5]
         \mess{$\mysign(<g^{a_i},g^{b_i}>,sk_A)$}{initiator}{receiver}




       \end{msc}
       \end{center}
    \caption{Diffie Hellman key exchange}\label{fig:dh_ke}
\end{figure}

\begin{figure}
\[
  \begin{array}{cc}
\begin{array}[t]{l@{~}l}
  A_i := & \aout{\mysign(g^{a_i},sk_A)} : \alpha_1; \\
         &\ain{x}; \\
         & \myif \mycsign(x,pk(sk_B)) \\
  & ~ \wedge \pi_1(\mygetmess(x))=g^{a_i}  \mythen \\
         & \quad \aout{\mysign(\mygetmess(x),sk_A) } : \alpha_2; \\
         & \quad \myfind j \mysuchthat g^{b_j} = \pi_2(\mygetmess(x)) \\
           & \qquad \aout{\diff{\pi_2(\mygetmess(x))^{a_i}}{k_{i,j}}} : \alpha_3\\
         & \quad \myelse \\
         & \qquad \aout{\diff{\pi_2(\mygetmess(x))^{a_i}}{\bot}}  : \alpha_4 \\
         & \myelse \\
           & \bot
\end{array}
&
\begin{array}[t]{l@{~}l}
  B_i := &\ain{x}; \\
         & \myif \mycsign(x,pk(sk_A)) \mythen \\
         & \quad \aout{\mysign(<\mygetmess(x), g^{b_i}>,sk_B)} : \beta_1; \\
         & \quad \ain{y}; \\
         & \quad \myif \mycsign(y,pk(sk_A))\\
  & \quad ~ \wedge \mygetmess(y) = <\mygetmess(x), g^{b_i}> \mythen \\
         & \quad \quad \myfind j \mysuchthat g^{a_j} = \mygetmess(x) \\
           & \quad \qquad \aout{\diff{\mygetmess(x)^{b_i}}{k_{j,i}}} : \beta_2 \\
         & \quad \quad \myelse \\
         & \quad \qquad \aout{\diff{\mygetmess(x)^{b_i}}{\bot}} : \beta_3 \\
         & \quad \myelse \\
           & \quad \bot \\
         & \myelse \\
           & \bot
\end{array}
\end{array}
\]
\label{fig:signed_ddh}
\caption{A signed DDH key exchange}
\end{figure}

We outline the proof of the fact that $!_i A_i \| B_i$ is diff-equivalent. There are four actions with choices in the output, thus, we have to show that, for all trace $\tr$, for all $i,j$:
\begin{enumerate}
\item $\begin{array}[t]{l}
         \phi_\tr,  \mycsign(x,pk(sk_B)), \mygetmess(x)=<g^{a_i}, g^{b_j}>, \mouts_\tr^L \sim \mouts_\tr^R,  \\
         \quad \vDash \mouts_\tr^L, \pi_2(\mygetmess(x))^{a_i} \sim \mouts_\tr^R, k_{i,j}
\end{array}
         $ ($\alpha_3$)

       \item $\begin{array}[t]{l}
                \phi_\tr,  \mycsign(x,pk(sk_B)),  \not \exists j. \pi_2(mygetmess(x))= g^{b_j},  \mouts_\tr^R \sim \mouts_\tr^L \\
                \quad \vDash \mouts_\tr^L, \pi_2(\mygetmess(x))^{a_i} \sim \mouts_\tr^R, \bot
                \end{array} $ ($\alpha_4$)
              \item $\begin{array}[t]{l}
                       \phi_\tr,  \mycsign(y,pk(sk_A)), \mycsign(x,pk(sk_A)), \mygetmess(y)=<g^{a_j}, g^{b_i}>,  \mouts_\tr^R \sim \mouts_\tr^L \\ \quad \vDash \mouts_\tr^L, \pi_2(\mygetmess(x))^{b_i} \sim \mouts_\tr^R, k_{j,i}
                     \end{array}$ ($\beta_2$)
              \item $\begin{array}[t]{l}
                       \phi_\tr,  \mycsign(y,pk(sk_A)), \mycsign(x,pk(sk_A)),  \not \exists j. \pi_2(mygetmess(x))= g^{b_j},  \mouts_\tr^R \sim \mouts_\tr^L\\
 \vDash \mouts_\tr^L, \pi_2(\mygetmess(x))^{b_i} \sim \mouts_\tr^R, \bot
                       \end{array}$ ($\beta_3$)
\end{enumerate}

Regarding goal $(2)$ and $(4)$, we remark that it is a case where $\Gamma \vdash \false$. Indeed, for $(2)$ applying EUFCMA yields that there exists $j$ such that $x = \mysign(<g^{a_i},g^{b_j}>,sk_B)$ which is in contradiction with  $\not \exists j. \pi_2(mygetmess(x))= g^{b_j}$.

Regarding goals $(1)$ and $(3)$, we mainly use DDH. To this end, we first use EUFMCA, to ensure that we have a matching conversation between the two sessions, and then use DDH. \charlie{je détail pas, ça prend du temps de formaliser proprement DDH vis à vis des actions, et je pense pas que ce soit l'objectif actuel}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
