\documentclass[a4paper]{article}

\usepackage{lipsum}
\usepackage[normalem]{ulem}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{framed}
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{xspace}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{cite}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage[margin=2cm]{geometry}
\usepackage{multicol}

\usepackage{url}
\usepackage{tikz}
\usepackage{proof}
\usepackage{hyperref}
\usepackage[capitalize,nameinlink,noabbrev]{cleveref}
\usepackage{enumerate}

\setlength{\ULdepth}{0.15em}

\usetikzlibrary{backgrounds}
\usetikzlibrary{intersections}
\usetikzlibrary{scopes}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing,shapes}
\usetikzlibrary{backgrounds}
\usetikzlibrary{shapes.misc}

\newtheorem{assumption}{Assumption}
\newtheorem*{theorem*}{Theorem}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{proposition*}{Proposition}



\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{proposition}{Proposition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}

\theoremstyle{remark}
\newtheorem{remark}{Remark}

\newcommand{\todo}[1]{\textcolor{red}{(\textbf{TD:} #1)}}
\newcommand{\toadd}[1]{\textcolor{blue}{(\textbf{TA:} #1)}}

\newcommand{\charlie}[1]{\textcolor{cyan}{(\textbf{Charlie:} #1)}}

\input{macros.tex}

\begin{document}
\title{Meta-Logic for BC}

\author{David Baelde, Stéphanie Delaune,
  Charlie Jacomme, Adrien Koutsos, Solène Moreau}

\maketitle

Bana and Comon have introduced an approach, which they call
\emph{computationally complete symbolic attacker} (CCSA),
to formulate security properties in the computational model as a first-order
logic formulas. Roughly, the translate a security property (for a finite set
of traces) as a first-order formula, then they seek to show that this formula
is valid in all \emph{computational models} where attacker computations
are unspecified and primitives satisfy some cryptographic assumptions. They
way this is done is by showing that the formula is a logical consequence of
some axioms, which are sound wrt.\ the considered class of computational 
models.

We introduce here a \emph{meta-logic} whose formulas correspond to schemas
of formulas in the \emph{base logic}
--- which we might call the CCSA or BC logic.
We present inference rules which are sound in the same way as before,
i.e.\ any instance of the schema is a formula that is valid in all
computational models subject to the relevant cryptographic assumptions.

We define next the meta-logic which abstractly allows to reason about
executions of a protocol. The precise definition of protocols and their
semantics is not needed for that first step, and is defined only in a
second part.

\section{A Logic for abstract sequence of actions}

\subsection{The base logic}

The base logic is that of Bana and Comon (CCS'14). It is first-order logic
with a distinguished kind of constant for representing names (written
$\mathsf{n}$, $\mathsf{m}$, $\mathsf{k}$, etc.)
and featuring a single predicate noted $\sim$ (or rather, a family
of predicates $\sim_k$ of arity $2 k$ for all $k\in\mathbb{N}$).
The terms are all of the same sort: they are meant to represent 
messages\footnote{
  David: I hope/believe that the distinction between booleans and messages
  can be ignored for the theory.
}.

In practice, the logic will be considered with function symbols for 
representing cryptographic primitives as well as attacker computations, and 
boolean constants and connectives.

The formulas of the base logic are intended to be interpreted in 
\emph{computational models}, where:
\begin{itemize}
  \item terms are interpreted as PPT Turing machines which,
    given infinite random tapes and a security parameter output a bitstring;
  \item $\sim$ is interpreted as indistinguishability;
  \item names are independent random samplings;
  \item function symbols correspond to deterministic machines.
\end{itemize}

In particular, function symbols corresponding to cryptographic primitives
are interpreted as implementations of the primitives, subject to some
assumptions.

For example, if $\mathsf{n}$ and $\mathsf{m}$ are distinct names,
the (atomic) formulas $\mathsf{n}\sim\mathsf{m}$ and 
$\mathsf{n}\stackrel{.}{=}\mathsf{m}\sim\mathsf{false}$
are valid.

\subsection{Syntax of the meta-logic}

Terms of the meta-logic are of three possible sorts: index, timestamps
or message. Formulas of the meta-logic may feature predicates over each sort.
Given interpretation $I$ and $T$ of index and timestamp variables
into two finite sets, a formula $\phi$ of the meta-logic will be translated 
into a term $(\phi)^{I,T}$ of the base logic in which index and action terms, 
and predicates over them, will have disappeared. The validity of the 
meta-logic formula $\phi$ will be defined as the validity of the base logic
$(\phi)^{I,T}\sim\mathsf{true}$.

\medskip

We assume three infinite sets of variables:
$\X$ (whose elements are noted $x$, $y$, $z$) for message variables;
$\I$ (whose elements are noted $i$, $j$, $k$) for index variables;
$\XT$ (whose elements are noted $\tau$) for timestamp variables.

We assume a set $\F$ a set of indexed function symbols
(used to model encryptions, pairs,\dots).
Each of these symbols comes with an index arity as well as an unusual arity:
if $f\in\F$ has index arity $k$ and arity $n$,
then for all index variables $i_1,\ldots,i_k$ and terms $t_1,\ldots,t_n$,
$f[i_1,\ldots,i_k](t_1,\ldots,t_n)$ is a term.

We assume a set $\N$ of indexed names symbols,
(used to model the randomness used in a protocol)
and a sets of indexed constants $\Actions$
(used to model specific timestamps).
These indexed symbols only have an index arity: they
cannot be applied to terms.

We finally assume a set $\M$ of indexed macro symbols
equipped with an arity and index arity, like function symbols.
An indexed macro symbol will be applied to the specified number of
indices, variables, and also to a single timestamp.
We will typically assume macro symbols $\mout$ and $\minp$
(with index arity $0$) for representing messages inputted and outputted
at a particular point of an execution.

We shall write $\F_k$ (resp.\ $\N_k$ or $\M_k$) for the set of function
symbols (resp.\ name or macro symbols) of index arity $k$.

\begin{figure}
\[
  \begin{array}{rcll}
    n &:=& \mathsf{n}[i_1,\ldots,i_n] & (\mathsf{n}\in\N_k)
    \\
    F &:=& f[i_1,\ldots,i_k] & (f\in\F_k)
    \\
    M &:=& m[i_1,\ldots,i_k] & (m\in\M_k)
  \end{array}
\]
\[
  \begin{array}{rcll}
    T &:=& \tau & \text{timestamp variable} \\
      &\mid& a[i_1,\ldots,i_k] & \text{constant (for $a\in\mathbb{A}$)} \\
      &\mid & \pre(T) & \text{predecessor}
\end{array}
   \]
\[
     \begin{array}{rcll}
    t & := & n &\text{name} \\
    & \mid & x  & \text{message variable $x\in\X$} \\
    & \mid & F(t_1,\dots,t_n) &\text{function application}\\
    & \mid & M(t_1,\ldots,t_n)@T &\text{macro application}\\
       \end{array}
     \]
     \caption{Meta-logic terms}\label{fig:terms}
\end{figure}

\begin{definition}
  Given a signature $\Sigma = (\F,\N,\M,\Actions)$ and some sets of variables
  $\X$, $\I$ and $\XT$,
  \cref{fig:terms} defines the syntax of (meta-logic) terms
  of sort message (noted $t$) and timestamp (noted $T$).
  The only terms of sort index are index variables.
  The set of message terms of the meta-logic is noted $\Msg_\Sigma$.
\end{definition}

We can now define a meta-interpretation as the structure needed to
give a meaning to index and timestamp terms. A meta-interpretation
also induces a translation from a meta-logic signature $\Sigma$
to some base logic signature $\Sigma^I$. For example, if
$\Sigma$ contains a name $\mathsf{n}$ with index arity $1$, and
the meta-interpretation interprets indices in a domain $D_\I = \{
  17, 22 \}$, the base logic signature will feature
two names $\mathsf{n}_{17}$ and $\mathsf{n}_{22}$.

\begin{definition}
  A meta-interpretation $I$ for $\Sigma = (\F,\M,\N)$ consists in:
  \begin{itemize}
    \item two finite sets $D_\I$ and $D_\XT$ called the index and timestamp
      domains of the interpretation;
    \item mappings $\sigma_\I : \I \to D_\I$
      and $\sigma_\XT : \XT \to D_\XT$ that interpret index and
      timestamp variables as elements of their respective domains;
    \item a total ordering $\leq$ over $D_\XT$,
      a function $p : D_\XT \to D_\XT$ (for interpreting the 
      predecessor\footnote{
        It does not matter that the predecessor means anything
        wrt.\ the ordering. We will impose later that it behaves
        well enough.
      })
      and a subset $H_\XT\in D_\XT$ (for identifying timestamps
      that actuallly happen in an execution\footnote{
        We cannot identify timestamps freely in the meta-interpretation
        because we want to be able to use axioms such as
        $\forall i\neq j.~ a[i] \neq a[j]$ without restricting
        them to timestamps that really happen.
      });
    \item for each constant $a \in \Actions$ of index arity $k$,
      an interpretation $\hat{a} : D_\I^k \to D_\XT$;
    \item for each macro symbol $m \in \M$ of index
      arity $k$ and arity $n$, an interpretation
      $\hat{m} : D_\I^k \times \Msg_\Sigma^n \times D_XT \to \Msg^I_\Sigma$,
      where $\Msg^I_\Sigma$ is the set of terms of the base
      logic for the signature
      $(\F^I,\N^I)$ with
      $$ \F^I =
      \{ f_{e_1,\ldots,e_k} : f \in \F_k, e_1,\ldots,e_k \in D_I \}
      \text{ and }
      \N^I = \{ \mathsf{n}_{e_1,\ldots,e_k} : \mathsf{n}\in\N_k, 
      e_1,\ldots,e_k\in D_I \}.$$
  \end{itemize}
\end{definition}

Note that, for each name $\mathsf{n}\in \N$ and indices $n_1,\ldots,n_k \in 
D_\I$, $\mathsf{n}_{i_1,\ldots,i_k}$ refers to a distinct name in $\N^I$.

\begin{definition}
  Given a meta-interpretation $I$
  we define $(T)^{I} \in D_\XT$ and $(t)^{I} \in \Msg^I_\Sigma$ as follows:
  \begin{eqnarray*}
    (\tau)^{I} &=& \sigma_\XT(\tau) \\
    (\pre(T))^{I} &=& p((T)^{I}) \\
    (a[i_1,\ldots,i_k])^{I} &=& \hat{a}(\sigma_\I(i_1),\ldots,\sigma_\I(i_k))
  \end{eqnarray*}
  \begin{eqnarray*}
    (\mathsf{n}[i_1,\ldots,i_k])^{I} &=& \mathsf{n}_{\sigma_\I(i_1),\ldots,\sigma_\I(i_k)}
    \\
    (x)^{I} &=& x
    \\
    (f[i_1,\ldots,i_k](t_1,\ldots,t_n))^{I} &=&
    f_{\sigma_\I(i_1),\ldots,\sigma_\I(i_k)}\bigl(
      (t_1)^{I},\ldots,(t_n)^{I}
    \bigr)
    \\
    (m[i_1,\ldots,i_k](t_1,\ldots,t_n)@T)^{I} &=&
    \hat{m}(\sigma_\I(i_1),\ldots,\sigma_\I(i_k),
      (t_1)^{I},\ldots,(t_n)^{I},
      (T)^{I})
  \end{eqnarray*}
\end{definition}

\begin{example}
  Consider the meta-logic term $t := \mathsf{h}(\mout@a[i],\mathsf{k}[i])$
  and an interpretation $I$ with $D_T = [1;10]$ and $D_I = [1;3]$
  (which might be relevant if we are considering traces of ten actions
  with three agents) such that $\sigma_I(i)=2$ and $\hat{a}(2)=10$
  and $\hat{\mout}(10)=\mathsf{ok}$ (the message outputted at step 10
  is $\mathsf{ok}$).
  We then have $(t)^I = \mathsf{h}(\mathsf{ok},\mathsf{k}_2)$.
\end{example}

The reason why macros take only one timestamp argument is purely practical:
we have no use for more. At this point one might wonder why we separate 
indices and actions given that they are interpreted similarly: it is again
purely practical, we will use them for different purposes, and we will need
less structure on indices than on actions, making reasoning easier on them
(one can simply compare indices, there is no ordering and no predecessor
operation on them).

\subsection{Formulas}

The syntax of the meta-logic formulas is given in \cref{fig:syntax}.
We could have included more generally a notion of predicate macro that
would have to be expanded when translating a formula from the meta-logic
to the base logic. Instead we opted to list the few atoms that we
will use in practice.

\begin{figure}
  \[
  \begin{array}{c}
   \begin{array}{rcll}
    \T &  := & \timestamp \mid \idx & \text{(meta logic sorts)} \\
    \\[2ex]
   \atom & := & t=t'
 & \text{atomic proposition over messages } \\
  &\mid & T=T' \mid T \leq T' \mid \happens(T) &  \text{atomic proposition
  over timestamps } \\
  &\mid & i=i'  &  \text{atomic proposition
    over indices } \\
    \end{array}
\\
\\
     \begin{array}{rcll}
    \phi & ::= &  \true \mid \false \mid \phi \wedge \phi' \mid  \phi
    \vee \phi' \mid   \phi \Rightarrow \phi'\mid \neg \phi \mid
    \forall x : \T.\ \phi \mid \exists x:\T.\ \phi \mid \atom &
    \end{array}

\end{array}
    \]
    \caption{Syntax of first order formulas.}\label{fig:syntax}
\end{figure}

\begin{definition}
  If $I$ is a meta-interpretation and $e\in D_\I$,
  $I[i\mapsto e]$ is the interpretation where $\sigma_\I$ is
  modified so that $\sigma_{\I}(i)=e$.
  We define the translation of a meta-logic formula $\phi$
  into the base logic \emph{term} $(\phi)^I$
  as follows:
  \begin{eqnarray*}
    (\phi\wedge\phi')^I &=& (\phi)^I \stackrel{.}{\wedge} (\phi')^I
    \quad \text{and similarly for other boolean connectives} \\
    (\forall i:\idx. \phi)^I &=&
    \stackrel{.}{\wedge}_{e\in D_\I} (\phi)^{I[i\mapsto e]} \\
    (\forall \tau:\timestamp. \phi)^I &=&
    \stackrel{.}{\wedge}_{e\in D_\XT} (\phi)^{I[\tau\mapsto e]} \\
    (\exists i:\idx. \phi)^I &=&
    \stackrel{.}{\vee}_{e\in D_\I} (\phi)^{I[i\mapsto e]} \\
    (\exists \tau:\timestamp. \phi)^I &=&
    \stackrel{.}{\vee}_{e\in D_\XT} (\phi)^{I[\tau\mapsto e]} \\
    (i=i')^I &=&
    \left\{\begin{array}{ll}
      \mathsf{true} & \text{if } \sigma_\I(i)=\sigma_\I(i') \\
      \mathsf{false} & \text{otherwise}
    \end{array}\right. \\
    (T = T')^I &=&
    \left\{\begin{array}{ll}
      \mathsf{true} & \text{if } (T)^I = (T')^I \\
      \mathsf{false} & \text{otherwise}
    \end{array}\right.
    \quad\text{ and similarly for $\leq$} \\
    (\happens(T))^I &=& \mathsf{true}
    \text{ if } (T)^I \in H_\XT
    \text{ and } \mathsf{false} \text{ otherwise}
    \\
    (t=t')^I &=& (t)^I = (t')^I
  \end{eqnarray*}
\end{definition}

\begin{definition}
  A formula $\phi$ of the meta-logic is said to be valid when,
  for any meta-interpretation $I$, the base logic formula
  $(\phi)^I \sim \mathsf{true}$ is valid.
  (In other words, we have $\M,\sigma\models(\phi)^I\sim\mathsf{true}$
  i.e. the boolean term $(\phi)^I$ is true with overwhelming
  probability in any computational model $\M$ and for any interpretation
  $\sigma$ of the free message variables\footnote{
    In the tool, we only allow universal quantification over messages, and
  only allow it at toplevel. The validity of such formulas is the same as
  when the variables are left free.}.)
\end{definition}

The above definition can be adapted in a standard way to obtain the
notion of logical consequence: we say that a meta-logic formula $\phi$ is a
logical consequence of a set $S$ of meta-logic formulas when
$\M\models(\phi)^I\sim\mathsf{true}$ holds for any $\M$ and $I$ such that
$\M\models(\psi)^I\sim\mathsf{true}$ holds for all $\psi\in S$.

This allows to ask the really interesting question for us:
we want to verify that a formula $\phi$ (the security property)
holds for all executions of some protocol, in all computational models
satisfying some cryptographic assumptions.
This can be formulated as the logical consequence $Ax_m,Ax_p\models\phi$
where $Ax_m$ and $Ax_p$ are two recursive sets of (meta-logic) axioms
respectively restricting the class of models and of meta-interpretations
that we want to consider.

More concretely, we will manipulate sequents $\Gamma \vdash \phi$
(which should be read as the meta-logic formula
$(\wedge\Gamma) \Rightarrow \phi$) and attempt to derive them using
a set of inference rules that is sound wrt.\ the intended class
of models and of protocol executions.

\section{Protocols and trace logic}

\subsection{Protocols definitions}
We  model protocols as a set of possible actions available to the
attacker. An action essentially models a step of the protocol, where
the attacker provides some inputs, some conditions are checked, some
updates are performed, and finally an output is performed.

Some actions may be available to the attacker in parallel, or one
after the other. A protocol will then be a tree, each node labelled by an action, a parallel operator or a choice operator.

\begin{definition}
An action $s(\ov{id})$ is a tuple $(\phi,U,o)$, where $\ov{id} \in I^k$ is a list of indices variable, $\phi$ is a propositional formula over ground terms (called the condition of $s$), $U$ is a set of states updates (a mapping from state symbols to terms), and $o$ is a list of ground terms.
All indices appearing in $\phi,U,o$ must appear in $I$.

Given a set of actions $\Actions$, a protocol $P$ is a term built over the signature $\{\|/2,\oplus/2\} \cup \{a/1 \mid a \in \Actions\}$, such that when going down inside the protocol, the indices set of the actions can only grow. We denote $\Actions(P)$ the set of actions appearing inside $P$. We denote $\suc^*(a)$ all the descendants of a node (including itself), $\pre(a)$ the predecessor (ancestor) of $a$ inside $P$ and $\bro(a)$ its brother, which are defined only if they exists.
\end{definition}.

We may denote an acrion $s(\ov{id})$ to give explicitely its set of indexes.
For concision, we will denote protocols using $;,\|,\oplus$. For instance, $s_1; (s_2 \| s_3(id))$ represents the protocol where the attacker can first execute $s_1$, and can then execute in any order $s_2$, and an arbitrary number of occurences of $s_3(id)$.

There exists a natural translation from applied pi-calculus to this notion of actions, reminescent of the translation inside Horn Clauses performed by Proverif, or the translation inside Multi Set Rewritting rules performed by Sapic (a Tamarin extension).

\subsection{Symbolic protocol execution}

Protocols can be executed according to the odering constraints on protocol steps defined by the protocol tree.
Each action depending on indices may be instantiated an arbitrary number of time using distinct indices. The protocol defines how the protocol steps may be executed. For instance, if some protocol step appears in
the trace with some defined indices, all its ancestors must have been executed previously in the trace.


\begin{definition}
  Given a protocol $P$, a symbolic trace of of $P$ is given, for any $n\in\mathbb{N}$, by a sequence of actions $a_0 (\ov{id}_0),\dots,a_n (\ov{id}_n)$, such that for all $1 \leq i,j \leq n$,
  \begin{itemize}
    \item each action is an instantiation of a protocol action and indices are uniformly instantiated, i.e, there exists $\sigma : \I \mapsto \I$, such that $a_i (\sigma (\ov{id})) \in\Actions(P)$,
    \item each action occurs only once, i.e, $a_i \neq{} a_j$ or $\ov{id}_i \neq\ov{id}_j$,
    \item if an action must happen before another one, it is reflected in the trace, i.e
      if $\pre (a_i(\sigma(\ov{id}_i)) \in \Actions(P)$, then there exists $k$ such that $\pre(a) = a_k(\sigma(\ov{id}_k))$,
    \item if the protocol enforces a choice between two actions, then it is respected in the trace, i.e if $\pre(a_i(\sigma(\ov{id}_i))) = \oplus$, then $a_j(\sigma(\ov{id}_j)) \notin \suc^*(\bro (a_i(\sigma(\ov{id}_i))))$,
      \item the actions only depends on previous actions, i.e, for any $\mout@a$ (resp. $\minp@a$) which appears in the terms of $a_i(\ov{id}_i)$, then there exists $k < i$ (resp. $k \leq i$) such that $a = a_k(\ov{id}_k)$.
      \end{itemize}
\end{definition}
Intuitively, a symbolic trace represent a possible scheduling of the protocol, when abstracting all the inputs. Some symbolic trace may not correspond to any actual execution of the protocol, if for instance an action require a condition which is never met.

Notice that the number of symbolic traces is infinite as soon as there exists an accessible action with a non nil set of indices.


\subsection{Concrete protocol execution}
As in the \BC model, we models arbitrary messages produced by the attacker using free function symbols $\G = \{g_i | i \in \mathbb{N}\} $, and extend the definition of a computational model $\M$ so that it contains Turing Machines for each attacker symbol.

Given a symbolic trace of the protocol, we can define the substitution which maps inputs, outputs and states to terms using the attacker function symbols, with the required attacker knowledge at each step.

\begin{definition}
  Given a symbolic trace $A = a_0,\dots,a_n$ of $P$, we define inductively $\sigma$ the instantiation of the inputs and ouputs of $A$ such that:
  \begin{itemize}
  \item $\minp@a_i\sigma := g_i( \mout@a_0\sigma,\dots,\mout@a_{i-1}\sigma  ) $
  \item $\mout@a_i\sigma := o_0\sigma, \dots, o_k\sigma$, where $o_0,\dots,o_k$ is the set of ouputs of  $a_i$,
    \item $s@a_i := u\sigma$, where $s$ is a state and $s \mapsto u$ is the latest update corresponding to $s$ appearing inside the actions before $a_i$.
\end{itemize}
\end{definition}
Note that $\sigma$ can indeed be defined, as by definition of a symbolic traces, the outputs of the action $a_i$ only depends on input values of previous actions.

\begin{definition}
  A (concrete) trace of $P$ is given by a symbolic trace $A = a_0,\dots,a_n$ of $P$ along with a computational model $\M$, such that with $\sigma$ the instantiation of $A$, we have that $A,\I,\M,\sigma \models \bigwedge_{1\leq i \leq n} \phi_i$, where $\phi_i$ is the condition of $a_i$.

  We denote $\tr(P)$ the set of traces of $P$.
\end{definition}

A trace of $P$ then corresponds to an actual possible evaluation of $P$. More strongly, $\tr(P)$ represents the set of all possible executions of the protocol $P$ for all possible probabilistic polynomial time attackers.

\subsection{Semantics of formulas for protocols}

\begin{definition}
  Let $\phi$ be a formula and $(A=(a_0,\dots,a_n),\M)$ a trace of $P$. If we denote $I(A,\phi)$ the set of indices appearing in $A$ extended with fresh indices for each quantification over indices in $\phi$ , and $\sigma$ the instantiation of $A$,

we say that $P$ satisfies $\phi$, denoted $P \models \phi$, if for all $(A,\M)$ in $\tr(P)$, $A, I(A,\phi), \M, \sigma \models \phi$.

\end{definition}

This semantics does match the intuition: for all possible executions of the protocol and for any

security parameter, the execution satisfies the formula.

$I(A,\phi)$ must depend both on the formula and the trace, so that the formula $\exists i:\idx, i=i$ is true, even when considering the empty protocol.


\section{The MetaBC-logic}

Now that the semantics of the formula are defined given a specific protocol, we can define a logic allowing to prove such formulas. We will reason using classical sequent calculs, extended with some axioms obtained form the constraints based on the protocol, or computational axioms made about the primitives. We will use implicitely the axioms about equality.

Given a protocol $P$, we define a set of path constraints axioms $C_P$ with the formulas:
\begin{itemize}
\item for any action $a(id_1,\dots,id_n) \in \Actions(P)$, when $a'(id_1,\dots,id_k) = \pre (a(i_1,\dots,i_n))$,
  \[\forall i_1, \dots, i_n:\idx, \tau:\timestamp, a(i_1,\dots,i_n)@\tau \Rightarrow \exists \tau', \tau'< \tau \wedge a'(i_1,\dots,i_k)@\tau' \qquad (i) \]
\item for any action $a(id_1,\dots,id_n) \in \Actions(P)$ such that $\pre (a(id_1,\dots,id_n)) =
  \oplus$, for any $a'(id_1,\dots,id_k,id'_1,\dots, id'_l) \in \suc^*( \bro (a(id_1,\dots,id_n)))$,
  \[\forall i_1, \dots, i_n, i'_1,\dots, i'_l:\idx, \tau,\tau':\timestamp, a(i_1,\dots,i_n)@\tau \wedge a'(id_1,\dots,id_k,id'_1,\dots, id'_l)@\tau' \Rightarrow \false   \qquad (ii) \]
\item for any action $a(id_1,\dots,id_n) \in \Actions(P)$,
  \[\forall i_1, \dots, i_n, :\idx, \tau:\timestamp, a(i_1,\dots,i_n)@\tau \wedge a(id_1,\dots,id_n)@\tau' \Rightarrow \tau=\tau'  \qquad (iii)\]
\item for any action $a(id_1,\dots,id_n) \in \Actions(P)$ with output term $o(id_1,\dots,id_n)$ and condition $\phi(id_1,\dots,id_n)$,
  \[\forall i_1, \dots, i_n, :\idx, \tau,\tau':\timestamp, a(i_1,\dots,i_n)@\tau \Rightarrow \mout@\tau = o(i_1,\dots,i_n) \wedge \phi(id_1,\dots,id_n)   \qquad (iv)\]
\end{itemize}

We have that $ P\models C_P$ by definitions of the traces of $P$.Intuitively $(i)$ captures the fact that an action can only happen if the previous actions in the protocol have happened before, $(ii)$ captures the fact that the protocol sometimes enforce a choice between two actions and both cannot then be in a trace, $(iii)$ captures the uniqueness of an action, and $(iv)$ simply enforces the equality given by an action.

\charlie{need to define the axiom for the states, but I'm lazy right now}


We also consider a set of computational sounds axioms $A_P$, which is based on classical axioms from the \BC model, which may contain EQ-INDEP, EUF-CMA, PRF, \dots.

Finally, given a protocol $P$, we obtain a set of axioms $C_P$, and we may choose a set of computationaly sound axioms $A_P$.
Then, we can prove statements of the form $ P \models \phi$, by reasoning using the rules of the sequence calculs, and proving that $A_P,C_P \vdash \phi$.

\subsection{The tool}

We develop a tool allowing to performs proofs as outlined before. It implements tactics that are either basic rules of the sequent calculus, or more complex deductions based on some specifix computational axiom.







\newpage
\section{Old stuff}



\paragraph{Facts}
Facts are schemas of $\bc$ formulas indexed by path constraints:
\[
  \phi \mdef
  \cforall_\theta\, \valpha.\;
  \psi
  \ra
  \bigvee_{i}
  \cexists_\gammai \vbetai. \psi_i
\]

\paragraph{Environments}
\[
  \env \mdef
  \aset \mid
  \pcnstr \mid
  \decls
  \qquad
  \text{ where }
  \qquad
  \decls \mdef
  \left\{
    \decl{t_\sfx}
    {t_\epsilon,(t_\sfy^\act)_{\act \in \aset}}
  \right\}
\]
where:
\begin{itemize}
\item $\aset$ is the set of symbolic actions.
\item $\pcnstr$ is a set of path constraints.
\item $\decls$ is a set of inductive term declarations.
\end{itemize}
\paragraph{Judgments}
\[
  \ejudge{\env}{\facts{\valpha}{\theta}{\Gamma}}{\phi}
\]
where:
\begin{itemize}
\item $\env$ is the environment.
\item $\pvtype{\valpha}{\theta}$ declares a set of constrained path variables.
\item $\Gamma$ is a set of facts.
\item $\phi$ is the goal.
\end{itemize}

\begin{remark}
  $\env$ will be invariant during derivations. We omit it when there is no ambiguity.
\end{remark}

\paragraph{Standard Introduction Rules}
\begin{mathpar}
  \inferrule[\rraintro]{
    \judge{\facts{\valpha}{\theta}{
        \Gamma \cup \{\psi_0\}}}
    {
      \cexists_\gammap \vdelta. \psi
    }
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}
    {
      \psi_0
      \ra
      \cexists_\gammap \vdelta. \psi
    }
  }

  \inferrule[\andlintro]{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \} \cup \{\psi'\}}}
    {\phi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \wedge \psi'\}}}
    {\phi}
  }

  \inferrule[\orlintro]{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \}}}
    {\phi}\\
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{\psi'\}}}
    {\phi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \vee \psi'\}}}
    {\phi}
  }

  \inferrule[\andrintro]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi}\\
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi'}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi \wedge \psi'}
  }

  \inferrule[\orrintro-1]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi \vee \psi'}
  }

  \inferrule[\orrintro-2]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi'}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi \vee \psi'}
  }

  \inferrule[\toprintro]{
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\top}
  }
\end{mathpar}

\paragraph{Other Rules}
\begin{mathpar}
  \inferrule[\absurd]{
    \bot \in \Gamma
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\axiom]{
    \psi \in \Gamma
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi}
  }

\end{mathpar}

\paragraph{Modal Introduction Rules}
\begin{mathpar}
  \inferrule[\grintro]{
    \judge{\facts{\valpha,\vbeta}{\theta\wedge\gamma}{\Gamma}}
    { \phi }\\
    \valpha \cap \vbeta = \emptyset
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}
    {
      \cforall_\gamma\, \vbeta.\;
      \phi
    }
  }

  \inferrule[\printro]{
    \nu : \vbeta \mapsto \valpha\\
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi\nu}\\
    \centail{\theta}{\gamma\nu}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\gamma \vbeta. \psi}
  }
\end{mathpar}

\paragraph{Path Constraints Rules}
\begin{mathpar}
  \inferrule[\clweaken]{
    \judge
    {\facts{\valpha}{\gamma}{\Gamma}}{\phi}\\
    \centail{\theta}{\gamma}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\crstrengthen]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\delta \vbeta. \phi}\\
    \centail{\delta}{\gamma}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\gamma \vbeta. \phi}
  }

  \inferrule[\cempty]{
    \centail{\theta}{\bot}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{
      \phi
    }
  }

  \inferrule[\cdisj]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}\\
    \judge{\facts{\valpha}{\gamma}{\Gamma}}{\phi}
  }{
    \judge{\facts{\valpha}{\theta \vee \gamma}{\Gamma}}{\phi}
  }
\end{mathpar}

\paragraph{Rules}
\begin{mathpar}
  \inferrule[\defunroll{t_\tau}]{
    \decl{t_\sfx}
    {t_\epsilon,(t_\sfy^\act)_{\act \in \aset}} \in \decls\\
    \tau \in \valpha\\
    \tauo \not \in \valpha\\\\
    \judge
    {\facts{\valpha}
      {\theta\wedge\tau = \epsilon}
      {\Gamma \wedge t_\tau = t_\epsilon}}
    {\phi}\\
    \left(
      \judge
      {\facts{\valpha,\tauo}
        {\theta\wedge\tauo = \tpred{\tau}\wedge \tauo = \act}
        {\Gamma \wedge t_\tau = t_\tauo^\act}}
      {\phi}
    \right)_{\act \in \aset}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\requ]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi[s]}\\
    \judge{\facts{\valpha}
      {\theta}{\Gamma}}
    {s = t}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{
      \psi[t]
    }
  }

  \inferrule[\papply]{
    \cexists_\gamma \vbeta. \psi
    \in \Gamma\\
    \valpha \cap \vbeta = \emptyset\\
    \judge{\facts{\valpha, \vbeta}{\theta \wedge \gamma}
      {\Gamma \cup \{\psi\}}}{\phi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\apply]{
    (\cforall_\gamma\, \vbeta.\;
    \psi
    \ra
    \phi_0)
    \in \Gamma\\
    \nu : \vbeta \mapsto \valpha\\
    \centail{\theta}{\gamma\nu}\\
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi\nu}\\
    \judge{\facts{\valpha}{\theta}
      {\Gamma \cup \{\phi_0\nu\}}}{\phi}
  }{\judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}}

  \inferrule[\induc]{
    \phi' \equiv
    \cforall_{\gammao} \tauo.\phi\\
    \gammao \equiv
    \subst{\gamma}{\tau}{\tauo}\wedge\tauo < \tau\\
    \tau,\tauo \not \in \valpha\\
    \judge
    {\facts{\valpha,\tau}{\theta\wedge\gamma}{\Gamma\cup\{\phi'\}}}
    {\phi}
  }{
    \judge
    {\facts{\valpha}{\theta}{\Gamma}}
    {\cforall_\gamma \tau.\phi}
  }
\end{mathpar}

\paragraph{Superpositions of $\clweaken$ or $\crstrengthen$ with other rules}
\begin{itemize}
\item $\mrule{\clweaken}$ with $\mrule{\printro}$:
  \[
    \inferrule[\printrogen]{
      \nu : \vbeta \mapsto \valpha\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}{\Gamma}}{\psi\nu}\\
      \judge{\facts{\valpha}{\theta \wedge \neg(\gamma\nu)}{\Gamma}}{\bot}
    }{
      \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\gamma \vbeta. \psi}
    }
  \]

\item $\mrule{\crstrengthen}$ with $\mrule{\apply}$ and $\mrule{\absurd}$:
  \[
    \inferrule[\botapply]{
      (
      \cforall_\gamma\, \vbeta.\;
      \psi
      \ra
      \bot
      ) \in \Gamma\\
      \nu : \vbeta \mapsto \valpha\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}{\Gamma}}{\psi\nu}\\
      \judge{\facts{\valpha}{\theta \wedge \neg(\gamma\nu)}{\Gamma}}{\phi}
    }{\judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}}
  \]

\item $\mrule{\crstrengthen}$ with $\mrule{\apply}$ (general case):
  \[
    \inferrule[\botapply]{
      (
      \cforall_\gamma\, \vbeta.\;
      \psi
      \ra
      \phio
      ) \in \Gamma\\
      \nu : \vbeta \mapsto \valpha\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}{\Gamma}}{\psi\nu}\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}
        {\Gamma \cup \{ \phio\nu\}}}
      {\phi}\\
      \judge{\facts{\valpha}{\theta \wedge \neg(\gamma\nu)}{\Gamma}}{\phi}
    }{\judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}}
  \]

\end{itemize}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
