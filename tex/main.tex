\documentclass[a4paper]{article}

\usepackage{lipsum}
\usepackage[normalem]{ulem}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{framed}
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{xspace}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{cite}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage[margin=2cm]{geometry}
\usepackage{multicol}

\usepackage{url}
\usepackage{tikz}
\usepackage{proof}
\usepackage{hyperref}
\usepackage[capitalize,nameinlink,noabbrev]{cleveref}
\usepackage{enumerate}

\setlength{\ULdepth}{0.15em}

\usetikzlibrary{backgrounds}
\usetikzlibrary{intersections}
\usetikzlibrary{scopes}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing,shapes}
\usetikzlibrary{backgrounds}
\usetikzlibrary{shapes.misc}

\newtheorem{assumption}{Assumption}
\newtheorem*{theorem*}{Theorem}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{proposition*}{Proposition}



\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}

\theoremstyle{remark}
\newtheorem{remark}{Remark}

\newcommand{\todo}[1]{\textcolor{red}{(\textbf{TD:} #1)}}
\newcommand{\toadd}[1]{\textcolor{blue}{(\textbf{TA:} #1)}}

\newcommand{\charlie}[1]{\textcolor{cyan}{(\textbf{Charlie:} #1)}}

\input{macros.tex}

\begin{document}
\title{Meta-Logic for BC}


\author{David Baelde, Adrien Koutsos}

\maketitle


We first define a first order logic which allows to reason about abstract sequence of possible actions. We will then use this logic to reason about protocols, where sequences of actions will correspond to traces of a protocol. According to this aim, the terms used to model message will contain function symbols and macros allowing to symbollicaly model the inputs and outputs performed by the protocol at some point in the trace, or symbol allowing to model states. Indices will be used to instantiate multiple instances of the same term.
\section{A Logic for abstract sequence of actions}

\subsection{Syntax of the logic}
We denote $\F$ a set of function symbols (used to model encryptions,
pairs,\dots). $\N$ denotes an
infinite set of names (used to model the randomness used in a
protocol), and $\I$ denotes an infinite set of indexes (used to talk
about multiple copies of the same agent). For
each name $n\in \N$ and sequence of indices $\ov{id} \in \I$,
$n(\ov{id})$ refers to a fresh unique name in $\N$. We denotes $\X$ an
infinite set of identifiers, used for variables.

We finally denote $\States$ a set of identifiers used to model
mutable
states, which can also be parametrized by sequences of indices, and
$\Actions$ a set of identifiers used to model actions
(which
will be used
to model an atomic step of a protocol).

If we are given a sequence of unique actions, it defines what we call a timestamp, which is essentially an action and its position inside the sequence. Timestamps are then comlpetely ordered, and it is possible to consider the successor or the predecessor of an action. Terms and indices are not ordered.

The syntax of the Meta-BC logic is given in \cref{fig:syntax}.

\begin{figure}
\[
\begin{array}[t]{ccc}
    \begin{array}{rcl}
    f \in \F & & \text{function symbol}\\
    id \in \I  & & \text{index}\\

    x \in \X & & \text{variable}\\
    \end{array}
&     \begin{array}{rcll}
\tau &:=& a \in \Actions & \text{action} \\
& \mid & \suc(\tau) & \text{action} \\
\end{array}
   &
    \begin{array}{rcll}

    n &:=& n \in \N & \text{name}\\
    &\mid& n(id_1,\dots,id_n) & \text{name copy} \\
    \\

    s&:=& s \in \States & \text{state}\\
    &\mid& s(id_1,\dots,id_n) & \text{state copy}\\

    \end{array}
\end{array}
\]

\[
  \begin{array}{c}
     \begin{array}{rcll}
    \T &  := & \timestamp \mid \idx & \text{
        type of trace variables} \\
    \T' &  := & \mess \mid \bool & \text{
        type of term variables} \\

      \\

    t & := & n &\text{a name } \\
           & \mid & s@\tau &\text{value of a state}\\
    & \mid & x  & \text{a variable} \\
    & \mid & \mout@\tau & \text{value of some output} \\
    & \mid & \minp@\tau & \text{value of some input} \\
    & \mid & f(t_1,\dots,t_n) &\text{function application}\\
       \end{array}
\\
\\
   \begin{array}{rcll}
   \atom & := & t=t'
 & \text{atomic proposition over terms } \\
  &\mid & \tau=\tau' \mid \tau \leq \tau' \mid \happens(\tau) &  \text{atomic proposition
  over timestamps } \\
  &\mid & i=i'  &  \text{atomic proposition
    over index } \\
    \end{array}
\\
\\
     \begin{array}{rcll}
    \phi & ::= &  \true \mid \false \mid \phi \wedge \phi' \mid  \phi
    \vee \phi' \mid   \phi \Rightarrow \phi'\mid \neg \phi \mid
    \forall x : \T.\ \phi \mid \exists x:\T.\ \phi \mid \atom &
\\
    \psi & ::= &  \phi \mid \forall x : \T'. \phi \mid \exists x : \T'. \phi &
    \text{
    first order formula} \\
    \end{array}

\end{array}
    \]
    \caption{Syntax of first order formulas.}\label{fig:syntax}
\end{figure}


Terms $t$ may represent messages of a protocol, where given a trace,
i.e a sequence of actions, $\mout@\tau$ and
$\minp@\tau$ models the output and input of the protocol at this
point in the trace. We will only consider well typed formulas, i.e
formulas where all variables (which are typed) are used accordingly
to there type (e.g, $s@x$ is ill-typed if $x$ is of type $\mess$).

\subsection{Semantics}

We will execute protocols according to the \BC model. This means that any message will be interpreted as a Polynomial Time Turing Machine which given infinite random tapes and a security parameter outputs a bitstring. We denote $D$ the set of such Turing Machines, which we call messages.

\charlie{insert here definition of a computational model $\M$ according to BC, which yelds an interpretation of terms $\sem{\dots}_\M^\eta$. Only honnest function symbols need to be interpreted for the moment.}


\charlie{define here the \BC logic, which allows to test if $\M,\sigma \models_\BC \phi \sim \true$}

Our goal is to interpret formulas inside the \BC logic, to capture the fact that the formula holds with overwhelming probability for a given sequence of actions. However, we must take care of the quantifications over the indices and the timestamps. The main idea is that given an explicit sequence of actions, the set of possible timestamps becomes fixed, and we can capture a forall using a conjonction over all the timestamps of the sequence. If we fix the set of indices, we can do the same transformation. Remark that the quantifications over the messages do not need to be transformed, as they can be handled inside the \BC logic. However, they must only appear at top level, else it is difficult to provide a precise semantics modelling the expected behaviour.

\begin{definition}
  Let $\M$ be a computational model, $A = a_1,\dots, a_n$  a sequence of actions, $\I$ a finite set of indices, and $\phi$ a first order formula such that all its terms are built over indices in $\I$,
  We define inductively a transformation of the formulas $\phi^{\I,\A}$ as :
  \begin{itemize}
 \item $ (\forall x:\idx.\ \phi) ^{\I,A} :=  \bigwedge_{i\in \I} (\phi\replace{x}{i})^{\I,A}$
 \item $ (\forall x:\timestamp.\ \phi)^{\I,A} := \bigwedge_{1 \leq i \leq n} (\phi\replace{x}{a_i})^{\I,A}$

  \end{itemize}
We propagate the transformation over all other quantifications and logical connectors homorphically.
\end{definition}

Once this transformation is performed over formulas, they can be naturally interpreted inside the BC model, if we consider in the computational model that timestamps form a completely ordered set and that the index set form a finite set of identifiers equipped with equality.

\begin{definition}
Let $\M$ be a computational model, $A = a_1,\dots, a_n$  a sequence of actions and $\I$ a finite set of indices. We denote $\M_{\I,A}$ the computational model $\M$ extended with the interpretation of $\I$ as a finite set of identifiers equipped with equality and the intepretation of $\{a_i | 1 \leq i \leq n\}$ as a finite set, ordered such that $a_i \leq a_j \Leftrightarrow i\leq j$.
\end{definition}


We also need to interpret inside the \BC model the free variables and the inputs and outputs functions symbols. Given $\sigma$ a mapping from $\X \cup \{\mout@a \mid a \in \Actions \} \cup \{\minp@a \mid a \in \Actions \} \mapsto D$, we can consider the evaluation of terms inside a formula as $\sem{t\sigma}_\M^\eta$. Essentialy, this means that if we are given a valuation of the free variables and of the outputs and inputs symbols for each action, we can evaluate all the terms appearing in the formula. Given a protocol, we will later on interpret the outputs and the inputs with the corresponding valus.


\begin{definition}
Let $\M$ be a computational model, $A = a_1,\dots, a_n$  a sequence of actions, $\I$ a finite set of indices, $\sigma$ an evaluation of messages for all actions in $A$, and $\phi$ a first order formula such that all its terms are built over indices in $\I$ and variables bounds by $\sigma$.


  We denote $A,\I,\M,\sigma \models \phi$ the fact that $A,\I,\M,\sigma$ satisfies $\phi$, defined by
  \begin{itemize}
  \item $A,\I,\M,\sigma \models \forall x_1,\dots,x_n : \mess.\ \phi $ if $\M_{\I,A}, \sigma \models_\BC \forall x_1,\dots,x_n : \mess. \phi^{\I,A} \sim \true$,
  \end{itemize}
\end{definition}



\section{Protocols and trace logic}


\subsection{Protocols definitions}
We  model protocols as a set of possible actions available to the
attacker. An action essentially models a step of the protocol, where
the attacker provides some inputs, some conditions are checked, some
updates are performed, and finally an output is performed.

Some actions may be available to the attacker in parallel, or one
after the other. A protocol will then be a tree, each node labelled by an action, a parallel operator or a choice operator.

\begin{definition}
An action $s(\ov{id})$ is a tuple $(\phi,U,o)$, where $\ov{id} \in I^k$ is a list of indices variable, $\phi$ is a propositional formula over ground terms (called the condition of $s$), $U$ is a set of states updates (a mapping from state symbols to terms), and $o$ is a list of ground terms.
All indices appearing in $\phi,U,o$ must appear in $I$.

Given a set of actions $\Actions$, a protocol $P$ is a term built over the signature $\{\|/2,\oplus/2\} \cup \{a/1 \mid a \in \Actions\}$, such that when going down inside the protocol, the indices set of the actions can only grow. We denote $\Actions(P)$ the set of actions appearing inside $P$. We denote $\suc^*(a)$ all the descendants of a node (including itself), $\pre(a)$ the predecessor (ancestor) of $a$ inside $P$ and $\bro(a)$ its brother, which are defined only if they exists.
\end{definition}.

We may denote an acrion $s(\ov{id})$ to give explicitely its set of indexes.
For concision, we will denote protocols using $;,\|,\oplus$. For instance, $s_1; (s_2 \| s_3(id))$ represents the protocol where the attacker can first execute $s_1$, and can then execute in any order $s_2$, and an arbitrary number of occurences of $s_3(id)$.

There exists a natural translation from applied pi-calculus to this notion of actions, reminescent of the translation inside Horn Clauses performed by Proverif, or the translation inside Multi Set Rewritting rules performed by Sapic (a Tamarin extension).

\subsection{Symbolic protocol execution}

Protocols can be executed according to the odering constraints on protocol steps defined by the protocol tree.
Each action depending on indices may be instantiated an arbitrary number of time using distinct indices. The protocol defines how the protocol steps may be executed. For instance, if some protocol step appears in
the trace with some defined indices, all its ancestors must have been executed previously in the trace.


\begin{definition}
  Given a protocol $P$, a symbolic trace of of $P$ is given, for any $n\in\mathbb{N}$, by a sequence of actions $a_0 (\ov{id}_0),\dots,a_n (\ov{id}_n)$, such that for all $1 \leq i,j \leq n$,
  \begin{itemize}
    \item each action is an instantiation of a protocol action and indices are uniformly instantiated, i.e, there exists $\sigma : \I \mapsto \I$, such that $a_i (\sigma (\ov{id})) \in\Actions(P)$,
    \item each action occurs only once, i.e, $a_i \neq{} a_j$ or $\ov{id}_i \neq\ov{id}_j$,
    \item if an action must happen before another one, it is reflected in the trace, i.e
      if $\pre (a_i(\sigma(\ov{id}_i)) \in \Actions(P)$, then there exists $k$ such that $\pre(a) = a_k(\sigma(\ov{id}_k))$,
    \item if the protocol enforces a choice between two actions, then it is respected in the trace, i.e if $\pre(a_i(\sigma(\ov{id}_i))) = \oplus$, then $a_j(\sigma(\ov{id}_j)) \notin \suc^*(\bro (a_i(\sigma(\ov{id}_i))))$,
      \item the actions only depends on previous actions, i.e, for any $\mout@a$ (resp. $\minp@a$) which appears in the terms of $a_i(\ov{id}_i)$, then there exists $k < i$ (resp. $k \leq i$) such that $a = a_k(\ov{id}_k)$.
      \end{itemize}
\end{definition}
Intuitively, a symbolic trace represent a possible scheduling of the protocol, when abstracting all the inputs. Some symbolic trace may not correspond to any actual execution of the protocol, if for instance an action require a condition which is never met.

Notice that the number of symbolic traces is infinite as soon as there exists an accessible action with a non nil set of indices.


\subsection{Concrete protocol execution}
As in the \BC model, we models arbitrary messages produced by the attacker using free function symbols $\G = \{g_i | i \in \mathbb{N}\} $, and extend the definition of a computational model $\M$ so that it contains Turing Machines for each attacker symbol.

Given a symbolic trace of the protocol, we can define the substitution which maps inputs, outputs and states to terms using the attacker function symbols, with the required attacker knowledge at each step.

\begin{definition}
  Given a symbolic trace $A = a_0,\dots,a_n$ of $P$, we define inductively $\sigma$ the instantiation of the inputs and ouputs of $A$ such that:
  \begin{itemize}
  \item $\minp@a_i\sigma := g_i( \mout@a_0\sigma,\dots,\mout@a_{i-1}\sigma  ) $
  \item $\mout@a_i\sigma := o_0\sigma, \dots, o_k\sigma$, where $o_0,\dots,o_k$ is the set of ouputs of  $a_i$,
    \item $s@a_i := u\sigma$, where $s$ is a state and $s \mapsto u$ is the latest update corresponding to $s$ appearing inside the actions before $a_i$.
\end{itemize}
\end{definition}
Note that $\sigma$ can indeed be defined, as by definition of a symbolic traces, the outputs of the action $a_i$ only depends on input values of previous actions.

\begin{definition}
  A (concrete) trace of $P$ is given by a symbolic trace $A = a_0,\dots,a_n$ of $P$ along with a computational model $\M$, such that with $\sigma$ the instantiation of $A$, we have that $A,\I,\M,\sigma \models \bigwedge_{1\leq i \leq n} \phi_i$, where $\phi_i$ is the condition of $a_i$.

  We denote $\tr(P)$ the set of traces of $P$.
\end{definition}

A trace of $P$ then corresponds to an actual possible evaluation of $P$. More strongly, $\tr(P)$ represents the set of all possible executions of the protocol $P$ for all possible probabilistic polynomial time attackers.

\subsection{Semantics of formulas for protocols}

\begin{definition}
  Let $\phi$ be a formula and $(A=(a_0,\dots,a_n),\M)$ a trace of $P$. If we denote $I(A,\phi)$ the set of indices appearing in $A$ extended with fresh indices for each quantification over indices in $\phi$ , and $\sigma$ the instantiation of $A$,

we say that $P$ satisfies $\phi$, denoted $P \models \phi$, if for all $(A,\M)$ in $\tr(P)$, $A, I(A,\phi), \M, \sigma \models \phi$.

\end{definition}

This semantics does match the intuition: for all possible executions of the protocol and for any

security parameter, the execution satisfies the formula.

$I(A,\phi)$ must depend both on the formula and the trace, so that the formula $\exists i:\idx, i=i$ is true, even when considering the empty protocol.


\section{The MetaBC-logic}

Now that the semantics of the formula are defined given a specific protocol, we can define a logic allowing to prove such formulas. We will reason using classical sequent calculs, extended with some axioms obtained form the constraints based on the protocol, or computational axioms made about the primitives. We will use implicitely the axioms about equality.

Given a protocol $P$, we define a set of path constraints axioms $C_P$ with the formulas:
\begin{itemize}
\item for any action $a(id_1,\dots,id_n) \in \Actions(P)$, when $a'(id_1,\dots,id_k) = \pre (a(i_1,\dots,i_n))$,
  \[\forall i_1, \dots, i_n:\idx, \tau:\timestamp, a(i_1,\dots,i_n)@\tau \Rightarrow \exists \tau', \tau'< \tau \wedge a'(i_1,\dots,i_k)@\tau' \qquad (i) \]
\item for any action $a(id_1,\dots,id_n) \in \Actions(P)$ such that $\pre (a(id_1,\dots,id_n)) =
  \oplus$, for any $a'(id_1,\dots,id_k,id'_1,\dots, id'_l) \in \suc^*( \bro (a(id_1,\dots,id_n)))$,
  \[\forall i_1, \dots, i_n, i'_1,\dots, i'_l:\idx, \tau,\tau':\timestamp, a(i_1,\dots,i_n)@\tau \wedge a'(id_1,\dots,id_k,id'_1,\dots, id'_l)@\tau' \Rightarrow \false   \qquad (ii) \]
\item for any action $a(id_1,\dots,id_n) \in \Actions(P)$,
  \[\forall i_1, \dots, i_n, :\idx, \tau:\timestamp, a(i_1,\dots,i_n)@\tau \wedge a(id_1,\dots,id_n)@\tau' \Rightarrow \tau=\tau'  \qquad (iii)\]
\item for any action $a(id_1,\dots,id_n) \in \Actions(P)$ with output term $o(id_1,\dots,id_n)$ and condition $\phi(id_1,\dots,id_n)$,
  \[\forall i_1, \dots, i_n, :\idx, \tau,\tau':\timestamp, a(i_1,\dots,i_n)@\tau \Rightarrow \mout@\tau = o(i_1,\dots,i_n) \wedge \phi(id_1,\dots,id_n)   \qquad (iv)\]
\end{itemize}

We have that $ P\models C_P$ by definitions of the traces of $P$.Intuitively $(i)$ captures the fact that an action can only happen if the previous actions in the protocol have happened before, $(ii)$ captures the fact that the protocol sometimes enforce a choice between two actions and both cannot then be in a trace, $(iii)$ captures the uniqueness of an action, and $(iv)$ simply enforces the equality given by an action.

\charlie{need to define the axiom for the states, but I'm lazy right now}


We also consider a set of computational sounds axioms $A_P$, which is based on classical axioms from the \BC model, which may contain EQ-INDEP, EUF-CMA, PRF, \dots.

Finally, given a protocol $P$, we obtain a set of axioms $C_P$, and we may choose a set of computationaly sound axioms $A_P$.
Then, we can prove statements of the form $ P \models \phi$, by reasoning using the rules of the sequence calculs, and proving that $A_P,C_P \vdash \phi$.

\subsection{The tool}

We develop a tool allowing to performs proofs as outlined before. It implements tactics that are either basic rules of the sequent calculus, or more complex deductions based on some specifix computational axiom.







\newpage
\section{Old stuff}



\paragraph{Facts}
Facts are schemas of $\bc$ formulas indexed by path constraints:
\[
  \phi \mdef
  \cforall_\theta\, \valpha.\;
  \psi
  \ra
  \bigvee_{i}
  \cexists_\gammai \vbetai. \psi_i
\]

\paragraph{Environments}
\[
  \env \mdef
  \aset \mid
  \pcnstr \mid
  \decls
  \qquad
  \text{ where }
  \qquad
  \decls \mdef
  \left\{
    \decl{t_\sfx}
    {t_\epsilon,(t_\sfy^\act)_{\act \in \aset}}
  \right\}
\]
where:
\begin{itemize}
\item $\aset$ is the set of symbolic actions.
\item $\pcnstr$ is a set of path constraints.
\item $\decls$ is a set of inductive term declarations.
\end{itemize}
\paragraph{Judgments}
\[
  \ejudge{\env}{\facts{\valpha}{\theta}{\Gamma}}{\phi}
\]
where:
\begin{itemize}
\item $\env$ is the environment.
\item $\pvtype{\valpha}{\theta}$ declares a set of constrained path variables.
\item $\Gamma$ is a set of facts.
\item $\phi$ is the goal.
\end{itemize}

\begin{remark}
  $\env$ will be invariant during derivations. We omit it when there is no ambiguity.
\end{remark}

\paragraph{Standard Introduction Rules}
\begin{mathpar}
  \inferrule[\rraintro]{
    \judge{\facts{\valpha}{\theta}{
        \Gamma \cup \{\psi_0\}}}
    {
      \cexists_\gammap \vdelta. \psi
    }
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}
    {
      \psi_0
      \ra
      \cexists_\gammap \vdelta. \psi
    }
  }

  \inferrule[\andlintro]{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \} \cup \{\psi'\}}}
    {\phi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \wedge \psi'\}}}
    {\phi}
  }

  \inferrule[\orlintro]{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \}}}
    {\phi}\\
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{\psi'\}}}
    {\phi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \vee \psi'\}}}
    {\phi}
  }

  \inferrule[\andrintro]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi}\\
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi'}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi \wedge \psi'}
  }

  \inferrule[\orrintro-1]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi \vee \psi'}
  }

  \inferrule[\orrintro-2]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi'}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi \vee \psi'}
  }

  \inferrule[\toprintro]{
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\top}
  }
\end{mathpar}

\paragraph{Other Rules}
\begin{mathpar}
  \inferrule[\absurd]{
    \bot \in \Gamma
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\axiom]{
    \psi \in \Gamma
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi}
  }

\end{mathpar}

\paragraph{Modal Introduction Rules}
\begin{mathpar}
  \inferrule[\grintro]{
    \judge{\facts{\valpha,\vbeta}{\theta\wedge\gamma}{\Gamma}}
    { \phi }\\
    \valpha \cap \vbeta = \emptyset
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}
    {
      \cforall_\gamma\, \vbeta.\;
      \phi
    }
  }

  \inferrule[\printro]{
    \nu : \vbeta \mapsto \valpha\\
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi\nu}\\
    \centail{\theta}{\gamma\nu}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\gamma \vbeta. \psi}
  }
\end{mathpar}

\paragraph{Path Constraints Rules}
\begin{mathpar}
  \inferrule[\clweaken]{
    \judge
    {\facts{\valpha}{\gamma}{\Gamma}}{\phi}\\
    \centail{\theta}{\gamma}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\crstrengthen]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\delta \vbeta. \phi}\\
    \centail{\delta}{\gamma}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\gamma \vbeta. \phi}
  }

  \inferrule[\cempty]{
    \centail{\theta}{\bot}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{
      \phi
    }
  }

  \inferrule[\cdisj]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}\\
    \judge{\facts{\valpha}{\gamma}{\Gamma}}{\phi}
  }{
    \judge{\facts{\valpha}{\theta \vee \gamma}{\Gamma}}{\phi}
  }
\end{mathpar}

\paragraph{Rules}
\begin{mathpar}
  \inferrule[\defunroll{t_\tau}]{
    \decl{t_\sfx}
    {t_\epsilon,(t_\sfy^\act)_{\act \in \aset}} \in \decls\\
    \tau \in \valpha\\
    \tauo \not \in \valpha\\\\
    \judge
    {\facts{\valpha}
      {\theta\wedge\tau = \epsilon}
      {\Gamma \wedge t_\tau = t_\epsilon}}
    {\phi}\\
    \left(
      \judge
      {\facts{\valpha,\tauo}
        {\theta\wedge\tauo = \tpred{\tau}\wedge \tauo = \act}
        {\Gamma \wedge t_\tau = t_\tauo^\act}}
      {\phi}
    \right)_{\act \in \aset}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\requ]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi[s]}\\
    \judge{\facts{\valpha}
      {\theta}{\Gamma}}
    {s = t}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{
      \psi[t]
    }
  }

  \inferrule[\papply]{
    \cexists_\gamma \vbeta. \psi
    \in \Gamma\\
    \valpha \cap \vbeta = \emptyset\\
    \judge{\facts{\valpha, \vbeta}{\theta \wedge \gamma}
      {\Gamma \cup \{\psi\}}}{\phi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\apply]{
    (\cforall_\gamma\, \vbeta.\;
    \psi
    \ra
    \phi_0)
    \in \Gamma\\
    \nu : \vbeta \mapsto \valpha\\
    \centail{\theta}{\gamma\nu}\\
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi\nu}\\
    \judge{\facts{\valpha}{\theta}
      {\Gamma \cup \{\phi_0\nu\}}}{\phi}
  }{\judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}}

  \inferrule[\induc]{
    \phi' \equiv
    \cforall_{\gammao} \tauo.\phi\\
    \gammao \equiv
    \subst{\gamma}{\tau}{\tauo}\wedge\tauo < \tau\\
    \tau,\tauo \not \in \valpha\\
    \judge
    {\facts{\valpha,\tau}{\theta\wedge\gamma}{\Gamma\cup\{\phi'\}}}
    {\phi}
  }{
    \judge
    {\facts{\valpha}{\theta}{\Gamma}}
    {\cforall_\gamma \tau.\phi}
  }
\end{mathpar}

\paragraph{Superpositions of $\clweaken$ or $\crstrengthen$ with other rules}
\begin{itemize}
\item $\mrule{\clweaken}$ with $\mrule{\printro}$:
  \[
    \inferrule[\printrogen]{
      \nu : \vbeta \mapsto \valpha\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}{\Gamma}}{\psi\nu}\\
      \judge{\facts{\valpha}{\theta \wedge \neg(\gamma\nu)}{\Gamma}}{\bot}
    }{
      \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\gamma \vbeta. \psi}
    }
  \]

\item $\mrule{\crstrengthen}$ with $\mrule{\apply}$ and $\mrule{\absurd}$:
  \[
    \inferrule[\botapply]{
      (
      \cforall_\gamma\, \vbeta.\;
      \psi
      \ra
      \bot
      ) \in \Gamma\\
      \nu : \vbeta \mapsto \valpha\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}{\Gamma}}{\psi\nu}\\
      \judge{\facts{\valpha}{\theta \wedge \neg(\gamma\nu)}{\Gamma}}{\phi}
    }{\judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}}
  \]

\item $\mrule{\crstrengthen}$ with $\mrule{\apply}$ (general case):
  \[
    \inferrule[\botapply]{
      (
      \cforall_\gamma\, \vbeta.\;
      \psi
      \ra
      \phio
      ) \in \Gamma\\
      \nu : \vbeta \mapsto \valpha\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}{\Gamma}}{\psi\nu}\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}
        {\Gamma \cup \{ \phio\nu\}}}
      {\phi}\\
      \judge{\facts{\valpha}{\theta \wedge \neg(\gamma\nu)}{\Gamma}}{\phi}
    }{\judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}}
  \]

\end{itemize}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
