\documentclass[a4paper]{article}

\usepackage{lipsum}
\usepackage[normalem]{ulem}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{framed}
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{xspace}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{cite}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage[margin=2cm]{geometry}
\usepackage{multicol}

\usepackage{url}
\usepackage{tikz}
\usepackage{proof}
\usepackage{hyperref}
\usepackage[capitalize,nameinlink,noabbrev]{cleveref}
\usepackage{enumerate}

\setlength{\ULdepth}{0.15em}

\usetikzlibrary{backgrounds}
\usetikzlibrary{intersections}
\usetikzlibrary{scopes}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing,shapes}
\usetikzlibrary{backgrounds}
\usetikzlibrary{shapes.misc}

\newtheorem{assumption}{Assumption}
\newtheorem*{theorem*}{Theorem}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{proposition*}{Proposition}



\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}

\theoremstyle{remark}
\newtheorem{remark}{Remark}

\newcommand{\todo}[1]{\textcolor{red}{(\textbf{TD:} #1)}}
\newcommand{\toadd}[1]{\textcolor{blue}{(\textbf{TA:} #1)}}

\newcommand{\charlie}[1]{\textcolor{cyan}{(\textbf{Charlie:} #1)}}

\input{macros.tex}

\begin{document}
\title{Meta-Logic for BC}

\author{David Baelde, Stéphanie Delaune,
  Charlie Jacomme, Adrien Koutsos, Solène Moreau}

\maketitle

Bana and Comon have introduced an approach, which they call
\emph{computationally complete symbolic attacker} (CCSA),
to formulate security properties in the computational model as a first-order
logic formulas. Roughly, the translate a security property (for a finite set
of traces) as a first-order formula, then they seek to show that this formula
is valid in all \emph{computational models} where attacker computations
are unspecified and primitives satisfy some cryptographic assumptions. They
way this is done is by showing that the formula is a logical consequence of
some axioms, which are sound wrt.\ the considered class of computational 
models.

We introduce here a \emph{meta-logic} whose formulas correspond to schemas
of formulas in the \emph{base logic}
--- which we might call the CCSA or BC logic.
We present inference rules which are sound in the same way as before,
i.e.\ any instance of the schema is a formula that is valid in all
computational models subject to the relevant cryptographic assumptions.

We define next the meta-logic which abstractly allows to reason about
executions of a protocol. The precise definition of protocols and their
semantics is not needed for that first step, and is defined only in a
second part.

\section{A Logic for abstract sequence of actions}

\subsection{The base logic}

The base logic is that of Bana and Comon (CCS'14). It is first-order logic
with a distinguished kind of constant for representing names (written
$\mathsf{n}$, $\mathsf{m}$, $\mathsf{k}$, etc.)
and featuring a single predicate noted $\sim$ (or rather, a family
of predicates $\sim_k$ of arity $2 k$ for all $k\in\mathbb{N}$).
The terms are all of the same sort: they are meant to represent messages.
\marginpar{
  The distinction between booleans and messages may be ignored
  for the theory?
}

In practice, the logic will be considered with function symbols for 
representing cryptographic primitives as well as attacker computations, and 
boolean constants and connectives.

The formulas of the base logic are intended to be interpreted in 
\emph{computational models}, where terms are interpreted as PPT Turing 
machines, $\sim$ is interpreted as indistinguishability,
names are independent random samplings,
and function symbols correspond to deterministic machines.
In particular, function symbols corresponding to cryptographic primitives
are interpreted as implementations of the primitives, subject to some
assumptions.

For example, if $\mathsf{n}$ and $\mathsf{m}$ are distinct names,
the (atomic) formulas $\mathsf{n}\sim\mathsf{m}$ and 
$\mathsf{n}\stackrel{.}{=}\mathsf{m}\sim\mathsf{false}$
are valid.

\subsection{Syntax of the meta-logic}

Terms of the meta-logic are of three possible sorts: index, timestamps
or message. Formulas of the meta-logic may feature predicates over each sort.
Given interpretation $I$ and $T$ of index and timestamp variables
into two finite sets, a formula $\phi$ of the meta-logic will be translated 
into a term $(\phi)^{I,T}$ of the base logic in which index and action terms, 
and predicates over them, will have disappeared. The validity of the 
meta-logic formula $\phi$ will be defined as the validity of the base logic
$(\phi)^{I,T}\sim\mathsf{true}$.

\medskip

We assume three infinite sets of variables:
$\X$ (whose elements are noted $x$, $y$, $z$) for message variables;
$\I$ (whose elements are noted $i$, $j$, $k$) for index variables;
$\XT$ (whose elements are noted $\tau$) for timestamp variables.

We assume a set $\F$ a set of indexed function symbols
(used to model encryptions, pairs,\dots).
Each of these symbols comes with an index arity as well as an unusual arity:
if $f\in\F$ has index arity $k$ and arity $n$,
then for all index variables $i_1,\ldots,i_k$ and terms $t_1,\ldots,t_n$,
$f[i_1,\ldots,i_k](t_1,\ldots,t_n)$ is a term.

We assume a set $\N$ of indexed names symbols,
(used to model the randomness used in a protocol)
and a sets of indexed constants $\Actions$
(used to model specific timestamps).
These indexed symbols only have an index arity: they
cannot be applied to terms.

We finally assume a set $\M$ of indexed macro symbols
equipped with an arity and index arity, like function symbols.
An indexed macro symbol will be applied to the specified number of
indices, variables, and also to a single timestamp.
We will typically assume macro symbols $\mout$ and $\minp$
(with index arity $0$) for representing messages inputted and outputted
at a particular point of an execution.

\begin{figure}
\[
\begin{array}[t]{ccc}
    \begin{array}{rcl}
    f \in \F & & \text{function symbol}\\
    M \in \M & & \text{macro symbol}\\
    \mathsf{n} \in \N & & \text{name symbol}
    \end{array}
    &
    \begin{array}{rcll}
      n &:=& \mathsf{n}[i_1,\ldots,i_n]
      \\
      F &:=& f[i_1,\ldots,i_k] & (f\in\F \text{ of index arity } $k$)
      \\
      M &:=& m[i_1,\ldots,i_k] & (m\in\M \text{ of index arity } $k$)
    \end{array}
\end{array}
\]
\[
  \begin{array}{rcll}
    T &:=& \tau & \text{timestamp variable} \\
      &\mid& a[i_1,\ldots,i_k] & \text{constant (for $a\in\mathbb{A}$)} \\
      &\mid & \pre(T) & \text{successor} \\
\end{array}
   \]
\[
     \begin{array}{rcll}

      \\

    t & := & n &\text{name} \\
    & \mid & x  & \text{message variable $x\in\X$} \\
    & \mid & F(t_1,\dots,t_n) &\text{function application}\\
    & \mid & M(t_1,\ldots,t_n)@T &\text{macro application}\\
       \end{array}
     \]
     \caption{Meta-logic terms}\label{fig:terms}
\end{figure}

\begin{definition}
  \cref{fig:terms} defines the syntax of terms
  of sort message (noted $t$) and timestamp (noted $T$).
  The only terms of sort index are index variables.
  Given (interpretations $\hat{a}$ and $\hat{m}$ for action
  constants are macro symbols and) a mapping\footnote{
    The choice of $\mathbb{N}$ is arbitrary.
    We could interpret indices and timestamps into different sets.
  } $I : \I\to\mathbb{N}$ and $A : \XT\to\mathbb{N}$
  we define $(T)^{I,A}$ and $(t)^{I,A}$ as follows:
  \begin{eqnarray*}
    (\tau)^{I,A} &=& A(\tau) \\
    (\pre(T))^{I,A} &=& (T)^{I,A}-1 \\
    (a[i_1,\ldots,i_k])^{I,A} &=& \hat{a}(I(i_1),\ldots,I(i_k))
  \end{eqnarray*}
  \begin{eqnarray*}
    (\mathsf{n}[i_1,\ldots,i_k])^{I,A} &=& \mathsf{n}_{I(i_1),\ldots,I(i_k)}
    \\
    (x)^{I,A} &=& x
    \\
    (f[i_1,\ldots,i_k](t_1,\ldots,t_n))^{I,A} &=&
    f_{I(i_1),\ldots,I(i_k)}\bigl(
      (t_1)^{I,A},\ldots,(t_n)^{I,A}
    \bigr)
    \\
    (m[i_1,\ldots,i_k](t_1,\ldots,t_n)@T)^{I,A} &=&
    \hat{m}(I(i_1),\ldots,I(i_k),
      (t_1)^{I,A},\ldots,(t_n)^{I,A})
  \end{eqnarray*}
\end{definition}

The reason why macros take only one timestamp argument is purely practical:
we have no use for more. At this point one might wonder why we separate 
indices and actions given that they are interpreted similarly: it is again
purely practical, we will use them for different purposes, and we will need
less structure on indices than on actions, making reasoning easier on them
(one can simply compare indices, there is no ordering and no predecessor
operation on them).

Note that, for each name $\mathsf{n}\in \N$ and integers $i_1,\ldots,i_k$,
$\mathsf{n}(i_1,\ldots,i_k)$ refers to a distinct name in the base logic.

Terms of the meta-logic extend the base terms in two ways.
First, the meta-logic features \emph{indexed} function symbols,
representing families of function symbols of the base logic.
For example, the indexed name $\mathsf{k}[i]$
(where $i$ is an index variable, on which we can quantify in the meta-logic)
may represent an infinity of distinct name constants $\mathsf{k}_n$
of the base logic for $n\in\mathbb{N}$.
Second, the meta-logic features \emph{macro} symbols, which get
expanded when translating to the base logic.
For example, the term $\mathsf{output}@a[i]$ may be expanded,
when $i$ is interpreted by $n$, to the message outputted by
action $a[n]$ of the protocol.


\emph{TODO reprendre: cela n'est qu'une intuition sur l'utilisation qu'on fera 
ensuite de la logique.}
If we are given a sequence of unique actions, it defines what we call a timestamp, which is essentially an action and its position inside the sequence. Timestamps are then comlpetely ordered, and it is possible to consider the successor or the predecessor of an action. Terms and indices are not ordered.

\subsection{Formulas}

The syntax of the Meta-BC logic is given in \cref{fig:syntax}.

\begin{figure}
  \[
  \begin{array}{c}
   \begin{array}{rcll}
    \T &  := & \timestamp \mid \idx & \text{(meta logic sorts)} \\
    \\[2ex]
   \atom & := & t=t'
 & \text{atomic proposition over terms } \\
  &\mid & \tau=\tau' \mid \tau \leq \tau' \mid \happens(\tau) &  \text{atomic proposition
  over timestamps } \\
  &\mid & i=i'  &  \text{atomic proposition
    over index } \\
    \end{array}
\\
\\
     \begin{array}{rcll}
    \phi & ::= &  \true \mid \false \mid \phi \wedge \phi' \mid  \phi
    \vee \phi' \mid   \phi \Rightarrow \phi'\mid \neg \phi \mid
    \forall x : \T.\ \phi \mid \exists x:\T.\ \phi \mid \atom &
    \end{array}

\end{array}
    \]
    \caption{Syntax of first order formulas.}\label{fig:syntax}
\end{figure}


Terms $t$ may represent messages of a protocol, where given a trace,
i.e a sequence of actions, $\mout@\tau$ and
$\minp@\tau$ models the output and input of the protocol at this
point in the trace. We will only consider well typed formulas, i.e
formulas where all variables (which are typed) are used accordingly
to there type (e.g, $s@x$ is ill-typed if $x$ is of type $\mess$).

\subsection{Semantics}

We will execute protocols according to the \BC model. This means that any message will be interpreted as a Polynomial Time Turing Machine which given infinite random tapes and a security parameter outputs a bitstring. We denote $D$ the set of such Turing Machines, which we call messages.

\charlie{insert here definition of a computational model $\M$ according to BC, which yelds an interpretation of terms $\sem{\dots}_\M^\eta$. Only honnest function symbols need to be interpreted for the moment.}


\charlie{define here the \BC logic, which allows to test if $\M,\sigma \models_\BC \phi \sim \true$}

Our goal is to interpret formulas inside the \BC logic, to capture the fact that the formula holds with overwhelming probability for a given sequence of actions. However, we must take care of the quantifications over the indices and the timestamps. The main idea is that given an explicit sequence of actions, the set of possible timestamps becomes fixed, and we can capture a forall using a conjonction over all the timestamps of the sequence. If we fix the set of indices, we can do the same transformation. Remark that the quantifications over the messages do not need to be transformed, as they can be handled inside the \BC logic. However, they must only appear at top level, else it is difficult to provide a precise semantics modelling the expected behaviour.

\begin{definition}
  Let $\M$ be a computational model, $A = a_1,\dots, a_n$  a sequence of actions, $\I$ a finite set of indices, and $\phi$ a first order formula such that all its terms are built over indices in $\I$,
  We define inductively a transformation of the formulas $\phi^{\I,\A}$ as :
  \begin{itemize}
 \item $ (\forall x:\idx.\ \phi) ^{\I,A} :=  \bigwedge_{i\in \I} (\phi\replace{x}{i})^{\I,A}$
 \item $ (\forall x:\timestamp.\ \phi)^{\I,A} := \bigwedge_{1 \leq i \leq n} (\phi\replace{x}{a_i})^{\I,A}$

  \end{itemize}
We propagate the transformation over all other quantifications and logical connectors homorphically.
\end{definition}

Once this transformation is performed over formulas, they can be naturally interpreted inside the BC model, if we consider in the computational model that timestamps form a completely ordered set and that the index set form a finite set of identifiers equipped with equality.

\begin{definition}
Let $\M$ be a computational model, $A = a_1,\dots, a_n$  a sequence of actions and $\I$ a finite set of indices. We denote $\M_{\I,A}$ the computational model $\M$ extended with the interpretation of $\I$ as a finite set of identifiers equipped with equality and the intepretation of $\{a_i | 1 \leq i \leq n\}$ as a finite set, ordered such that $a_i \leq a_j \Leftrightarrow i\leq j$.
\end{definition}


We also need to interpret inside the \BC model the free variables and the inputs and outputs functions symbols. Given $\sigma$ a mapping from $\X \cup \{\mout@a \mid a \in \Actions \} \cup \{\minp@a \mid a \in \Actions \} \mapsto D$, we can consider the evaluation of terms inside a formula as $\sem{t\sigma}_\M^\eta$. Essentialy, this means that if we are given a valuation of the free variables and of the outputs and inputs symbols for each action, we can evaluate all the terms appearing in the formula. Given a protocol, we will later on interpret the outputs and the inputs with the corresponding valus.


\begin{definition}
Let $\M$ be a computational model, $A = a_1,\dots, a_n$  a sequence of actions, $\I$ a finite set of indices, $\sigma$ an evaluation of messages for all actions in $A$, and $\phi$ a first order formula such that all its terms are built over indices in $\I$ and variables bounds by $\sigma$.


  We denote $A,\I,\M,\sigma \models \phi$ the fact that $A,\I,\M,\sigma$ satisfies $\phi$, defined by
  \begin{itemize}
  \item $A,\I,\M,\sigma \models \forall x_1,\dots,x_n : \mess.\ \phi $ if $\M_{\I,A}, \sigma \models_\BC \forall x_1,\dots,x_n : \mess. \phi^{\I,A} \sim \true$,
  \end{itemize}
\end{definition}



\section{Protocols and trace logic}


\subsection{Protocols definitions}
We  model protocols as a set of possible actions available to the
attacker. An action essentially models a step of the protocol, where
the attacker provides some inputs, some conditions are checked, some
updates are performed, and finally an output is performed.

Some actions may be available to the attacker in parallel, or one
after the other. A protocol will then be a tree, each node labelled by an action, a parallel operator or a choice operator.

\begin{definition}
An action $s(\ov{id})$ is a tuple $(\phi,U,o)$, where $\ov{id} \in I^k$ is a list of indices variable, $\phi$ is a propositional formula over ground terms (called the condition of $s$), $U$ is a set of states updates (a mapping from state symbols to terms), and $o$ is a list of ground terms.
All indices appearing in $\phi,U,o$ must appear in $I$.

Given a set of actions $\Actions$, a protocol $P$ is a term built over the signature $\{\|/2,\oplus/2\} \cup \{a/1 \mid a \in \Actions\}$, such that when going down inside the protocol, the indices set of the actions can only grow. We denote $\Actions(P)$ the set of actions appearing inside $P$. We denote $\suc^*(a)$ all the descendants of a node (including itself), $\pre(a)$ the predecessor (ancestor) of $a$ inside $P$ and $\bro(a)$ its brother, which are defined only if they exists.
\end{definition}.

We may denote an acrion $s(\ov{id})$ to give explicitely its set of indexes.
For concision, we will denote protocols using $;,\|,\oplus$. For instance, $s_1; (s_2 \| s_3(id))$ represents the protocol where the attacker can first execute $s_1$, and can then execute in any order $s_2$, and an arbitrary number of occurences of $s_3(id)$.

There exists a natural translation from applied pi-calculus to this notion of actions, reminescent of the translation inside Horn Clauses performed by Proverif, or the translation inside Multi Set Rewritting rules performed by Sapic (a Tamarin extension).

\subsection{Symbolic protocol execution}

Protocols can be executed according to the odering constraints on protocol steps defined by the protocol tree.
Each action depending on indices may be instantiated an arbitrary number of time using distinct indices. The protocol defines how the protocol steps may be executed. For instance, if some protocol step appears in
the trace with some defined indices, all its ancestors must have been executed previously in the trace.


\begin{definition}
  Given a protocol $P$, a symbolic trace of of $P$ is given, for any $n\in\mathbb{N}$, by a sequence of actions $a_0 (\ov{id}_0),\dots,a_n (\ov{id}_n)$, such that for all $1 \leq i,j \leq n$,
  \begin{itemize}
    \item each action is an instantiation of a protocol action and indices are uniformly instantiated, i.e, there exists $\sigma : \I \mapsto \I$, such that $a_i (\sigma (\ov{id})) \in\Actions(P)$,
    \item each action occurs only once, i.e, $a_i \neq{} a_j$ or $\ov{id}_i \neq\ov{id}_j$,
    \item if an action must happen before another one, it is reflected in the trace, i.e
      if $\pre (a_i(\sigma(\ov{id}_i)) \in \Actions(P)$, then there exists $k$ such that $\pre(a) = a_k(\sigma(\ov{id}_k))$,
    \item if the protocol enforces a choice between two actions, then it is respected in the trace, i.e if $\pre(a_i(\sigma(\ov{id}_i))) = \oplus$, then $a_j(\sigma(\ov{id}_j)) \notin \suc^*(\bro (a_i(\sigma(\ov{id}_i))))$,
      \item the actions only depends on previous actions, i.e, for any $\mout@a$ (resp. $\minp@a$) which appears in the terms of $a_i(\ov{id}_i)$, then there exists $k < i$ (resp. $k \leq i$) such that $a = a_k(\ov{id}_k)$.
      \end{itemize}
\end{definition}
Intuitively, a symbolic trace represent a possible scheduling of the protocol, when abstracting all the inputs. Some symbolic trace may not correspond to any actual execution of the protocol, if for instance an action require a condition which is never met.

Notice that the number of symbolic traces is infinite as soon as there exists an accessible action with a non nil set of indices.


\subsection{Concrete protocol execution}
As in the \BC model, we models arbitrary messages produced by the attacker using free function symbols $\G = \{g_i | i \in \mathbb{N}\} $, and extend the definition of a computational model $\M$ so that it contains Turing Machines for each attacker symbol.

Given a symbolic trace of the protocol, we can define the substitution which maps inputs, outputs and states to terms using the attacker function symbols, with the required attacker knowledge at each step.

\begin{definition}
  Given a symbolic trace $A = a_0,\dots,a_n$ of $P$, we define inductively $\sigma$ the instantiation of the inputs and ouputs of $A$ such that:
  \begin{itemize}
  \item $\minp@a_i\sigma := g_i( \mout@a_0\sigma,\dots,\mout@a_{i-1}\sigma  ) $
  \item $\mout@a_i\sigma := o_0\sigma, \dots, o_k\sigma$, where $o_0,\dots,o_k$ is the set of ouputs of  $a_i$,
    \item $s@a_i := u\sigma$, where $s$ is a state and $s \mapsto u$ is the latest update corresponding to $s$ appearing inside the actions before $a_i$.
\end{itemize}
\end{definition}
Note that $\sigma$ can indeed be defined, as by definition of a symbolic traces, the outputs of the action $a_i$ only depends on input values of previous actions.

\begin{definition}
  A (concrete) trace of $P$ is given by a symbolic trace $A = a_0,\dots,a_n$ of $P$ along with a computational model $\M$, such that with $\sigma$ the instantiation of $A$, we have that $A,\I,\M,\sigma \models \bigwedge_{1\leq i \leq n} \phi_i$, where $\phi_i$ is the condition of $a_i$.

  We denote $\tr(P)$ the set of traces of $P$.
\end{definition}

A trace of $P$ then corresponds to an actual possible evaluation of $P$. More strongly, $\tr(P)$ represents the set of all possible executions of the protocol $P$ for all possible probabilistic polynomial time attackers.

\subsection{Semantics of formulas for protocols}

\begin{definition}
  Let $\phi$ be a formula and $(A=(a_0,\dots,a_n),\M)$ a trace of $P$. If we denote $I(A,\phi)$ the set of indices appearing in $A$ extended with fresh indices for each quantification over indices in $\phi$ , and $\sigma$ the instantiation of $A$,

we say that $P$ satisfies $\phi$, denoted $P \models \phi$, if for all $(A,\M)$ in $\tr(P)$, $A, I(A,\phi), \M, \sigma \models \phi$.

\end{definition}

This semantics does match the intuition: for all possible executions of the protocol and for any

security parameter, the execution satisfies the formula.

$I(A,\phi)$ must depend both on the formula and the trace, so that the formula $\exists i:\idx, i=i$ is true, even when considering the empty protocol.


\section{The MetaBC-logic}

Now that the semantics of the formula are defined given a specific protocol, we can define a logic allowing to prove such formulas. We will reason using classical sequent calculs, extended with some axioms obtained form the constraints based on the protocol, or computational axioms made about the primitives. We will use implicitely the axioms about equality.

Given a protocol $P$, we define a set of path constraints axioms $C_P$ with the formulas:
\begin{itemize}
\item for any action $a(id_1,\dots,id_n) \in \Actions(P)$, when $a'(id_1,\dots,id_k) = \pre (a(i_1,\dots,i_n))$,
  \[\forall i_1, \dots, i_n:\idx, \tau:\timestamp, a(i_1,\dots,i_n)@\tau \Rightarrow \exists \tau', \tau'< \tau \wedge a'(i_1,\dots,i_k)@\tau' \qquad (i) \]
\item for any action $a(id_1,\dots,id_n) \in \Actions(P)$ such that $\pre (a(id_1,\dots,id_n)) =
  \oplus$, for any $a'(id_1,\dots,id_k,id'_1,\dots, id'_l) \in \suc^*( \bro (a(id_1,\dots,id_n)))$,
  \[\forall i_1, \dots, i_n, i'_1,\dots, i'_l:\idx, \tau,\tau':\timestamp, a(i_1,\dots,i_n)@\tau \wedge a'(id_1,\dots,id_k,id'_1,\dots, id'_l)@\tau' \Rightarrow \false   \qquad (ii) \]
\item for any action $a(id_1,\dots,id_n) \in \Actions(P)$,
  \[\forall i_1, \dots, i_n, :\idx, \tau:\timestamp, a(i_1,\dots,i_n)@\tau \wedge a(id_1,\dots,id_n)@\tau' \Rightarrow \tau=\tau'  \qquad (iii)\]
\item for any action $a(id_1,\dots,id_n) \in \Actions(P)$ with output term $o(id_1,\dots,id_n)$ and condition $\phi(id_1,\dots,id_n)$,
  \[\forall i_1, \dots, i_n, :\idx, \tau,\tau':\timestamp, a(i_1,\dots,i_n)@\tau \Rightarrow \mout@\tau = o(i_1,\dots,i_n) \wedge \phi(id_1,\dots,id_n)   \qquad (iv)\]
\end{itemize}

We have that $ P\models C_P$ by definitions of the traces of $P$.Intuitively $(i)$ captures the fact that an action can only happen if the previous actions in the protocol have happened before, $(ii)$ captures the fact that the protocol sometimes enforce a choice between two actions and both cannot then be in a trace, $(iii)$ captures the uniqueness of an action, and $(iv)$ simply enforces the equality given by an action.

\charlie{need to define the axiom for the states, but I'm lazy right now}


We also consider a set of computational sounds axioms $A_P$, which is based on classical axioms from the \BC model, which may contain EQ-INDEP, EUF-CMA, PRF, \dots.

Finally, given a protocol $P$, we obtain a set of axioms $C_P$, and we may choose a set of computationaly sound axioms $A_P$.
Then, we can prove statements of the form $ P \models \phi$, by reasoning using the rules of the sequence calculs, and proving that $A_P,C_P \vdash \phi$.

\subsection{The tool}

We develop a tool allowing to performs proofs as outlined before. It implements tactics that are either basic rules of the sequent calculus, or more complex deductions based on some specifix computational axiom.







\newpage
\section{Old stuff}



\paragraph{Facts}
Facts are schemas of $\bc$ formulas indexed by path constraints:
\[
  \phi \mdef
  \cforall_\theta\, \valpha.\;
  \psi
  \ra
  \bigvee_{i}
  \cexists_\gammai \vbetai. \psi_i
\]

\paragraph{Environments}
\[
  \env \mdef
  \aset \mid
  \pcnstr \mid
  \decls
  \qquad
  \text{ where }
  \qquad
  \decls \mdef
  \left\{
    \decl{t_\sfx}
    {t_\epsilon,(t_\sfy^\act)_{\act \in \aset}}
  \right\}
\]
where:
\begin{itemize}
\item $\aset$ is the set of symbolic actions.
\item $\pcnstr$ is a set of path constraints.
\item $\decls$ is a set of inductive term declarations.
\end{itemize}
\paragraph{Judgments}
\[
  \ejudge{\env}{\facts{\valpha}{\theta}{\Gamma}}{\phi}
\]
where:
\begin{itemize}
\item $\env$ is the environment.
\item $\pvtype{\valpha}{\theta}$ declares a set of constrained path variables.
\item $\Gamma$ is a set of facts.
\item $\phi$ is the goal.
\end{itemize}

\begin{remark}
  $\env$ will be invariant during derivations. We omit it when there is no ambiguity.
\end{remark}

\paragraph{Standard Introduction Rules}
\begin{mathpar}
  \inferrule[\rraintro]{
    \judge{\facts{\valpha}{\theta}{
        \Gamma \cup \{\psi_0\}}}
    {
      \cexists_\gammap \vdelta. \psi
    }
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}
    {
      \psi_0
      \ra
      \cexists_\gammap \vdelta. \psi
    }
  }

  \inferrule[\andlintro]{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \} \cup \{\psi'\}}}
    {\phi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \wedge \psi'\}}}
    {\phi}
  }

  \inferrule[\orlintro]{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \}}}
    {\phi}\\
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{\psi'\}}}
    {\phi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \vee \psi'\}}}
    {\phi}
  }

  \inferrule[\andrintro]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi}\\
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi'}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi \wedge \psi'}
  }

  \inferrule[\orrintro-1]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi \vee \psi'}
  }

  \inferrule[\orrintro-2]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi'}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi \vee \psi'}
  }

  \inferrule[\toprintro]{
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\top}
  }
\end{mathpar}

\paragraph{Other Rules}
\begin{mathpar}
  \inferrule[\absurd]{
    \bot \in \Gamma
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\axiom]{
    \psi \in \Gamma
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi}
  }

\end{mathpar}

\paragraph{Modal Introduction Rules}
\begin{mathpar}
  \inferrule[\grintro]{
    \judge{\facts{\valpha,\vbeta}{\theta\wedge\gamma}{\Gamma}}
    { \phi }\\
    \valpha \cap \vbeta = \emptyset
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}
    {
      \cforall_\gamma\, \vbeta.\;
      \phi
    }
  }

  \inferrule[\printro]{
    \nu : \vbeta \mapsto \valpha\\
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi\nu}\\
    \centail{\theta}{\gamma\nu}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\gamma \vbeta. \psi}
  }
\end{mathpar}

\paragraph{Path Constraints Rules}
\begin{mathpar}
  \inferrule[\clweaken]{
    \judge
    {\facts{\valpha}{\gamma}{\Gamma}}{\phi}\\
    \centail{\theta}{\gamma}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\crstrengthen]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\delta \vbeta. \phi}\\
    \centail{\delta}{\gamma}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\gamma \vbeta. \phi}
  }

  \inferrule[\cempty]{
    \centail{\theta}{\bot}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{
      \phi
    }
  }

  \inferrule[\cdisj]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}\\
    \judge{\facts{\valpha}{\gamma}{\Gamma}}{\phi}
  }{
    \judge{\facts{\valpha}{\theta \vee \gamma}{\Gamma}}{\phi}
  }
\end{mathpar}

\paragraph{Rules}
\begin{mathpar}
  \inferrule[\defunroll{t_\tau}]{
    \decl{t_\sfx}
    {t_\epsilon,(t_\sfy^\act)_{\act \in \aset}} \in \decls\\
    \tau \in \valpha\\
    \tauo \not \in \valpha\\\\
    \judge
    {\facts{\valpha}
      {\theta\wedge\tau = \epsilon}
      {\Gamma \wedge t_\tau = t_\epsilon}}
    {\phi}\\
    \left(
      \judge
      {\facts{\valpha,\tauo}
        {\theta\wedge\tauo = \tpred{\tau}\wedge \tauo = \act}
        {\Gamma \wedge t_\tau = t_\tauo^\act}}
      {\phi}
    \right)_{\act \in \aset}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\requ]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi[s]}\\
    \judge{\facts{\valpha}
      {\theta}{\Gamma}}
    {s = t}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{
      \psi[t]
    }
  }

  \inferrule[\papply]{
    \cexists_\gamma \vbeta. \psi
    \in \Gamma\\
    \valpha \cap \vbeta = \emptyset\\
    \judge{\facts{\valpha, \vbeta}{\theta \wedge \gamma}
      {\Gamma \cup \{\psi\}}}{\phi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\apply]{
    (\cforall_\gamma\, \vbeta.\;
    \psi
    \ra
    \phi_0)
    \in \Gamma\\
    \nu : \vbeta \mapsto \valpha\\
    \centail{\theta}{\gamma\nu}\\
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi\nu}\\
    \judge{\facts{\valpha}{\theta}
      {\Gamma \cup \{\phi_0\nu\}}}{\phi}
  }{\judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}}

  \inferrule[\induc]{
    \phi' \equiv
    \cforall_{\gammao} \tauo.\phi\\
    \gammao \equiv
    \subst{\gamma}{\tau}{\tauo}\wedge\tauo < \tau\\
    \tau,\tauo \not \in \valpha\\
    \judge
    {\facts{\valpha,\tau}{\theta\wedge\gamma}{\Gamma\cup\{\phi'\}}}
    {\phi}
  }{
    \judge
    {\facts{\valpha}{\theta}{\Gamma}}
    {\cforall_\gamma \tau.\phi}
  }
\end{mathpar}

\paragraph{Superpositions of $\clweaken$ or $\crstrengthen$ with other rules}
\begin{itemize}
\item $\mrule{\clweaken}$ with $\mrule{\printro}$:
  \[
    \inferrule[\printrogen]{
      \nu : \vbeta \mapsto \valpha\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}{\Gamma}}{\psi\nu}\\
      \judge{\facts{\valpha}{\theta \wedge \neg(\gamma\nu)}{\Gamma}}{\bot}
    }{
      \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\gamma \vbeta. \psi}
    }
  \]

\item $\mrule{\crstrengthen}$ with $\mrule{\apply}$ and $\mrule{\absurd}$:
  \[
    \inferrule[\botapply]{
      (
      \cforall_\gamma\, \vbeta.\;
      \psi
      \ra
      \bot
      ) \in \Gamma\\
      \nu : \vbeta \mapsto \valpha\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}{\Gamma}}{\psi\nu}\\
      \judge{\facts{\valpha}{\theta \wedge \neg(\gamma\nu)}{\Gamma}}{\phi}
    }{\judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}}
  \]

\item $\mrule{\crstrengthen}$ with $\mrule{\apply}$ (general case):
  \[
    \inferrule[\botapply]{
      (
      \cforall_\gamma\, \vbeta.\;
      \psi
      \ra
      \phio
      ) \in \Gamma\\
      \nu : \vbeta \mapsto \valpha\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}{\Gamma}}{\psi\nu}\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}
        {\Gamma \cup \{ \phio\nu\}}}
      {\phi}\\
      \judge{\facts{\valpha}{\theta \wedge \neg(\gamma\nu)}{\Gamma}}{\phi}
    }{\judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}}
  \]

\end{itemize}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
