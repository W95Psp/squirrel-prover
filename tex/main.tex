\documentclass[a4paper]{article}

\usepackage{lipsum}
\usepackage[normalem]{ulem}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{framed}
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{xspace}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{cite}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage[margin=3cm]{geometry}
\usepackage{multicol}

\usepackage{url}
\usepackage{tikz}
\usepackage{proof}
\usepackage{hyperref}
\usepackage[capitalize,nameinlink,noabbrev]{cleveref}
\usepackage{enumerate}

\setlength{\ULdepth}{0.15em}

\usetikzlibrary{backgrounds}
\usetikzlibrary{intersections}
\usetikzlibrary{scopes}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing,shapes}
\usetikzlibrary{backgrounds}
\usetikzlibrary{shapes.misc}

\newtheorem{assumption}{Assumption}
\newtheorem*{theorem*}{Theorem}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{proposition*}{Proposition}



\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{proposition}{Proposition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}

\theoremstyle{remark}
\newtheorem{remark}{Remark}

\newcommand{\adrien}[1]{\textcolor{blue}{(\textbf{Adrien:} #1)}}
\newcommand{\charlie}[1]{\textcolor{cyan}{(\textbf{Charlie:} #1)}}

\input{macros.tex}

\begin{document}
\title{Meta-Logic for BC}

\author{David Baelde, Stéphanie Delaune,
  Charlie Jacomme, Adrien Koutsos, Solène Moreau}

\maketitle

\vfill

\tableofcontents

\vfill

\newpage

Bana and Comon have introduced an approach, which they call
\emph{computationally complete symbolic attacker} (CCSA),
to formulate security properties in the computational model as first-order
logic formulas. Roughly, they translate a security property (for a finite set
of traces) as a first-order formula, then they seek to show that this formula
is valid in all \emph{computational models} where attacker computations
are unspecified and primitives satisfy some cryptographic assumptions. The
way this is done is by showing that the formula is a logical consequence of
some axioms, which are sound w.r.t.\ the considered class of computational
models.

We introduce here a \emph{meta-logic} whose formulas correspond to schemas
of formulas in the \emph{base logic}
--- which we might call the CCSA or BC logic.
We present inference rules which are sound in the same way as before,
i.e.\ any instance of the schema is a formula that is valid in all
computational models subject to the relevant cryptographic assumptions.

We define next the meta-logic which abstractly allows to reason about
executions of a protocol. The precise definition of protocols and their
semantics is not needed for that first step, and is defined only in a
second part.

\include{logic}

\include{protocols}

\section{Concrete meta-logic}

\emph{We are not defining a new logic, but identifying axioms (or inference
rules, which would be closer to the tool) that hold in all
meta-interpretations corresponding to protocol executions.}

Now that the semantics of formulas is defined given a specific protocol, we
can define a logic allowing to prove such formulas. We will reason using
classical sequent calculs, extended with some axioms obtained form the
constraints based on the protocol, or computational axioms made about the
primitives. We will use implicitely the axioms about equality.

Given a protocol $P$, we define a set of path constraints axioms $C_P$ with the formulas:
\begin{itemize}
\item for any action $a(id_1,\dots,id_n) \in \Actions(P)$, when $a'(id_1,\dots,id_k) = \pre (a(i_1,\dots,i_n))$,
  \[\forall i_1, \dots, i_n:\idx, \tau:\timestamp, a(i_1,\dots,i_n)@\tau \Rightarrow \exists \tau', \tau'< \tau \wedge a'(i_1,\dots,i_k)@\tau' \qquad (i) \]
\item for any action $a(id_1,\dots,id_n) \in \Actions(P)$ such that $\pre (a(id_1,\dots,id_n)) =
  \oplus$, for any $a'(id_1,\dots,id_k,id'_1,\dots, id'_l) \in \suc^*( \bro (a(id_1,\dots,id_n)))$,
  \[\forall i_1, \dots, i_n, i'_1,\dots, i'_l:\idx, \tau,\tau':\timestamp, a(i_1,\dots,i_n)@\tau \wedge a'(id_1,\dots,id_k,id'_1,\dots, id'_l)@\tau' \Rightarrow \false   \qquad (ii) \]
\item for any action $a(id_1,\dots,id_n) \in \Actions(P)$,
  \[\forall i_1, \dots, i_n, :\idx, \tau:\timestamp, a(i_1,\dots,i_n)@\tau \wedge a(id_1,\dots,id_n)@\tau' \Rightarrow \tau=\tau'  \qquad (iii)\]
\item for any action $a(id_1,\dots,id_n) \in \Actions(P)$ with output term $o(id_1,\dots,id_n)$ and condition $\phi(id_1,\dots,id_n)$,
  \[\forall i_1, \dots, i_n, :\idx, \tau,\tau':\timestamp, a(i_1,\dots,i_n)@\tau \Rightarrow \mout@\tau = o(i_1,\dots,i_n) \wedge \phi(id_1,\dots,id_n)   \qquad (iv)\]
\end{itemize}

We have that $ P\models C_P$ by definitions of the traces of $P$.Intuitively $(i)$ captures the fact that an action can only happen if the previous actions in the protocol have happened before, $(ii)$ captures the fact that the protocol sometimes enforce a choice between two actions and both cannot then be in a trace, $(iii)$ captures the uniqueness of an action, and $(iv)$ simply enforces the equality given by an action.

\charlie{need to define the axiom for the states, but I'm lazy right now}


We also consider a set of computational sounds axioms $A_P$, which is based on classical axioms from the \BC model, which may contain EQ-INDEP, EUF-CMA, PRF, \dots.

Finally, given a protocol $P$, we obtain a set of axioms $C_P$, and we may choose a set of computationaly sound axioms $A_P$.
Then, we can prove statements of the form $ P \models \phi$, by reasoning using the rules of the sequence calculs, and proving that $A_P,C_P \vdash \phi$.

\newpage

\section{Old stuff}



\paragraph{Facts}
Facts are schemas of $\bc$ formulas indexed by path constraints:
\[
  \phi \mdef
  \cforall_\theta\, \valpha.\;
  \psi
  \ra
  \bigvee_{i}
  \cexists_\gammai \vbetai. \psi_i
\]

\paragraph{Environments}
\[
  \env \mdef
  \aset \mid
  \pcnstr \mid
  \decls
  \qquad
  \text{ where }
  \qquad
  \decls \mdef
  \left\{
    \decl{t_\sfx}
    {t_\epsilon,(t_\sfy^\act)_{\act \in \aset}}
  \right\}
\]
where:
\begin{itemize}
\item $\aset$ is the set of symbolic actions.
\item $\pcnstr$ is a set of path constraints.
\item $\decls$ is a set of inductive term declarations.
\end{itemize}
\paragraph{Judgments}
\[
  \ejudge{\env}{\facts{\valpha}{\theta}{\Gamma}}{\phi}
\]
where:
\begin{itemize}
\item $\env$ is the environment.
\item $\pvtype{\valpha}{\theta}$ declares a set of constrained path variables.
\item $\Gamma$ is a set of facts.
\item $\phi$ is the goal.
\end{itemize}

\begin{remark}
  $\env$ will be invariant during derivations. We omit it when there is no ambiguity.
\end{remark}

\paragraph{Standard Introduction Rules}
\begin{mathpar}
  \inferrule[\rraintro]{
    \judge{\facts{\valpha}{\theta}{
        \Gamma \cup \{\psi_0\}}}
    {
      \cexists_\gammap \vdelta. \psi
    }
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}
    {
      \psi_0
      \ra
      \cexists_\gammap \vdelta. \psi
    }
  }

  \inferrule[\andlintro]{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \} \cup \{\psi'\}}}
    {\phi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \wedge \psi'\}}}
    {\phi}
  }

  \inferrule[\orlintro]{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \}}}
    {\phi}\\
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{\psi'\}}}
    {\phi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \vee \psi'\}}}
    {\phi}
  }

  \inferrule[\andrintro]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi}\\
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi'}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi \wedge \psi'}
  }

  \inferrule[\orrintro-1]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi \vee \psi'}
  }

  \inferrule[\orrintro-2]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi'}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi \vee \psi'}
  }

  \inferrule[\toprintro]{
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\top}
  }
\end{mathpar}

\paragraph{Other Rules}
\begin{mathpar}
  \inferrule[\absurd]{
    \bot \in \Gamma
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\axiom]{
    \psi \in \Gamma
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi}
  }

\end{mathpar}

\paragraph{Modal Introduction Rules}
\begin{mathpar}
  \inferrule[\grintro]{
    \judge{\facts{\valpha,\vbeta}{\theta\wedge\gamma}{\Gamma}}
    { \phi }\\
    \valpha \cap \vbeta = \emptyset
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}
    {
      \cforall_\gamma\, \vbeta.\;
      \phi
    }
  }

  \inferrule[\printro]{
    \nu : \vbeta \mapsto \valpha\\
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi\nu}\\
    \centail{\theta}{\gamma\nu}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\gamma \vbeta. \psi}
  }
\end{mathpar}

\paragraph{Path Constraints Rules}
\begin{mathpar}
  \inferrule[\clweaken]{
    \judge
    {\facts{\valpha}{\gamma}{\Gamma}}{\phi}\\
    \centail{\theta}{\gamma}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\crstrengthen]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\delta \vbeta. \phi}\\
    \centail{\delta}{\gamma}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\gamma \vbeta. \phi}
  }

  \inferrule[\cempty]{
    \centail{\theta}{\bot}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{
      \phi
    }
  }

  \inferrule[\cdisj]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}\\
    \judge{\facts{\valpha}{\gamma}{\Gamma}}{\phi}
  }{
    \judge{\facts{\valpha}{\theta \vee \gamma}{\Gamma}}{\phi}
  }
\end{mathpar}

\paragraph{Rules}
\begin{mathpar}
  \inferrule[\defunroll{t_\tau}]{
    \decl{t_\sfx}
    {t_\epsilon,(t_\sfy^\act)_{\act \in \aset}} \in \decls\\
    \tau \in \valpha\\
    \tauo \not \in \valpha\\\\
    \judge
    {\facts{\valpha}
      {\theta\wedge\tau = \epsilon}
      {\Gamma \wedge t_\tau = t_\epsilon}}
    {\phi}\\
    \left(
      \judge
      {\facts{\valpha,\tauo}
        {\theta\wedge\tauo = \tpred{\tau}\wedge \tauo = \act}
        {\Gamma \wedge t_\tau = t_\tauo^\act}}
      {\phi}
    \right)_{\act \in \aset}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\requ]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi[s]}\\
    \judge{\facts{\valpha}
      {\theta}{\Gamma}}
    {s = t}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{
      \psi[t]
    }
  }

  \inferrule[\papply]{
    \cexists_\gamma \vbeta. \psi
    \in \Gamma\\
    \valpha \cap \vbeta = \emptyset\\
    \judge{\facts{\valpha, \vbeta}{\theta \wedge \gamma}
      {\Gamma \cup \{\psi\}}}{\phi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\apply]{
    (\cforall_\gamma\, \vbeta.\;
    \psi
    \ra
    \phi_0)
    \in \Gamma\\
    \nu : \vbeta \mapsto \valpha\\
    \centail{\theta}{\gamma\nu}\\
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi\nu}\\
    \judge{\facts{\valpha}{\theta}
      {\Gamma \cup \{\phi_0\nu\}}}{\phi}
  }{\judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}}

  \inferrule[\induc]{
    \phi' \equiv
    \cforall_{\gammao} \tauo.\phi\\
    \gammao \equiv
    \subst{\gamma}{\tau}{\tauo}\wedge\tauo < \tau\\
    \tau,\tauo \not \in \valpha\\
    \judge
    {\facts{\valpha,\tau}{\theta\wedge\gamma}{\Gamma\cup\{\phi'\}}}
    {\phi}
  }{
    \judge
    {\facts{\valpha}{\theta}{\Gamma}}
    {\cforall_\gamma \tau.\phi}
  }
\end{mathpar}

\paragraph{Superpositions of $\clweaken$ or $\crstrengthen$ with other rules}
\begin{itemize}
\item $\mrule{\clweaken}$ with $\mrule{\printro}$:
  \[
    \inferrule[\printrogen]{
      \nu : \vbeta \mapsto \valpha\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}{\Gamma}}{\psi\nu}\\
      \judge{\facts{\valpha}{\theta \wedge \neg(\gamma\nu)}{\Gamma}}{\bot}
    }{
      \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\gamma \vbeta. \psi}
    }
  \]

\item $\mrule{\crstrengthen}$ with $\mrule{\apply}$ and $\mrule{\absurd}$:
  \[
    \inferrule[\botapply]{
      (
      \cforall_\gamma\, \vbeta.\;
      \psi
      \ra
      \bot
      ) \in \Gamma\\
      \nu : \vbeta \mapsto \valpha\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}{\Gamma}}{\psi\nu}\\
      \judge{\facts{\valpha}{\theta \wedge \neg(\gamma\nu)}{\Gamma}}{\phi}
    }{\judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}}
  \]

\item $\mrule{\crstrengthen}$ with $\mrule{\apply}$ (general case):
  \[
    \inferrule[\botapply]{
      (
      \cforall_\gamma\, \vbeta.\;
      \psi
      \ra
      \phio
      ) \in \Gamma\\
      \nu : \vbeta \mapsto \valpha\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}{\Gamma}}{\psi\nu}\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}
        {\Gamma \cup \{ \phio\nu\}}}
      {\phi}\\
      \judge{\facts{\valpha}{\theta \wedge \neg(\gamma\nu)}{\Gamma}}{\phi}
    }{\judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}}
  \]

\end{itemize}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
