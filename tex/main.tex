\documentclass[a4paper]{article}

\usepackage{lipsum}
\usepackage[normalem]{ulem}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{framed}
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{xspace}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{cite}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage[margin=2cm]{geometry}
\usepackage{multicol}

\usepackage{url}
\usepackage{tikz}
\usepackage{proof}
\usepackage{hyperref}
\usepackage[capitalize,nameinlink,noabbrev]{cleveref}
\usepackage{enumerate}

\setlength{\ULdepth}{0.15em}

\usetikzlibrary{backgrounds}
\usetikzlibrary{intersections}
\usetikzlibrary{scopes}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing,shapes}
\usetikzlibrary{backgrounds}
\usetikzlibrary{shapes.misc}

\newtheorem{assumption}{Assumption}
\newtheorem*{theorem*}{Theorem}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{proposition*}{Proposition}



\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}

\theoremstyle{remark}
\newtheorem{remark}{Remark}

\newcommand{\todo}[1]{\textcolor{red}{(\textbf{TD:} #1)}}
\newcommand{\toadd}[1]{\textcolor{blue}{(\textbf{TA:} #1)}}

\newcommand{\charlie}[1]{\textcolor{cyan}{(\textbf{Charlie:} #1)}}

\input{macros.tex}

\begin{document}
\title{Meta-Logic for BC}


\author{David Baelde, Adrien Koutsos}

\maketitle

\section{A Logic for protocols}

\subsection{Syntax of the logic}
We denote $\F$ a set of function symbols (used to model encryptions,
pairs,\dots). $\N$ denotes an
infinite set of names (used to model the randomness used in a
protocol), and $\I$ denotes an infinite set of indexes (used to talk
about multiple copies of the same agent). For
each name $n\in \N$ and sequence of indices $\ov{id} \in \I$,
$n(\ov{id})$ refers to a fresh unique name in $\N$. We denotes $\X$ an
infinite set of identifiers, used for variables.

We finally denote $\States$ a set of identifiers used to model
mutable
states, which can also be parametrized by sequences of indices,
$\Actions$ a set of identifiers used to model actions
(which
will be used
to model an atomic step of a protocol), and $\Timestamps$ a set of
identifiers for timestamps in a trace.

The syntax of the Meta-BC logic is then given in \cref{fig:syntax}.

\begin{figure}
\[
\begin{array}[t]{ccc}
    \begin{array}{rcl}
    f \in \F & & \text{function symbol}\\
    id \in \I  & & \text{index}\\

    x \in \X & & \text{variable}\\
    \end{array}
&     \begin{array}{rcll}
\tau &:=& \tau \in \Timestamps  & \text{timestamp}\\
& \mid & a \in \Actions & \text{action} \\
& \mid & \suc(\tau) & \text{action} \\
\end{array}
   &
    \begin{array}{rcll}

    n &:=& n \in \N & \text{name}\\
    &\mid& n(id_1,\dots,id_n) & \text{name copy} \\
    \\

    s&:=& s \in \States & \text{state}\\
    &\mid& s(id_1,\dots,id_n) & \text{state copy}\\

    \end{array}
\end{array}
\]

\[
  \begin{array}{c}
     \begin{array}{rcll}
    \T &  := & \mess \mid \timestamp \mid \idx \mid \bool & \text{
        type of variables} \\

      \\

    t & := & n &\text{a name } \\
           & \mid & s@\tau &\text{value of a state}\\
    & \mid & x  & \text{a variable} \\
    & \mid & \mout@\tau & \text{value of some output} \\
    & \mid & \minp@\tau & \text{value of some input} \\
    & \mid & f(t_1,\dots,t_n) &\text{function application}\\
       \end{array}
\\
\\
   \begin{array}{rcll}
   \atom & := & t=t'
 & \text{atomic proposition over terms } \\
  &\mid & \tau=\tau' \mid \tau \leq \tau' &  \text{atomic proposition
  over timestamps } \\
  &\mid & i=i'  &  \text{atomic proposition
    over index } \\
  &\mid & a= a'\mid  \happens(a)  &  \text{atomic proposition
    over actions } \\
    \end{array}
\\
\\
     \begin{array}{rcll}
    \phi & ::= &  \true \mid \false \mid \phi \wedge \phi' \mid  \phi
    \vee \phi' \mid   \phi \Rightarrow \phi'\mid \neg \phi \mid
    \forall x : \T.\ \phi \mid \exists x:\T.\ \phi \mid \atom &
    \text{
    first order formula} \\
    \end{array}

\end{array}
    \]
    \caption{Syntax of first order formulas.}\label{fig:syntax}
\end{figure}


Terms $t$ may represent messages of a protocol, where given a trace,
i.e a sequence of actions or timestamps, $\mout@\tau$ and
$\minp@\tau$ models the output and input of the protocol at this
point in the trace. We will only consider well typed formulas, i.e
formulas where all variables (which are typed) are used accordingly
to there type (e.g, $s@x$ is ill-typed if $x$ is of type $\mess$).




Timestamps are ordered, and it is possible to consider the successor
of a timestamp.  Terms and indices are not ordered.

\subsection{Semantic for propositional formulas}
We start by giving the semantic of formulas restricted to propositional formulas, i.e formulas without quantifiers. Intuitively, those are the formulas which can be used as conditions inside a protocol.

We will execute protocols according to the \BC model. This means that any message will be interpreted as a Polynomial Time Turing Machine which given infinite random tapes and a security parameter outputs a bitstring. We denote $D$ the set of such Turing Machines, which we call messages.

\charlie{insert here definition of a computational model $\M$ according to BC, which yelds an interpretation of terms $\sem{\dots}_\M^\eta$. Only honnest function symbols need to be interpreted for the moment.}

Given $\sigma$ a mapping from $\X \cup \{\mout@a \mid a \in \Actions \} \cup \{\minp@a \mid a \in \Actions \} \mapsto D$, we define the evaluation of terms inside a formula as $\sem{t}_\M^{\eta,\sigma} := \sem{t\sigma}_\M^\eta$.
\charlie{define here the \BC logic, which allows to test if $\sigma \models \EQ(t,t') \sim \true$}


\begin{definition}
  Given a computational model $\M$, a sequence of actions $A = a_1,\dots, a_n$, its ordered set of implied timestamp is $\{1,\dots,n\}$. Given $\I$ a set of indices, $\sigma$ an evaluation of messages for all actions in $A$, and $\phi$ a propositional formula such that all its terms are built over indices in $\I$ and variables bounds by $\sigma$, we denote $A,\I,\M,\sigma \models \phi$ the fact that $A,\I,\M,\sigma$ satisfies $\phi$. We define inductively $\models$ as:
  \begin{itemize}
  \item $A,\I,\M,\sigma \models t=t'$ if $\M, \sigma \models \EQ(t,t') \sim \true$,

  \item $A,\I,\M, \sigma \models \tau = \tau' $ if $\tau \in \Timestamps$ and $\tau = \tau'$,

  \item $A,\I,\M, \sigma \models \tau \leq \tau' $ if $\tau,\tau' \in \Timestamps$ and $\tau \leq \tau'$,

  \item $A,\I,\M, \sigma \models \happens(a)$ if $a \in A$,
  \item $A,\I,\M, \sigma \models a=a'$ if $a \in A$ and $a=a'$,
  \item $A,\I,\M, \sigma \models i=i'$ if $i \in I$ and  $i=i'$,

  \end{itemize}

  We inductively define the evalutation of the logical connectors in the natural way.
\end{definition}






\subsection{Protocols definitions}
We  model protocols as a set of possible actions available to the
attacker. An action essentially models a step of the protocol, where
the attacker provides some inputs, some conditions are checked, some
updates are performed, and finally an output is performed.

Some actions may be available to the attacker in parallel, or one
after the other. A protocol will then be a tree, each node labelled by an action, a parallel operator or a choice operator.

\begin{definition}
An action $s(\ov{id})$ is a tuple $(\phi,U,o)$, where $\ov{id} \in \I^k$ is a list of indices variable, $\phi$ is a propositional formula over ground terms (called the condition of $s$), $U$ is a set of states updates (a mapping from state symbols to terms), and $o$ is a list of ground terms.
All indices appearing in $\phi,U,o$ must appear in $I$.

Given a set of actions $\Actions$, a protocol $P$ is a term built over the signature $\{\|/2,\oplus/2\} \cup \{a/1 \mid a \in \Actions\}$, such that when going down inside the protocol, the indices set of the actions can only grow. We denote $\Actions(P)$ the set of actions appearing inside $P$. We denote $\suc^*(a)$ all the descendants of a node, $\pre(a)$ the predecessor (ancestor) of $a$ inside $P$ and $\bro(a)$ its brother, which are defined only if they exists.
\end{definition}.

We may denote an acrion $s(\ov{id})$ to give explicitely its set of indexes.
For concision, we will denote protocols using $;,\|,\oplus$. For instance, $s_1; (s_2 \| s_3(id))$ represents the protocol where the attacker can first execute $s_1$, and can then execute in any order $s_2$, and an arbitrary number of occurences of $s_3(id)$.

There exists a natural translation from applied pi-calculus to this notion of actions, reminescent of the translation inside Horn Clauses performed by Proverif, or the translation inside Multi Set Rewritting rules performed by Sapic (a Tamarin extension).

\subsection{Symbolic protocol execution}

Protocols can be executed according to the odering constraints on protocol steps defined by the protocol tree.
Each action depending on indices may be instantiated an arbitrary number of time using distinct indices. The protocol defines how the protocol steps may be executed. For instance, if some protocol step appears in
the trace with some defined indices, all its ancestors must have been executed previously in the trace.


\begin{definition}
  Given a protocol $P$, a symbolic trace of of $P$ is given, for any $n\in\mathbb{N}$, by a sequence of actions $a_0 (\ov{id}_0),\dots,a_n (\ov{id}_n)$, such that for all $1 \leq i,j \leq n$,
  \begin{itemize}
    \item each action is an instantiation of a protocol action and indices are uniformly instantiated, i.e, there exists $\sigma : \I \mapsto \I$, such that $a_i (\sigma (\ov{id})) \in\Actions(P)$,
    \item each action occurs only once, i.e, $a_i \neq{} a_j$ or $\ov{id}_i \neq\ov{id}_j$,
    \item if an action must happen before another one, it is reflected in the trace, i.e
      if $\pre (a_i(\sigma(\ov{id}_i)) \in \Actions(P)$, then there exists $k$ such that $\pre(a) = a_k(\sigma(\ov{id}_k))$,
    \item if the protocol enforces a choice between two actions, then it is respected in the trace, i.e if $\pre(a_i(\sigma(\ov{id}_i))) = \oplus$, then $a_j(\sigma(\ov{id}_j)) \notin \suc^*(a_i(\sigma(\ov{id}_i)))$,
      \item the actions only depends on previous actions, i.e, for any $\out@a$ (resp. $\inp@a$) which appears in the terms of $a_i(\ov{id}_i)$, then there exists $k < i$ (resp. $k \leq i$) such that $a = a_k(\ov{id}_k)$.
      \end{itemize}
\end{definition}
Intuitively, a symbolic trace represent a possible scheduling of the protocol, when abstracting all the inputs. Some symbolic trace may not correspond to any actual execution of the protocol, if for instance an action require a condition which is never met.

Notice that the number of symbolic traces is infinite as soon as there exists an accessible action with a non nil set of indices.


\subsection{Concrete protocol execution}
As in the \BC model, we models arbitrary messages produced by the attacker using free function symbols $\{g_i\}_{i \in \mathbb{N}} \in \G$, and extend the definition of a computational model $\M$ so that it contains Turing machines for each attacker symbol.

\begin{definition}
  Given by a symbolic trace $A = a_0,\dots,a_n$ of $P$, we define inductively $\sigma$ the instantiation of the inputs and ouputs of $A$ such that:
  \begin{itemize}
  \item $\minp@a_i\sigma := g_i( \mout@a_0\sigma,\dots,\mout@a_{i-1}\sigma  ) $
  \item $\mout@a_i\sigma := o_0\sigma, \dots, o_k\sigma$, where $o_0,\dots,o_k$ is the set of ouputs of  $a_i$,
    \item $s@a_i := u\sigma$, where $s$ is a state and $s \mapsto u$ is the latest update corresponding to $s$ appearing inside the actions before $a_i$.
\end{itemize}
\end{definition}
Note that $\sigma$ can indeed be defined, as by definition of a symbolic traces, the outputs of the action $a_i$ only depends on input values of previous actions.

\begin{definition}
  A (concrete) trace of $P$ is given by a symbolic trace $A = a_0,\dots,a_n$ of $P$ along with a computational model $\M$, such that with $\sigma$ the instantiation of $A$, for all $\eta$, we have that $A,\I,\sigma \models \bigwedge_{1\leq i \leq n} \phi_i$, where $\phi_i$ is the condition of $a_i$.

  We denote $\tr(P)$ the set of traces of $P$.
\end{definition}

A trace of $P$ then corresponds to an actual possible evaluation of $P$. More strongly, $\tr(P)$ represents the set of all possible executions of the protocol $P$ for all possible probabilistic polynomial time attackers.

\subsection{Semantics of quantified formulas}

\begin{definition}
  Given a quantified formula $\phi$ and a trace $(A=(a_0,\dots,a_n),\M)$ of $P$, we write $A, \M \models \phi$ when the trace satisfies $\phi$. With $I$ the finite set of indices appearing in $A$ and $\sigma$ the instantiation of $A$, we define $\models$ by induction as:
  \begin{itemize}
  \item $A,\M \models \forall x:\idx.\ \phi$ if $A,\M, \I,\sigma \models \bigwedge_{i\in \I} \phi\replace{x}{i}$

  \item $A,\M \models \forall x:\timestamp.\ \phi$ if $A,\M, \I,\sigma \models \bigwedge_{1 \leq \tau \leq n} \phi\replace{x}{\tau}$
  \item $A,\M \models \forall x:\mess.\ t= t' $ if $\M, \sigma \models \forall x:\mess, \EQ(t,t') \sim \true$
  \item $A,\M \models \forall x:\bool.\ t= t' $ if $\M, \sigma \models \forall x:\bool, \EQ(t,t') \sim \true$
  \end{itemize}

We say that $P \models \phi$, if for all $(A,\M)$ in $\tr(P)$, $A, \M \models \phi$.

\end{definition}

This semantics does match the intuition: for all possible executions of the protocol and for any security parameter, the execution satisfies the formula.


\newpage
\section{Old stuff}



\paragraph{Facts}
Facts are schemas of $\bc$ formulas indexed by path constraints:
\[
  \phi \mdef
  \cforall_\theta\, \valpha.\;
  \psi
  \ra
  \bigvee_{i}
  \cexists_\gammai \vbetai. \psi_i
\]

\paragraph{Environments}
\[
  \env \mdef
  \aset \mid
  \pcnstr \mid
  \decls
  \qquad
  \text{ where }
  \qquad
  \decls \mdef
  \left\{
    \decl{t_\sfx}
    {t_\epsilon,(t_\sfy^\act)_{\act \in \aset}}
  \right\}
\]
where:
\begin{itemize}
\item $\aset$ is the set of symbolic actions.
\item $\pcnstr$ is a set of path constraints.
\item $\decls$ is a set of inductive term declarations.
\end{itemize}
\paragraph{Judgments}
\[
  \ejudge{\env}{\facts{\valpha}{\theta}{\Gamma}}{\phi}
\]
where:
\begin{itemize}
\item $\env$ is the environment.
\item $\pvtype{\valpha}{\theta}$ declares a set of constrained path variables.
\item $\Gamma$ is a set of facts.
\item $\phi$ is the goal.
\end{itemize}

\begin{remark}
  $\env$ will be invariant during derivations. We omit it when there is no ambiguity.
\end{remark}

\paragraph{Standard Introduction Rules}
\begin{mathpar}
  \inferrule[\rraintro]{
    \judge{\facts{\valpha}{\theta}{
        \Gamma \cup \{\psi_0\}}}
    {
      \cexists_\gammap \vdelta. \psi
    }
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}
    {
      \psi_0
      \ra
      \cexists_\gammap \vdelta. \psi
    }
  }

  \inferrule[\andlintro]{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \} \cup \{\psi'\}}}
    {\phi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \wedge \psi'\}}}
    {\phi}
  }

  \inferrule[\orlintro]{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \}}}
    {\phi}\\
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{\psi'\}}}
    {\phi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma \cup \{ \psi \vee \psi'\}}}
    {\phi}
  }

  \inferrule[\andrintro]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi}\\
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi'}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi \wedge \psi'}
  }

  \inferrule[\orrintro-1]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi \vee \psi'}
  }

  \inferrule[\orrintro-2]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi'}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi \vee \psi'}
  }

  \inferrule[\toprintro]{
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\top}
  }
\end{mathpar}

\paragraph{Other Rules}
\begin{mathpar}
  \inferrule[\absurd]{
    \bot \in \Gamma
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\axiom]{
    \psi \in \Gamma
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi}
  }

\end{mathpar}

\paragraph{Modal Introduction Rules}
\begin{mathpar}
  \inferrule[\grintro]{
    \judge{\facts{\valpha,\vbeta}{\theta\wedge\gamma}{\Gamma}}
    { \phi }\\
    \valpha \cap \vbeta = \emptyset
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}
    {
      \cforall_\gamma\, \vbeta.\;
      \phi
    }
  }

  \inferrule[\printro]{
    \nu : \vbeta \mapsto \valpha\\
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi\nu}\\
    \centail{\theta}{\gamma\nu}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\gamma \vbeta. \psi}
  }
\end{mathpar}

\paragraph{Path Constraints Rules}
\begin{mathpar}
  \inferrule[\clweaken]{
    \judge
    {\facts{\valpha}{\gamma}{\Gamma}}{\phi}\\
    \centail{\theta}{\gamma}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\crstrengthen]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\delta \vbeta. \phi}\\
    \centail{\delta}{\gamma}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\gamma \vbeta. \phi}
  }

  \inferrule[\cempty]{
    \centail{\theta}{\bot}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{
      \phi
    }
  }

  \inferrule[\cdisj]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}\\
    \judge{\facts{\valpha}{\gamma}{\Gamma}}{\phi}
  }{
    \judge{\facts{\valpha}{\theta \vee \gamma}{\Gamma}}{\phi}
  }
\end{mathpar}

\paragraph{Rules}
\begin{mathpar}
  \inferrule[\defunroll{t_\tau}]{
    \decl{t_\sfx}
    {t_\epsilon,(t_\sfy^\act)_{\act \in \aset}} \in \decls\\
    \tau \in \valpha\\
    \tauo \not \in \valpha\\\\
    \judge
    {\facts{\valpha}
      {\theta\wedge\tau = \epsilon}
      {\Gamma \wedge t_\tau = t_\epsilon}}
    {\phi}\\
    \left(
      \judge
      {\facts{\valpha,\tauo}
        {\theta\wedge\tauo = \tpred{\tau}\wedge \tauo = \act}
        {\Gamma \wedge t_\tau = t_\tauo^\act}}
      {\phi}
    \right)_{\act \in \aset}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\requ]{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi[s]}\\
    \judge{\facts{\valpha}
      {\theta}{\Gamma}}
    {s = t}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{
      \psi[t]
    }
  }

  \inferrule[\papply]{
    \cexists_\gamma \vbeta. \psi
    \in \Gamma\\
    \valpha \cap \vbeta = \emptyset\\
    \judge{\facts{\valpha, \vbeta}{\theta \wedge \gamma}
      {\Gamma \cup \{\psi\}}}{\phi}
  }{
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}
  }

  \inferrule[\apply]{
    (\cforall_\gamma\, \vbeta.\;
    \psi
    \ra
    \phi_0)
    \in \Gamma\\
    \nu : \vbeta \mapsto \valpha\\
    \centail{\theta}{\gamma\nu}\\
    \judge{\facts{\valpha}{\theta}{\Gamma}}{\psi\nu}\\
    \judge{\facts{\valpha}{\theta}
      {\Gamma \cup \{\phi_0\nu\}}}{\phi}
  }{\judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}}

  \inferrule[\induc]{
    \phi' \equiv
    \cforall_{\gammao} \tauo.\phi\\
    \gammao \equiv
    \subst{\gamma}{\tau}{\tauo}\wedge\tauo < \tau\\
    \tau,\tauo \not \in \valpha\\
    \judge
    {\facts{\valpha,\tau}{\theta\wedge\gamma}{\Gamma\cup\{\phi'\}}}
    {\phi}
  }{
    \judge
    {\facts{\valpha}{\theta}{\Gamma}}
    {\cforall_\gamma \tau.\phi}
  }
\end{mathpar}

\paragraph{Superpositions of $\clweaken$ or $\crstrengthen$ with other rules}
\begin{itemize}
\item $\mrule{\clweaken}$ with $\mrule{\printro}$:
  \[
    \inferrule[\printrogen]{
      \nu : \vbeta \mapsto \valpha\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}{\Gamma}}{\psi\nu}\\
      \judge{\facts{\valpha}{\theta \wedge \neg(\gamma\nu)}{\Gamma}}{\bot}
    }{
      \judge{\facts{\valpha}{\theta}{\Gamma}}{\cexists_\gamma \vbeta. \psi}
    }
  \]

\item $\mrule{\crstrengthen}$ with $\mrule{\apply}$ and $\mrule{\absurd}$:
  \[
    \inferrule[\botapply]{
      (
      \cforall_\gamma\, \vbeta.\;
      \psi
      \ra
      \bot
      ) \in \Gamma\\
      \nu : \vbeta \mapsto \valpha\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}{\Gamma}}{\psi\nu}\\
      \judge{\facts{\valpha}{\theta \wedge \neg(\gamma\nu)}{\Gamma}}{\phi}
    }{\judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}}
  \]

\item $\mrule{\crstrengthen}$ with $\mrule{\apply}$ (general case):
  \[
    \inferrule[\botapply]{
      (
      \cforall_\gamma\, \vbeta.\;
      \psi
      \ra
      \phio
      ) \in \Gamma\\
      \nu : \vbeta \mapsto \valpha\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}{\Gamma}}{\psi\nu}\\
      \judge{\facts{\valpha}{\theta \wedge (\gamma\nu)}
        {\Gamma \cup \{ \phio\nu\}}}
      {\phi}\\
      \judge{\facts{\valpha}{\theta \wedge \neg(\gamma\nu)}{\Gamma}}{\phi}
    }{\judge{\facts{\valpha}{\theta}{\Gamma}}{\phi}}
  \]

\end{itemize}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
