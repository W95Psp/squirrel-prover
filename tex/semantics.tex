\section{Semantics}

We now define meta-interpretations, which are the structures needed to
give a meaning to indices and timestamps. More generally, a trace model
also allows to translate any meta-logic formula $\phi$
(over some meta-logic signature $\Sigma$)
to a base logic $\phi^I$ (over some base logic signature $\Sigma^I$).
For example, if
$\Sigma$ contains a name $\mathsf{n}$ with index arity $1$, and
the meta-interpretation interprets indices in a domain
$D_\I = \{ 17, 22 \}$, the base logic signature will feature
two names $\mathsf{n}_{17}$ and $\mathsf{n}_{22}$.

\david{I like Adrien's suggestion to rename meta-interpretations to trace
model, but I'm lazy to rename all meta-interpretations $I$ to $T$. Also,
both $T$ and $\T$ have a meaning at this point. Shall we move to trace models
$\mathbb{T}$ and computational models $\mathbb{M}$ (which would avoid the
confusion with the set $\M$ of macro symbols ?}

\medskip

From now on, we assume a protocol $P$ providing some set of action
symbols $\A$, using function and name symbols from $\F$ and $\N$,
as well as memory cell symbols from $\States$.
We consider meta-logic terms and formulas over $\Sigma = (\F,\N,\M,\A)$
where $\M = \{ \minp, \mout, \mframe \} \cup \States$.

\begin{definition}
  Given a finite set of integers $D$ we define the base logic
  signature $\Sigma^D$ containing exactly:
  \begin{itemize}
    \item a name symbol $n_{e_1,\ldots,e_k}$ for every $n \in \N_k$
       and $e_1,\ldots,e_k \in D$;
    \item a function symbol $f_{e_1,\ldots,e_k}$ of arity $n$ for every
      $f \in \F_k^n$ and $e_1,\ldots,e_k \in D$;
    \item a function $g_n$ of arity $n$ for every $n\in\mathbb{N}$.
  \end{itemize}
  The latter kind of function symbol will be used, as usual in the BC 
  approach, to model attacker computations.
\end{definition}

Note that, for each name $\mathsf{n}\in \N$ and indices $n_1,\ldots,n_k \in
D_\I$, $\mathsf{n}_{n_1,\ldots,n_k}$ refers to a distinct name in $\N^{I_\tr}$.
\adrien{The same is true for function symbols. The thing to remark here is that in a BC computational model, different names will always be interpreted by i.i.d.\ uniform random samplings. This is not true for function symbols ($\ne$ function symbols may have the same interpretation).}

\begin{definition}
  A meta-interpretation (relative to $P$) is given by:
  \begin{itemize}
    \item a finite index domain $\D_\I \subseteq \mathbb{N}$;
    \item a total ordering $\leq_\XT$ on
      $\D_\XT = \{ \tinit \} \uplus \{ a(\ov{n}) : a\in\Actions_k,
      \ov{n}\in\D_\I^k \}$ which refines the dependency ordering
      $\leq$ on concrete actions and such that $\tinit$ is minimal;
    \item mappings $\sigma_\I : \I \to D_\I$
      and $\sigma_\XT : \XT \to D_\XT$ that interpret index and
      timestamp variables as elements of their respective domains;
  \end{itemize}
\end{definition}

\newcommand{\interp}[1]{(#1)}

Given a meta-interpretation $I$ of domains $D_\I$ and $D_\XT$
we define the interpretation of index and timestamp terms as
follows:
\begin{itemize}
  \item $\interp{i}^I = \sigma_\I(i)$ and $\interp{\tau}^I = \sigma_\XT(\tau)$;
  \item $\interp{\tinit}^I = \tinit$ and
    $\interp{\sfa(i_1,\ldots,i_k)}^I =
     \sfa(\sigma_\I(i_1),\ldots,\sigma_\I(i_n))$
    for all $\sfa\in\Actions_k$ and $e_1,\ldots,e_k\in D_\I$;
  \item $\interp{\tpred{T}}^I$ is the predecessor of $\interp{T}^I$
    according to ${\leq}_\XT$, or $\tinit$ if $\interp{T}^I = \tinit$.
\end{itemize}

We can then define, for each macro symbol $m\in\M_k$,
its interpretation $m^I : D_\I^k \times D_\XT \to T_\Sigma^{D_I}$.
More precisely we define $m^I(e_1,\ldots,e_k,t)$ by induction on $t$,
as follows. Let $(\alpha'_i)_i$ be the enumeration of the elements
of $D_\XT$ wrt $\leq$ (in particular, $\alpha'_0 = \tinit$), and let
$\alpha_i$ be a symbolic action of which $\alpha'_i$ is an instance:
\begin{itemize}
  \item $\mout^I(\tinit) = \min^I(\tinit) = \mframe^I(\tinit) = 0$;
  \item $s(e_1,\ldots,e_k,\tinit) = 0$ for all $s \in \States_k$ and
    $e_1,\ldots,e_k \in D_\I$;
  \item we then set, for timestamps other than $\tinit$,
    $$
    \minp^I(\alpha'_{i+1}) =
    g_{i}(\mout^I(\alpha'_1),\ldots,\mout^I(\alpha'_i))
    $$
    $$s^I(f_1,\ldots,f_p,\alpha'_{i+1}) =
    \interp{
      u_{\alpha_{i}}^{s}
    }^{I\{\vec{i}\mapsto\vec{e},\vec{j}\mapsto\vec{f}\}}
    $$
    $$
    \mout^I(\alpha'_i) =
      \interp{
        o_{\alpha_i}
        \{x_{\beta_j}\mapsto\mout@\alpha_j\}_{j\leq i}
        \{x_{\alpha_i}^{s[j_1,\ldots,j_p]}\mapsto 
          s[j_1,\ldots,j_p]@\alpha_i\}_s
        }^{I\{\vec{i}\mapsto\vec{e}\}}
    $$
    The interpretation of input macros is the simplest:
    it uses an arbitrary function $g_i$ to model the attacker's
    computation based on previous outputs.
    For the other macros, the interpretation at some concrete
    action $\alpha'_i$ is obtained from the symbolic semantics of
    $\alpha_i$ by applying the relevant substitutions (directly
    on terms of the meta-logic when possible\footnote{
      \david{What I wrote implicitly assumes that there is no dependency
      such as e.g.\ $b(i,j) \leq a(i)$ where the dependency introduces
      a new index.}
    }, otherwise by updating the meta-interpretation).
  \end{itemize}
  \david{All this requires to interpret terms, and thus formulas: everything 
  has to be done simultaneously!}

\begin{definition}
  We define $(T)^{I_\tr} \in D_\XT$ and $(t)^{I_\tr} \in \Msg^{I_\tr}_\Sigma$ as follows:
  \begin{eqnarray*}
    (\mathsf{n}[i_1,\ldots,i_k])^{I_\tr} &=& \mathsf{n}_{\sigma_\I(i_1),\ldots,\sigma_\I(i_k)}
    \\
    (x)^{I_\tr} &=& x
    \\
    (f[i_1,\ldots,i_k](t_1,\ldots,t_n))^{I_\tr} &=&
    f_{\sigma_\I(i_1),\ldots,\sigma_\I(i_k)}\bigl(
      (t_1)^{I_\tr},\ldots,(t_n)^{I_\tr}
    \bigr)
    \\
    (m[i_1,\ldots,i_k](t_1,\ldots,t_n)@T)^{I_\tr} &=&
    \hat{m}(\sigma_\I(i_1),\ldots,\sigma_\I(i_k),
      (t_1)^{I_\tr},\ldots,(t_n)^{I_\tr},
      (T)^{I_\tr})
  \end{eqnarray*}
\end{definition}

\begin{example}
  Consider the meta-logic term $t := \mathsf{h}(\mout@a[i],\mathsf{k}[i])$
  and an interpretation $I_\tr$ with $D_\XT = [1;10]$ and $D_\I = [1;3]$
  (which might be relevant if we are considering traces of ten actions
  with three agents) such that $\sigma_\I(i)=2$ and $\hat{a}(2)=10$
  and $\hat{\mout}(10)=\mathsf{ok}$ (the message outputted at step 10
  is $\mathsf{ok}$ \adrien{I don't like this. It seems that macro can be interperted as the term we want at any timestamp.}).
  We then have $(t)^{I_\tr} = \mathsf{h}(\mathsf{ok},\mathsf{k}_2)$.
\end{example}

The reason why macros take only one timestamp argument is purely practical:
we have no use for more. At this point one might wonder why we separate
indices and actions given that they are interpreted similarly: it is again
purely practical, we will use them for different purposes, and we will need
less structure on indices than on actions, making reasoning easier on them
(one can simply compare indices, there is no ordering and no predecessor
operation on them).


\begin{definition}
  If $I_\tr$ is a meta-interpretation and $e\in D_\I$,
  $I_\tr[i\mapsto e]$ is the interpretation where $\sigma_\I$ is
  modified so that $\sigma_{\I}(i)=e$.
  We define the translation of a meta-logic formula $\phi$
  into the base logic \emph{term} $(\phi)^{I_\tr}$
  as follows:
  \begin{eqnarray*}
    (\phi\wedge\phi')^{I_\tr} &=& (\phi)^{I_\tr} \stackrel{.}{\wedge} (\phi')^{I_\tr}
    \quad \text{and similarly for other boolean connectives} \\
    (\forall i:\idx. \phi)^{I_\tr} &=&
    \stackrel{.}{\wedge}_{e\in D_\I} (\phi)^{I[i\mapsto e]} \\
    (\forall \tau:\timestamp. \phi)^{I_\tr} &=&
    \stackrel{.}{\wedge}_{e\in D_\XT} (\phi)^{I[\tau\mapsto e]} \\
    (\exists i:\idx. \phi)^{I_\tr} &=&
    \stackrel{.}{\vee}_{e\in D_\I} (\phi)^{I[i\mapsto e]} \\
    (\exists \tau:\timestamp. \phi)^{I_\tr} &=&
    \stackrel{.}{\vee}_{e\in D_\XT} (\phi)^{I[\tau\mapsto e]} \\
    (i=i')^{I_\tr} &=&
    \left\{\begin{array}{ll}
      \mathsf{true} & \text{if } \sigma_\I(i)=\sigma_\I(i') \\
      \mathsf{false} & \text{otherwise}
    \end{array}\right. \\
    (T = T')^{I_\tr} &=&
    \left\{\begin{array}{ll}
      \mathsf{true} & \text{if } (T)^{I_\tr} = (T')^{I_\tr} \\
      \mathsf{false} & \text{otherwise}
    \end{array}\right.
    \quad\text{ and similarly for $\leq$} \\
    (\happens(T))^{I_\tr} &=& \mathsf{true}
    \text{ if } (T)^{I_\tr} \in H_\XT
    \text{ and } \mathsf{false} \text{ otherwise}
    \\
    (t=t')^{I_\tr} &=& (t)^{I_\tr} \stackrel{.}{=} (t')^{I_\tr}
  \end{eqnarray*}
\end{definition}

\begin{definition}
  A formula $\phi$ of the meta-logic is said to be valid when,
  for any meta-interpretation $I_\tr$, the base logic formula
  $(\phi)^{I_\tr} \sim \mathsf{true}$ is valid.

  In other words, we have $\M,\sigma\models(\phi)^I\sim\mathsf{true}$
  i.e. the boolean term $(\phi)^{I_\tr}$ is true with overwhelming
  probability in any computational model $\M$ and for any interpretation
  $\sigma$ of the free message variables.\footnote{
  In the tool, we only allow universal quantification over messages, and
  only allow it at toplevel. The validity of such formulas is the same as
  when the variables are left free.}
\end{definition}


\begin{definition}
  A meta-logic formula $\phi$ is a
  logical consequence of a set $S$ of meta-logic formulas
  (noted $S \models \phi$)
  when
  $\M\models(\phi)^{I_\tr}\sim\mathsf{true}$ holds for any $\M$ and ${I_\tr}$ such that
  $\M\models(\psi)^{I_\tr}\sim\mathsf{true}$ holds for all $\psi\in S$.
  \adrien{This definition seems not necessary. We interpret meta-formula as (schemas of) first-order formulas. Hence entailment is exactly first-order logic entailment.}
\end{definition}
