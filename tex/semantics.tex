\section{Semantics}

We now define trace models, denoted $\TM$, which are the structures needed to
give a meaning to indices and timestamps. More generally, a trace model
also allows to translate any meta-logic formula $\phi$
(over some meta-logic signature $\Sigma$)
to a base logic $\phi^\TM$ (over some base logic signature~$\Sigma^\TM$).

\medskip

From now on, we assume a protocol $P$ providing some set of action
symbols $\Act$, using function and name symbols from $\F$ and $\N$,
as well as memory cell symbols from $\States$.
We consider meta-logic terms and formulas over $\Sigma = (\F,\N,\Mac,\Act)$
where $\Mac = \{ \minp, \mout, \mframe \} \cup \States$. We require that $\Sigma$ contains the following function symbols, of index arity $0$:
\begin{itemize}
\item a function $\att$ of arity one, which models attacker computations.
% \item a function $\att_n$ of arity $n$ for every $n\in\mathbb{N}$, which models attacker computations. 
\item a binary function symbol $\langle \cdot , \cdot \rangle$ for pairs;
\item binary function symbols
  $\stackrel{.}{\wedge}$, $\stackrel{.}{\vee}$ and
  $\stackrel{.}{\Rightarrow}$ for boolean operations;
\item a ternary function symbol $\mathsf{if}$;
\item nullary function symbols $\mathsf{true}$ and $\mathsf{false}$.
\end{itemize}
We use the usual notations for boolean symbols (infix), $\mathsf{if}$ and for pairs (e.g.\ $\langle t_1,t_2 \rangle$).

\begin{definition}
  Given a finite set of integers $D$, the base logic
  signature $\Sigma^D$ is contains exactly:
  \begin{itemize}
    \item a name symbol $n_{e_1,\ldots,e_k}$ for every $n \in \N_k$
       and $e_1,\ldots,e_k \in D$;
    \item a function symbol $f_{e_1,\ldots,e_k}$ of arity $n$ for every
      $f \in \F_k^n$ and $e_1,\ldots,e_k \in D$;
  \end{itemize}
\end{definition}

For example, if $f \in \F_1$ (resp. $k \in \N_1$) and we have two distinct
integers $n$ and $m$ in $D$, then $f_n$ and $f_m$ (resp. $k_n$ and $k_m$)
are distinct function (resp. name) symbols in $\Sigma^D$.
A computational model may give the same interpretation for $f_n$ and $f_m$
but $k_n$ and $k_m$ will necessarily be mapped to two independent uniform
samplings.

\subsection{Trace models}

We define the structure which will allow us to interpret meta-logic
terms and formulas.

\begin{definition}
  For every protocol $\calp = (\calp_\sfA, \leq)$, a $\calp$-trace model $\TM$ is a tuple
  \(
    (\D_\I, \D_\XT, \leq_\XT, \sigma_\I, \sigma_\XT)
  \) such that:
  \begin{itemize}
    \item $\D_\I \subseteq \mathbb{N}$ is a finite index domain;
    \item $\leq_\XT$ is a a total ordering on
      $\D_\XT := \{ \tinit \} \uplus \{ a(\ov{n}) : a\in\Act_k, \ov{n}\in\D_\I^k
      \}$ which refines the dependency ordering $\leq$ on concrete actions such
      that $\tinit$ is minimal, and such that the sequence of elements of $\D_\XT$ ordered by $\leq$ is an
      abstract trace of $\calp$;
    \item $\sigma_\I : \I \to D_\I$
      and $\sigma_\XT : \XT \to D_\XT$ are mappings that interpret index and
      timestamp variables as elements of their respective domains;
  \end{itemize}
\end{definition}

The total ordering $\leq_\XT$ yields a predecessor function
$\mathsf{pred}_\XT : \D_\XT\to\D_\XT$ which,
by convention, maps $\tinit$ to itself,
and all other elements $v \in \D_\XT$ to the largest $v' \in \D_\XT$ such that
$v' < v$.

When $\TM$ is a trace model and $e$ is an element of its index domain,
$\TM\{i\mapsto e\}$ is the trace model identical to $\TM$ except for
$\sigma_\I$ which is updated to map $i$ to $e$. We similarly define
$\TM\{\tau\mapsto v\}$ when $v$ is an element of the timestamp domain of $\TM$.

\subsection{Interpretation of terms and formulas}

\newcommand{\interp}[1]{(#1)}

\adrien{We should give an example in the introduction, and explain that we interpret $\exists$ and $\forall$ by, respectively, $\vee$ and $\wedge$}.

We define next the interpretation of terms and formulas. %  when they are
% macro-free, i.e.\ when terms contain no occurrence of $m[\vec{i}]@T$
% and formulas contain no occurrence of $m@T$. This will be used to
% define the interpretation of macros and, finally, of all terms
% and formulas.

\begin{definition}
  The interpretation % of macro-free
  terms and formulas of the meta-logic in
  some trace model $\TM$, noted $\interp{t}^\TM$ and $\interp{\phi}^\TM$
  respectively, is given by the clauses of \cref{fig:interpt,fig:interpf,fig:inter-macros}.
\end{definition}

Basically, frames are defined as nested pairs, starting from $0$ and
providing, for each action, the output of the action if it is executable,
and $0$ otherwise. The interpretation of input macros uses function symbols $\att$ to models the arbitrary attacker's computation based on the previous frame, which models its current knowledge. The definition of $s^\TM(\vec{f},\sfa[\pvec{e}])$ gives the content of memory cell $s[\vec{f}]$ just after the execution of $\sfa[\pvec{e}]$:
it is obtained by interpreting the update term $u_{\sfa}^{s}$. The semantics of outputs is defined similarly. 

\input{figs-semantics}

\begin{example}
  The formula
  $\exists i:\idx.~ \tau = \sfa(i)$
  is translated to the disjunction of base logic terms
  $\interp{\tau = \sfa(i)}^{\TM\{i\mapsto e\}}$ for all $e \in \D_\I$.
  Each disjunct is either $\mathsf{true}$ or $\mathsf{false}$ depending on
  whether $\sigma_\XT(\tau)$ and $\sfa(e)$ are equal.
\end{example}

\begin{proposition}
  For any protocol $\calp$ and $\calp$-trace model $\TM$, for any the interpretation $(\cdot)^\TM$ of terms and formulas of the meta-logic is well-defined.
\end{proposition}

\begin{proof}
  We only need to prove that the inductive definition of $(\cdot)^\TM$ given in \cref{fig:interpt,fig:interpf,fig:inter-macros} terminates. All cases are trivial, as $(t)^\TM$ (resp.\ $(\phi)^\TM$) are defined using $(\cdot)^\TM$ on strict subterms of $t$ (resp.\ $\phi$), except for the macros case, where termination follows from the well-founded conditions on actions of a protocol.
\end{proof}

% \subsection{Macros}
% Let $(\alpha'_i)_{0 \leq i < |\D_\XT|}$ be the enumeration of the elements
% of $D_\XT$ w.r.t.\ $\leq_\XT$ (in particular, $\alpha'_0 = \tinit$).
% For each $k$, let $\alpha_k$ be the representative symbolic action
% such that $\alpha'_k = \alpha_k\{\vec{i}_k\mapsto\vec{e}_k\}$.

% We define the interpretation $\mcond^\TM$ from $\D_\XT$
% to base logic formulas, as follows:
% \adrien{We do not interpret as a base logic formula, as there are macros}
% \begin{eqnarray*}
%   \mcond^\TM(\tinit) &=& \true \\
%   \mcond^\TM(\alpha'_{k+1}) &=&
%     \interp{\phi_{\alpha_{k+1}}
%     \{x_\beta\mapsto\mout@\beta\}_{\beta\leq \alpha_{k+1}}
%     \{x^{s[\vec{j}]}\mapsto
%       s[\vec{j}]@\alpha_{k+1}\}_s
%     }^{I\{\vec{i}_{k+1}\mapsto\vec{e}_{k+1}\}}
% \end{eqnarray*}
% In other words, $\mcond^\TM(\alpha'_{k+1})$ is obtained by taking the
% (macro-free) condition $\phi_{\alpha_{k+1}}$ of the symbolic action, and
% interpreting it using $I$, mapping indices $\vec{i}_{k+1}$ to their
% desired concretization.
% The semantics $\mexec^\TM$ of the executability macro is then simply defined as
% the conjunction of consecutive conditions:
% \begin{eqnarray*}
%   \mexec^\TM(\tinit) &=& \true \\
%   \mexec^\TM(\alpha'_{k+1}) &=&
%     \mcond^\TM(\alpha'_{k+1})
%     \stackrel{.}{\wedge}
%     \mexec^\TM(\alpha'_k)
% \end{eqnarray*}

% We then define, for each macro symbol $m\in\Mac_k$,
% its interpretation $m^\TM : D_\I^k \times \D_\XT \to T_\Sigma^{D_I}$.
% More precisely, we define $m^\TM(\ldots,v)$ by induction on its timestamp
% argument $v$ as follows, for all $s \in \States_p$ and $\vec{f} \in D_\I^p$:
% \[
%     \minp^\TM(\tinit) = \mframe^\TM(\tinit) = s^\TM(\vec{f},\tinit)
%     = \mout^\TM(\tinit) = 0\]


% \[\begin{array}{rll}
%     \mframe^\TM(\alpha'_{k+1}) &=&
%     \langle \mframe^\TM(\alpha'_k),
%     \myif \mexec^\TM(\alpha'_{k+1}) \mythen \mout^\TM(\alpha'_{k+1}) \myelse 0
%     \rangle
%     \\
%     \minp^\TM(\alpha'_{k+1}) &=&
%     \att_{k}(\mframe^\TM(\alpha'_k))
%   \\
%     s^\TM(\vec{f},\alpha'_{k+1}) &=&
%     \interp{
%       u_{\alpha_{k+1}}^{s[\vec{j}]}
%       \{x_\beta\mapsto\mout@\beta\}_{\beta\leq \alpha_{k+1}}
%       \{x^{s[\vec{j}]}\mapsto
%         s[\vec{j}]@\alpha_{k+1}\}_s
%     }^{
%       I\{\vec{i}_k\mapsto\vec{e}_k,\vec{j}\mapsto\vec{f}\}}
%   \\
%     \mout^\TM(\alpha'_{k+1}) &=&
%       \interp{
%         o_{\alpha_{k+1}}
%         \{x_\beta\mapsto\mout@\beta\}_{\beta\leq \alpha_{k+1}}
%         \{x^{s[\vec{j}]}\mapsto
%           s[\vec{j}]@\alpha_{k+1}\}_s
%         }^{I\{\vec{i}_{k+1}\mapsto\vec{e}_{k+1}\}}
% \end{array}\]
% \adrien{1) We cannot use $\minp$ in $o$? 2) There are still macros after interpreting $o$}

% Frames are defined as nested pairs, starting from $0$ and
% providing, for each action, the output of the action if it is executable,
% and $0$ otherwise. The interpretation of input macros uses function symbols $\att_i$ to model the arbitrary attacker's
% computation based on the previous frame, which models its current knowledge.

% The definition of $s^\TM(\vec{f},\alpha'_{k+1})$ gives the content of memory
% cell $s[\vec{f}]$ just after the execution of $\alpha'_{k+1}$:
% it is obtained by interpreting the update term $u_{\alpha_{k+1}}^{s[\vec{j}]}$
% of the associated symbolic action $\alpha_{k+1}$ mapping $\vec{i}$
% and $\vec{j}$ to their expected concretizations.

% The semantics of outputs is defined similarly.

% Since meta-logic terms and formulas $o_{\alpha}$, $u_{\alpha}$ and
% $\phi_{\alpha}$ may include occurrences of message variables
% $x_\beta$ and $x^{s[\vec{j}]}$,
% we use a term-level substitution for these variables.



    % For the other macros, the interpretation at some concrete
    % action $\alpha'_i$ is obtained from the symbolic semantics of
    % $\alpha_i$ by applying the relevant substitutions (directly
    % on terms of the meta-logic when possible\footnote{
    %   \david{What I wrote implicitly assumes that there is no dependency
    %   such as e.g.\ $b(i,j) \leq a(i)$ where the dependency introduces
    %   a new index.}
    % }, otherwise by updating the trace model).

% Given for all macros $m \in \Mac_k$ the corresponding interpretation function $m^\TM$, we lift the interpretation of macro-free terms and formulas to terms and formulas with:
%     \[ \interp{m(i_1,\dots,i_k)@T}^\TM = m^\TM(\interp{i_1}^\TM,\dots,\interp{i_k}^\TM,\interp{T}^\TM) \]




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
