\section{Meta-logic}

Terms of the meta-logic are of three possible sorts: index, timestamps
or message. Formulas of the meta-logic may feature predicates over each sort.
Given interpretation $I$ and $T$ of index and timestamp variables
into two finite sets, a formula $\phi$ of the meta-logic will be translated
into a term $(\phi)^{I,T}$ of the base logic in which index and action terms,
and predicates over them, will have disappeared. The validity of the
meta-logic formula $\phi$ will be defined as the validity of the base logic
$(\phi)^{I,T}\sim\mathsf{true}$.

\subsection{Syntax}

\paragraph{Terms}

We assume three infinite sets of variables:
$\X$ (whose elements are noted $x$, $y$, $z$) for message variables;
$\I$ (whose elements are noted $i$, $j$, $k$) for index variables;
$\XT$ (whose elements are noted $\tau$) for timestamp variables.

We assume a set $\F$ of function symbols
(used to model encryptions, pairs,\dots).
Each of these symbols comes with an usual arity:
if $f\in\F$ has arity $n$,
then for all terms $t_1,\ldots,t_n$,
$f(t_1,\ldots,t_n)$ is a term.

We assume a set $\N$ of indexed names symbols,
(used to model random samplings)
and a sets of indexed constants $\Actions$
(used to model specific timestamps).
These indexed symbols only have an index arity: they
cannot be applied to terms.

We finally assume a set $\M$ of indexed macro symbols
equipped with an arity and index arity.
An indexed macro symbol will be applied to the specified number of
indices, variables, and also to a single timestamp.
This timestamp gives the instant at which the macro is evaluated.
We will typically assume macro symbols $\mout$ and $\minp$
(with index arity $0$) for representing messages inputted and outputted
at a particular point of an execution.

\begin{figure}
\[
  \begin{array}{rcll}
    T &:=& \tau & \text{timestamp variable} \\
      &\mid& a[i_1,\ldots,i_k] & \text{constant (for $a\in\mathbb{A}$)} \\
      &\mid & \pre(T) & \text{predecessor}
\end{array}
   \]
\[
     \begin{array}{rcll}
    t & := & n &\text{name} \\
    & \mid & x  & \text{message variable $x\in\X$} \\
    & \mid & F(t_1,\dots,t_n) &\text{function application}\\
    & \mid & m[i_1,\ldots,i_k](t_1,\ldots,t_n)@T &\text{macro application}\\
       \end{array}
     \]
     \caption{Meta-logic terms}\label{fig:terms}
\end{figure}

\begin{definition}
  Given a (meta logic) signature $\Sigma = (\F,\N,\M,\Actions)$
  and some sets of variables
  $\X$, $\I$ and $\XT$,
  \cref{fig:terms} defines the syntax of (meta-logic) terms
  of sort message (noted $t$) and timestamp (noted $T$).
  The only terms of sort index are index variables.
  The set of message terms of the meta-logic is noted $\Msg_\Sigma$.
\end{definition}

\paragraph{Formulas}

The syntax of the meta-logic formulas is given in \cref{fig:syntax}.
We could have included more generally a notion of predicate macro that
would have to be expanded when translating a formula from the meta-logic
to the base logic. Instead we opted to list the few atoms that we
will use in practice.

\begin{figure}
  \[
  \begin{array}{c}
   \begin{array}{rcll}
    \T &  := & \timestamp \mid \idx & \text{(meta logic sorts)} \\
    \\[2ex]
   \atom & := & t=t'
 & \text{atomic proposition over messages } \\
  &\mid & T=T' \mid T \leq T' \mid \happens(T) &  \text{atomic proposition
  over timestamps } \\
  &\mid & i=i'  &  \text{atomic proposition
    over indices } \\
    \end{array}
\\
\\
     \begin{array}{rcll}
    \phi & ::= &  \true \mid \false \mid \phi \wedge \phi' \mid  \phi
    \vee \phi' \mid   \phi \Rightarrow \phi'\mid \neg \phi \mid
    \forall x : \T.\ \phi \mid \exists x:\T.\ \phi \mid \atom &
    \end{array}

\end{array}
    \]
    \caption{Syntax of first order formulas.}\label{fig:syntax}
\end{figure}

\subsection{Semantics: trace-model}

We can now define a trace-model as the structure needed to
give a meaning to index and timestamp terms. A trace-model
also induces a translation from a meta-logic signature $\Sigma$
to some base logic signature $\Sigma^I$. For example, if
$\Sigma$ contains a name $\mathsf{n}$ with index arity $1$, and
the trace-model interprets indices in a domain $D_\I = \{
  17, 22 \}$, the base logic signature will feature
two names $\mathsf{n}_{17}$ and $\mathsf{n}_{22}$.

As in the \BC model, we model arbitrary messages produced by the attacker
using free function symbols $\G = \{g_i | i \in \mathbb{N}\}$. We assume
from now on that our meta-logic signature contains such symbols.

We construct, for each trace, a trace-model representing
the trace. Some details of this definition will be understood in the next
section, where we identify some axioms that hold in all such
trace-models.

\begin{definition}
  Given a trace $\tr = \alpha_1\ldots\alpha_n$,
  we define the trace-model $I_\tr$ as follows
  % (\emph{TODO define the substitution for $x_s$ variables,
  % as well as $\hat{s}$\ldots)}):
  \begin{itemize}
    \item $\D_\I$ is the set of indices that occur in $\tr$;
    \item $\D_\XT = \{ t_0 \} \uplus \{ a(\ov{n}) : a\in\Actions_k,
      \ov{n}\in\D_\I^k \}$;
    \item the order $\leq$ is such that $t_0\leq t$ for all $t\in\D_\XT$,
      and $\alpha\leq\beta$ if $\alpha$ occurs before $\beta$ in $\tr$;
    \item the predecessor function $p$ maps $t_0$ to itself and all
      other timestamps to their predecessor according to $\leq$;
    \item $H_\XT$ is the set of actions that occur in $\tr$,
      i.e.\ $H_\XT=\{\alpha_i : i\in[1;n]\}$;
    \item arbitrary mappings $\sigma_\I : \I \to D_\I$
      and $\sigma_\XT : \XT \to D_\XT$ that interpret index and
      timestamp variables as elements of their respective domains;
    \item for each $a\in\Actions_k$, $\hat{a}(\ov{n}) = a(\ov{n})$;
    \item $\hat{\minp}$ and $\hat{\mout}$ have arbitrary values on
      $t_0$ and otherwise are uniquely defined by the following
      conditions, for all $i\in[1;n]$:
      \begin{itemize}
        \item $\hat{\minp}(\alpha_i) = g_{i}(\mout(\alpha_i)))$
        \item $\hat{\mout}(\alpha_i) =
      \mout_{\alpha_i}\{x_{\alpha_i}\mapsto\hat{\minp}(\alpha_i)\}.$
      \end{itemize}
    % \item for each macro symbol $m \in \M$ of index
    %   arity $k$ and arity $n$, an interpretation
    %   $\hat{m} : D_\I^k \times \Msg_\Sigma^n \times D_\XT \to \Msg^I_\Sigma$,
    %   where $\Msg^I_\Sigma$ is the set of terms of the base
    %   logic for the (base logic) signature
    %   $(\F^I,\N^I)$ with
    %   \[
    %     \F^I =
    %     \{ f_{e_1,\ldots,e_k} : f \in \F_k, e_1,\ldots,e_k \in D_\I \}
    %     \text{ and }
    %     \N^I = \{ \mathsf{n}_{e_1,\ldots,e_k} : \mathsf{n}\in\N_k,
    %     e_1,\ldots,e_k\in D_\I \}.
    %   \]
    %   \adrien{The interpretation of macros can depend on the precise element of $\D_\T$ it is interpreted at. In the tool, this is more restricted. E.g.\ $\hat{m}@a[i]$ can only depend on $a$, not on $i$  (except to re-use $i$ in the term). Instead, we could interpret macro symbol as terms of the meta-logic (with restrictions to have termination).}
  \end{itemize}
\end{definition}

% Note that, for each name $\mathsf{n}\in \N$ and indices $n_1,\ldots,n_k \in
% D_\I$, $\mathsf{n}_{n_1,\ldots,n_k}$ refers to a distinct name in $\N^I$.
% \adrien{The same is true for function symbols. The thing to remark here is that in a BC computational model, different names will always be interpreted by i.i.d.\ uniform random samplings. This is not true for function symbols ($\ne$ function symbols may have the same interpretation).}

Given a trace-model $I_\tr$, we define the interpretation in $I_\tr$ of terms of the meta-logic as terms of the base logic.
\begin{definition}
  Given a trace-model $I_\tr$
  we define $(T)^{I_\tr} \in D_\XT$ and $(t)^{I_\tr} \in \Msg^{I_\tr}_\Sigma$ as follows:
  \begin{eqnarray*}
    (\tau)^{I_\tr} &=& \sigma_\XT(\tau) \\
    (\pre(T))^{I_\tr} &=& p((T)^{I_\tr}) \\
    (a[i_1,\ldots,i_k])^{I_\tr} &=& \hat{a}(\sigma_\I(i_1),\ldots,\sigma_\I(i_k))
  \end{eqnarray*}
  \begin{eqnarray*}
    (\mathsf{n}[i_1,\ldots,i_k])^{I_\tr} &=& \mathsf{n}_{\sigma_\I(i_1),\ldots,\sigma_\I(i_k)}
    \\
    (x)^{I_\tr} &=& x
    \\
    (f[i_1,\ldots,i_k](t_1,\ldots,t_n))^{I_\tr} &=&
    f_{\sigma_\I(i_1),\ldots,\sigma_\I(i_k)}\bigl(
      (t_1)^{I_\tr},\ldots,(t_n)^{I_\tr}
    \bigr)
    \\
    (m[i_1,\ldots,i_k](t_1,\ldots,t_n)@T)^{I_\tr} &=&
    \hat{m}(\sigma_\I(i_1),\ldots,\sigma_\I(i_k),
      (t_1)^{I_\tr},\ldots,(t_n)^{I_\tr},
      (T)^{I_\tr})
  \end{eqnarray*}
\end{definition}

\begin{example}
  Consider the meta-logic term $t := \mathsf{h}(\mout@a[i],\mathsf{k}[i])$
  and a trace-model $I_\tr$ with $D_T = [1;10]$ and $D_I = [1;3]$
  (which might be relevant if we are considering traces of ten actions
  with three agents) such that $\sigma_I(i)=2$ and $\hat{a}(2)=10$
  and $\hat{\mout}(10)=\mathsf{ok}$ (the message outputted at step 10
  is $\mathsf{ok}$ \adrien{I don't like this. It seems that macro can be interperted as the term we want at any timestamp.}).
  We then have $(t)^I = \mathsf{h}(\mathsf{ok},\mathsf{k}_2)$.
\end{example}

The reason why macros take only one timestamp argument is purely practical:
we have no use for more. At this point one might wonder why we separate
indices and actions given that they are interpreted similarly: it is again
purely practical, we will use them for different purposes, and we will need
less structure on indices than on actions, making reasoning easier on them
(one can simply compare indices, there is no ordering and no predecessor
operation on them).

\begin{definition}
  If $I_\tr$ is a trace-model and $e\in D_\I$,
  $I_\tr[i\mapsto e]$ is the interpretation where $\sigma_\I$ is
  modified so that $\sigma_{\I}(i)=e$.
  We define the translation of a meta-logic formula $\phi$
  into the base logic \emph{term} $(\phi)^{I_\tr}$
  as follows:
  \begin{eqnarray*}
    (\phi\wedge\phi')^{I_\tr} &=& (\phi)^{I_\tr} \stackrel{.}{\wedge} (\phi')^{I_\tr}
    \quad \text{and similarly for other boolean connectives} \\
    (\forall i:\idx. \phi)^{I_\tr} &=&
    \stackrel{.}{\wedge}_{e\in D_\I} (\phi)^{I_\tr[i\mapsto e]} \\
    (\forall \tau:\timestamp. \phi)^{I_\tr} &=&
    \stackrel{.}{\wedge}_{e\in D_\XT} (\phi)^{I_\tr[\tau\mapsto e]} \\
    (\exists i:\idx. \phi)^{I_\tr} &=&
    \stackrel{.}{\vee}_{e\in D_\I} (\phi)^{I_\tr[i\mapsto e]} \\
    (\exists \tau:\timestamp. \phi)^{I_\tr} &=&
    \stackrel{.}{\vee}_{e\in D_\XT} (\phi)^{I_\tr[\tau\mapsto e]} \\
    (i=i')^{I_\tr} &=&
    \left\{\begin{array}{ll}
      \mathsf{true} & \text{if } \sigma_\I(i)=\sigma_\I(i') \\
      \mathsf{false} & \text{otherwise}
    \end{array}\right. \\
    (T = T')^{I_\tr} &=&
    \left\{\begin{array}{ll}
      \mathsf{true} & \text{if } (T)^{I_\tr} = (T')^{I_\tr} \\
      \mathsf{false} & \text{otherwise}
    \end{array}\right.
    \quad\text{ and similarly for $\leq$} \\
    (\happens(T))^{I_\tr} &=& \mathsf{true}
    \text{ if } (T)^{I_\tr} \in H_\XT
    \text{ and } \mathsf{false} \text{ otherwise}
    \\
    (t=t')^{I_\tr} &=& (t)^{I_\tr} \stackrel{.}{=} (t')^{I_\tr}
  \end{eqnarray*}
\end{definition}

\begin{definition}
  A formula $\phi$ of the meta-logic is said to be valid when,
  for any trace-model $I_\tr$, the base logic formula
  $(\phi)^{I_\tr} \sim \mathsf{true}$ is valid.
  (In other words, we have $\M,\sigma\models(\phi)^{I_\tr}\sim\mathsf{true}$
  i.e. the boolean term $(\phi)^{I_\tr}$ is true with overwhelming
  probability in any computational model $\M$ and for any interpretation
  $\sigma$ of the free message variables.\footnote{
    In the tool, we only allow universal quantification over messages, and
  only allow it at toplevel. The validity of such formulas is the same as
  when the variables are left free.})
\end{definition}

\begin{definition}
  A meta-logic formula $\phi$ is a
  logical consequence of a set $S$ of meta-logic formulas
  (noted $S \models \phi$)
  when
  $\M\models(\phi)^I\sim\mathsf{true}$ holds for any $\M$ and $I$ such that
  $\M\models(\psi)^I\sim\mathsf{true}$ holds for all $\psi\in S$.
  \adrien{This definition seems not necessary. We interpret meta-formula as (schemas of) first-order formulas. Hence entailment is exactly first-order logic entailment.}
\end{definition}
