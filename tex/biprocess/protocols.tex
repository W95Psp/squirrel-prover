\section{Protocols}

\subsection{Syntax}

\begin{itemize}
  \item $\N$ names with index arity
  \item $\X$ variables
  \item $\I$ index variables
  \item $\F$ function symbols with usual arity
  \item $\G$ attacker's function symbols with usual arity
  \item $\A$ action symbols with index arity
  \item $\C$ channel names
\end{itemize}

\begin{figure}[h]
  \[
    \begin{array}{rcll}
      t & := & \sfn(i_1 \dots i_n) \mid x \mid \sff(t_1,\dots,t_n) \mid \sfg(t_1,\dots,t_n) & \text{term}
      \\
      tt & := & t \mid \choice(t_1,t_2) \mid \sff(tt_1,\dots,tt_n) \mid \sfg(tt_1,\dots,tt_n) & \text{bi-term}
    \end{array}
  \]
  \caption{Syntax for bi-processes}
  \label{fig:syntax-bi-process}
\end{figure}

Three sorts: $\idx$, $\msg$ and $\bool$.

% We assume that $\F$ contains at least the function symbols (of sort $\bool$): $\true$ and $\false$ (of arity 0) and $\eq$ (of arity 2).

\begin{definition}
An \emph{action} $\alpha = \sfa(i_1,\dots,i_n)$, where $\sfa \in \A$ and $i_1,\dots,i_n \in \I$, is defined by:
\begin{itemize}
  \item a bi-term of sort $\bool$: $\mtest_{\alpha}$ (intuitively, the condition of this action)
  \item a bi-term of sort $\msg$: $\mout_{\alpha}$ (intuitively, the output of this action)
  \item two channel names $\cin_\alpha$ and $\cout_\alpha$ (intuitively, the channels used for the input and the output of this action)
\end{itemize}
where the only variable appearing in $\mtest_{\alpha}$ and $\mout_{\alpha}$ is $x_{\alpha}$ (intuitively, the input of this action).\footnote{TODO - Traiter le cas des variables d'index libres dans $\mtest_{\alpha}$ (try find).}
\end{definition}

\begin{definition}
  A \emph{bi-process} is a (possibly infinite) set of actions equipped with:
  \begin{itemize}
    \item a transitive \emph{sequential dependency} relation $\before$ on actions,
    \item a \emph{conflict} relation $\conflict$ on actions.
  \end{itemize}
  Intuitively, $\alpha\before\beta$ means that $\alpha$ must happen before $\beta$ in any execution and $\alpha\conflict\beta$ means that $\alpha$ and $\beta$ cannot both occur in any execution.
\end{definition}

\begin{example}[Basic Hash]
  \label{ex:basic-hash-bi-process}
  We introduce the bi-process $B$ defined by the following set of actions $$\{\T(i,j),\R_1(ii,jj),\R_2(ii,jj) \mid i,j,ii,jj \in \I\}$$
  equipped with a \emph{conflict} relation $\conflict$ such that $\R_1(ii,jj)\conflict\R_2(ii,jj)$.
  \begin{itemize}
    \item action $\alpha_1 := \T(i,j)$
      \begin{itemize}
        \item $\mtest_{\alpha_1} := \true$
        \item $\mout_{\alpha_1} := \langle n(i,j), \h(\choice(k(i),k'(i)),n(i,j) \rangle$
      \end{itemize}
    \item action $\alpha_2 := \R_1(ii,jj)$
      \begin{itemize}
        \item $\mtest_{\alpha_2} := \eq(\snd(\g(x_{\alpha_2})),  \h(\choice(k(ii),k'(ii)),\fst(\g(x_{\alpha_2})))$
        \item $\mout_{\alpha_2} := \ok$
      \end{itemize}
    \item action $\alpha_3 := \R_2(ii,jj)$
      \begin{itemize}
        \item $\mtest_{\alpha_3} := \noteq (\snd(\g(x_{\alpha_3})),  \h(\choice(k(ii),k'(ii)),\fst(\g(x_{\alpha_3}))))$
        \item $\mout_{\alpha_3} := \error$
      \end{itemize}
  \end{itemize}
\end{example}

\begin{definition}
  Given a bi-process $B$ defined by a set $\{\alpha_i\}_i$ of actions, a sequential dependency relation $\before$ and a conflict relation $\conflict$, a \emph{symbolic trace} is a sequence $\alpha_1 \dots \alpha_n$ made of actions from the set $\{\alpha_i\}_i$ such that:
  \begin{itemize}
    \item for all $1 \leq i < j \leq n$, $\alpha_i \neq \alpha_j$;
    \item for all $1 \leq i < j \leq n$, it is not the case that $\alpha_i \conflict \alpha_j$;
    \item for all $1 \leq i \leq n$, for all $\beta \before \alpha_i$, there exists $1 \leq j < i$ such that $\beta = \alpha_j$.
  \end{itemize}
\end{definition}

\begin{definition}
  Given a symbolic trace $\tr = \alpha_1 \dots \alpha_n$, we define recursively the \emph{frame} $\mouts(\tr)$ of this trace:
  \begin{itemize}
    \item $\mouts(\alpha_1) := \{ \mout_{\alpha_1}\{x_{\alpha_1} \mapsto \varnothing\} \}$
    \item $\forall i, 2 \leq i \leq n, \mouts(\alpha_1 \dots \alpha_i) := \mouts(\alpha_1 \dots \alpha_{i-1}) \cup \{ \mout_{\alpha_{i-1}}\{x_{\alpha_{i-1}} \mapsto \mouts(\alpha_1 \dots \alpha_{i-1})\} \}$
  \end{itemize}
\end{definition}

\begin{definition}
  Given a symbolic trace $\tr = \alpha_1 \dots \alpha_n$, we define:
  $$\mtests_\tr := \mand(\{ \mtest_{\alpha_i}\{x_{\alpha_i}\mapsto\mouts(\alpha_1 \dots \alpha_{i-1})\} \}_{1 \leq i \leq n})$$
\end{definition}

\begin{example}
  \label{ex:basic-hash-trace}
  The sequence $\alpha_1.\alpha_2$ is a symbolic trace of the bi-process defined in \Cref{ex:basic-hash-bi-process}.
  \begin{itemize}
    \item $\mouts(\alpha_1) := \langle n(i,j), \h(\choice(k(i),k'(i)),n(i,j) \rangle$
    \item $\mouts(\alpha_1.\alpha_2) := \langle n(i,j), \h(\choice(k(i),k'(i)),n(i,j) \rangle, \ok$
    \item $\mtests_\tr := \mand(\true, \eq(\snd(\g(\mouts(\alpha_1))), \h(\choice(k(i),k'(i)),\fst(\g(\mouts(\alpha_1)))))$
  \end{itemize}
  Other symbolic traces:
  \begin{itemize}
    \item $\T(i,j).\R_1(ii,jj).\T(i,j').\R_1(ii,jj')$
    \item $\T(i,j).\R_1(ii,jj).\T(i',j').\R_1(ii',jj')$
  \end{itemize}
\end{example}

\begin{example}
  Toy example.
  \begin{itemize}
    \item bi-process $B := \{ \sfa(i) \mid i \in \I \}$ (no conflict nor sequential dependency)
      \begin{itemize}
        \item $\mtest_{\sfa(i)} := \eq(\g(x_{\sfa(i)}), \choice(n(i),m(i)))$
        \item $\mout_{\sfa(i)} := \ok$
      \end{itemize}
    \item $\tr := \sfa(i).\sfa(i')$
    \begin{itemize}
      \item $\mouts(\tr) := \{\ok,\ok\}$
      \item $\mtests_\tr := \mand(\eq(\g(), \choice(n(i),m(i))), \eq(\g(\{\ok\}), \choice(n(i'),m(i'))))$
    \end{itemize}
  \end{itemize}
\end{example}

\bigskip
\noindent
We use the notation $(\_)^L$ and $(\_)^R$ to denote the left and right projections (defined as usual), for example:
\begin{itemize}
  \item $(\mtest_{\alpha})^L$ and $(\mtest_{\alpha})^R$
  \item $(\mout_{\alpha})^L$ and $(\mout_{\alpha})^R$
  \item $(\mtests_{\tr})^L$ and $(\mtests_{\tr})^R$
  \item $(\mouts_{\tr})^L$ and $(\mouts_{\tr})^R$
\end{itemize}

\subsection{Semantics}

See Adrien's thesis, section 2.3:
\begin{itemize}
  \item term interpertation
  \item computational model
  \item we extend $\sigma$ to a valuation from $\X \cup \I$ to the appropriate domain ($\D_\msg$, $\D_\bool$ or $\D_\idx$.)
  \item the domain $\D_\idx$ is interpreted in a finite subset of $\mathbb{N}$
\end{itemize}
