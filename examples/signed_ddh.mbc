hash h

abstract exp : message -> message -> message
abstract g : message

abstract ok : message
abstract ko : message

name kP : message
name kS : message

mutable keyS : index -> message
mutable keyP : index -> message

channel cP
channel cS

name a : index -> message
name b : index -> message

term test : boolean = zero

process P(i:index) =
  out(cP, exp(g,a(i)));
  in(cP, t);
  let sS = fst(t) in
  let hash_share = snd(t) in
  if h(<exp(g,a(i)),snd(fst(t))>,kS) = snd(t) then
    (keyP(i) := <exp(g,a(i)),snd(fst(t))>;
     out(cP, h(<exp(g,a(i)),snd(fst(t))>,kP))
      )
  else
     null

process S(i:index) =
  in(cS, sP);
  out(cS, < <sP,exp(g,b(i))>, h(<sP,exp(g,b(i))>,kS)>);
  in(cS, hash_shares);
  if hash_shares = h(<sP,exp(g,b(i))>,kP) then
    (keyS(i) := <sP,exp(g,b(i))>;
     out(cS,ok);
     in(cP, challenge);
     try find j such that sP = exp(g,a(j)) in
     out(cP, ok)
     else
     out(cP, diff(ok,ko))
      )
   else null


system (!_i P(i) | !_j S(j)).

(* goal used to prove that S1 is never executed, no diff *)
goal unreachS1 :
forall (r:index),
cond@S1(r) =>
   exists (s:index),
   input@S(r) = exp(g,a(s)).
Proof.
  simpl.
       expand cond@S1(r).
       simpl.
   introsleft H0.
  euf M0.
  case H0.
  exists i.
  exists i.
Qed.

(* Prove that the condition of A does not give any information to the attacker,
by proving that it is equivalent to a trivial formula that the attacker can
compute. It is a bit troublesome, because the formula depends on ks, which needs
to disapear. If we used classical assymetric signature scheme, the issue wowould
disappear.
*)
goal A_cond_useless :
 forall (i:index),
       (cond@A(i)  =>
           (

	     (forall (j1:index), input@S(j1) <> output@P(i)
	      ||snd(input@A(i)) <> snd(output@S(j1))
	      || snd(fst(input@A(i))) <> exp(g,b(j1))
	       )
	     )
	 )
	      &&
	 (
	   (forall (j1:index), input@S(j1) <> output@P(i)
	    ||snd(input@A(i)) <> snd(output@S(j1))
	    || snd(fst(input@A(i))) <> exp(g,b(j1))
	    )
	     =>
	     cond@A(i)

	  )
	      .
 Proof.
intro.
split.


expand cond@A(i).
notleft H0.

expand cond@A(i).

euf M0.
apply H0 to j.
case H1.
Qed.


(* Prove that the condition of P1 does not give any information to the attacker,
by proving that it is equivalent to a trivial formula that the attacker can
compute. It is a bit troublesome, because the formula depends on ks, which needs
to disapear. If we used classical assymetric signature scheme, the issue wowould
disappear.
*)
goal P1_cond_useless :
 forall (i:index),
       (cond@P1(i)  =>
           not(

	     (forall (j1:index), input@S(j1) <> output@P(i)
	      ||snd(input@P1(i)) <> snd(output@S(j1))
	      || snd(fst(input@P1(i))) <> exp(g,b(j1))
	       )
	     )
	 )
	      &&
	 (
	   not(forall (j1:index), input@S(j1) <> output@P(i)
	    ||snd(input@P1(i)) <> snd(output@S(j1))
	    || snd(fst(input@P1(i))) <> exp(g,b(j1))
	    )
	     =>
	     cond@P1(i)

	  )
	      .
 Proof.
intro.
split.


expand cond@P1(i).
introsleft H0.
euf M0.
apply H0 to j.
case H1.

notleft H0.
expand cond@P1(i).
Qed.


equiv [left] [right] unreach.
Proof.
   case t.
   cycle 4.

   expand frame@S3(j).
   expand exec@S3(j).
   fa 0.
   noif 1.

   (* unreachability of the left system - using unreach *)
   simpl.
   expand cond@S3(j).
   executable pred(S3(j)).
   depends S1(j), S3(j).
   apply H2 to S1(j).
   apply unreachS1 to j.
   apply H1 to s.
   fa 1.
   induc.

   expand frame@A(i).
	    expand output@A(i).
	    help.

   expand exec@A(i).
	    expand cond@A(i).

   equivalent
      cond@A(i),
	   (forall (j1:index), input@S(j1) <> output@P(i)
 ||snd(input@A(i)) <> snd(output@S(j1))
 || snd(fst(input@A(i))) <> exp(g,b(j1))
     ).

     simpl.
     nosimpl(apply A_cond_useless to i).
     nosimpl(split).
     assumption.
     assumption.

     fa 0. fa 1. fa 2. fa 2.

(* We should be able to close this using some magical dup/fa* tactic.. *)

      admit. admit.


   expand frame@P(i).
	    expand output@P(i).
   expand exec@P(i).
	    expand cond@P(i).

   (* We should be able to close this with fresh a(i), fa, and induction (containing exec@predP(i)) *)
      admit.
 expand frame@S(j).
	    expand output@S(j).
   expand exec@S(j).
	    expand cond@S(j).
   (* We should be able to close this with fresh b(j), fa, and induction (containing exec@predP(i)) *)

      admit.


   expand frame@P1(i).

   expand exec@P1(i).


   equivalent
      cond@P1(i),
	   not(forall (j1:index), input@S(j1) <> output@P(i)
 ||snd(input@P1(i)) <> snd(output@S(j1))
 || snd(fst(input@P1(i))) <> exp(g,b(j1))
     ).

      simpl.
     nosimpl(apply P1_cond_useless to i).
     nosimpl(split).
     assumption.
     assumption.

      fa 0. fa 1.
  expand output@P1(i).
(* PRF ? *)

      admit.
 expand frame@S1(j).
	    expand output@S1(j).
   expand exec@S1(j).
	    expand cond@S1(j).
   (* Symmetric case of A, to handle similarly. *)
admit.
admit.

      Qed.
