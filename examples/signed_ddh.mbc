hash h

abstract ok : message
abstract ko : message

name kP : message
name kS : message

mutable keyS : index -> message
mutable keyP : index -> message

channel cP
channel cS

name a : index -> message
name b : index -> message

term test : boolean = zero

process P(i:index) =
  out(cP, g^a(i));
  in(cP, t);
  let sS = fst(t) in
  let hash_share = snd(t) in
  if h(<g^a(i),snd(fst(t))>,kS) = snd(t) then
    keyP(i) := <g^a(i),snd(fst(t))>;
    out(cP, h(<g^a(i),snd(fst(t))>,kP))
  else null

process S(i:index) =
  in(cS, sP);
  out(cS, < <sP,g^b(i)>, h(<sP,g^b(i)>,kS)>);
  in(cS, hash_shares);
  if hash_shares = h(<sP,g^b(i)>,kP) then
    keyS(i) := <sP,g^b(i)>;
    out(cS,ok);
    in(cP, challenge);
    try find j such that sP = g^a(j) in
      out(cP, ok)
    else
      out(cP, diff(ok,ko))
  else null

system (!_i P(i) | !_j S(j)).

(* We prove several lemmas, characterizing when a action's conditions passes.
   The characterization is expressed as a property of the trace that the attacker
   already has, showing that the condition does not bring him extra knowledge.

   Prove that the condition of A does not give any information to the attacker,
   by proving that it is equivalent to a trivial formula that the attacker can
   compute. It is a bit troublesome, because the formula depends on ks, which needs
   to disappear. We would not have this issue if we used a classical asymmetric
   signature scheme. *)

(* Show that condition S1 implies the next one. *)
goal S1_charac :
  forall (r:index),
  cond@S1(r) =>
  exists (s:index),
  input@S(r) = g^a(s).
Proof.
  simpl.
  expand cond@S1(r).
  introsleft H0. (* TODO should be done as part of expansion *)
  euf M0.
  exists i.
Qed.

equiv unreach.
    Proof.
   enrich kP; enrich kS; enrich seq(i->g^a(i));enrich seq(i->g^b(i)).

    induction t.

   expand frame@init.
   expand exec@init.

   expand frame@P(i); expand output@P(i); expand exec@P(i); expand cond@P(i).
    fa 5; fa 6; fa 4. fa 6.
    expand  seq(i->g^a(i)), i.
    assumption.

   expand frame@P1(i); expand exec@P1(i); expand output@P1(i); expand cond@P1(i).
    fa 5; fa 4. fa 7; fa 7. dup 8. fa 5. fa 6. dup 6.
    fa 5. fa 9. dup 5. fa 8. fa 9; fa 9. dup 9.
    expand  seq(i->g^a(i)), i.
    assumption.


   expand frame@A(i); expand output@A(i); expand exec@A(i); expand cond@A(i).
    fa 5.  fa 6. fa 6.  fa 4. dup 5. fa 7;fa 7; fa 7; fa 7.
    fa 8 ; fa 8.
    fa 10.
    dup 10.
    dup 6.
    expand  seq(i->g^a(i)), i.
    dup 8; dup 7.
    assumption.



   expand frame@S(j); expand output@S(j); expand exec@S(j); expand cond@S(j).

   fa 4;fa 5; fa 5; fa 6; fa 6; fa 7. fa 7. fa 7. fa 9. fa 9.
    dup 7. dup 8.
    expand  seq(i->g^b(i)), j.

    assumption.


  expand frame@S1(j).
  expand output@S1(j).
  expand exec@S1(j).
  expand cond@S1(j).
  fa 4.
  fa 5. fa 7.
  dup 5. fa 7. fa 7.
  fa 8.
  dup 7.  dup 8.
  fa 5.
  fa 5.
  expand  seq(i->g^b(i)), j.
  dup 9. dup 5.
  assumption.
  expand frame@S2(j,j1).
  expand output@S2(j,j1).
  expand exec@S2(j,j1).
  expand cond@S2(j,j1).
  fa 4; fa 5. fa 7. fa 8. fa 8. fa 9. dup 9; dup 5.
  expand  seq(i->g^a(i)), j1.
  assumption.


   expand frame@S3(j).
   expand exec@S3(j).


   (* Unreachability of S3  *)
   equivalent cond@S3(j), False.
   expand cond@S3(j).
   executable pred(S3(j)).
   depends S1(j), S3(j).
   apply H1 to S1(j).
   apply S1_charac to j.
   apply H0 to s.

   fa 5.
   noif 6. simpl.
   fa 4.
   assumption.


   expand frame@A1(j); expand output@A1(j); expand exec@A1(j); expand cond@A1(j).

    fa 5; fa 6; dup 6. fa 4;fa 5; fa 5; fa 6; fa 6. dup 5. dup 5.
    expand  seq(i->g^b(i)), j.
   assumption.

Qed.
