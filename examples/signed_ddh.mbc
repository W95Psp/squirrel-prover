hash h

abstract exp : message -> message -> message
abstract g : message

abstract ok : message
abstract ko : message

name kP : message
name kS : message

mutable keyS : index -> message
mutable keyP : index -> message

channel cP
channel cS

name a : index -> message
name b : index -> message

term test : boolean = zero

process P(i:index) =
  out(cP, exp(g,a(i)));
  in(cP, t);
  let sS = fst(t) in
  let hash_share = snd(t) in
  if h(<exp(g,a(i)),snd(fst(t))>,kS) = snd(t) then
    keyP(i) := <exp(g,a(i)),snd(fst(t))>;
    out(cP, h(<exp(g,a(i)),snd(fst(t))>,kP))
  else null

process S(i:index) =
  in(cS, sP);
  out(cS, < <sP,exp(g,b(i))>, h(<sP,exp(g,b(i))>,kS)>);
  in(cS, hash_shares);
  if hash_shares = h(<sP,exp(g,b(i))>,kP) then
    keyS(i) := <sP,exp(g,b(i))>;
    out(cS,ok);
    in(cP, challenge);
    try find j such that sP = exp(g,a(j)) in
      out(cP, ok)
    else
      out(cP, diff(ok,ko))
  else null

system (!_i P(i) | !_j S(j)).

(* We prove several lemmas, characterizing when a action's conditions passes.
   The characterization is expressed as a property of the trace that the attacker
   already has, showing that the condition does not bring him extra knowledge.

   Prove that the condition of A does not give any information to the attacker,
   by proving that it is equivalent to a trivial formula that the attacker can
   compute. It is a bit troublesome, because the formula depends on ks, which needs
   to disappear. We would not have this issue if we used a classical asymmetric
   signature scheme. TODO I don't understand this comment: what is ks ? *)

(* Correspondence property for S1, proved directly on both sides. *)
goal S1_charac :
  forall (r:index),
  cond@S1(r) =>
  exists (s:index),
  input@S(r) = exp(g,a(s)).
Proof.
  simpl.
  expand cond@S1(r).
  introsleft H0. (* TODO should be done as part of expansion *)
  euf M0.
  exists i.
Qed.

goal A_charac :
 forall (i:index),
 (* TODO add _ <=> _ syntax for equivalences *)
 (cond@A(i) =>
   (forall (j1:index),
    input@S(j1) <> output@P(i) ||
    snd(input@A(i)) <> snd(output@S(j1)) ||
    snd(fst(input@A(i))) <> exp(g,b(j1))))
 &&
 ((forall (j1:index),
   input@S(j1) <> output@P(i) ||
   snd(input@A(i)) <> snd(output@S(j1)) ||
   snd(fst(input@A(i))) <> exp(g,b(j1)))
  =>
  cond@A(i)).
Proof.
  intro; expand cond@A(i); split.

  notleft H0. (* TODO rename to elim (Coq-style) or absurd ? *)

  euf M0.
  apply H0 to j. (* TODO this does not look like apply to me: rename ? *)
  case H1.
Qed.

goal P1_charac :
  forall (i:index),
  ((cond@P1(i) =>
    not (forall (j1:index),
         input@S(j1) <> output@P(i) ||
         snd(input@P1(i)) <> snd(output@S(j1)) ||
         snd(fst(input@P1(i))) <> exp(g,b(j1))))
   &&
   (not (forall (j1:index),
         input@S(j1) <> output@P(i) ||
         snd(input@P1(i)) <> snd(output@S(j1)) ||
         snd(fst(input@P1(i))) <> exp(g,b(j1)))
    =>
    cond@P1(i))).
Proof.
  intro; expand cond@P1(i); split.

  introsleft H0.
  euf M0.
  apply H0 to j.
  case H1.

  notleft H0.
Qed.

equiv [left] [right] unreach.
Proof.
   case t.

   expand frame@init.
   refl.

   cycle 4.

   expand frame@S3(j).
   expand exec@S3(j).
   fa 0.
   noif 1.

   (* Unreachability of S3 in the left system TODO why left ? *)
   simpl.
   expand cond@S3(j).
   executable pred(S3(j)).
   depends S1(j), S3(j).
   apply H2 to S1(j).
   apply S1_charac to j.
   apply H1 to s.

   fa 1.
   induc.

   expand frame@A(i); expand output@A(i); expand exec@A(i).
   equivalent
     cond@A(i),
     (forall (j1:index),
      input@S(j1) <> output@P(i) ||
      snd(input@A(i)) <> snd(output@S(j1)) ||
      snd(fst(input@A(i))) <> exp(g,b(j1))).

     nosimpl(apply A_charac to i).
     split; assumption. (* TODO auto simpl after split should do the assumption *)
   fa 0. fa 1. fa 2. fa 2.
   (* We should be able to close this using some magical dup/fa* tactic..
      TODO to justify this we need j1<A(i). *)
   admit 1.
   induc.

   admit.

   expand frame@P(i).
   expand output@P(i).
   expand exec@P(i).
   expand cond@P(i).
   (* We should be able to close this with fresh a(i), fa, dup on exec@predP(i). *)
   fa 0. fa 1. fa 3.
   admit 1.
   fa 1. fa 1. admit 1.
   induc.
    
   expand frame@S(j).
   expand output@S(j).
   expand exec@S(j).
   expand cond@S(j).
   (* We should be able to close this with fresh b(j), fa, and induction (containing exec@predP(i)) *)
   fa 0. fa 1. repeat (fa 2).
   admit 1. admit 1.
   fa 1. fa 1.
   admit 1.
   fa 2.
   admit 1.
   induc.
    
   expand frame@P1(i).
   expand exec@P1(i).
   equivalent
     cond@P1(i),
     not(forall (j1:index), input@S(j1) <> output@P(i) ||
     snd(input@P1(i)) <> snd(output@S(j1)) ||
     snd(fst(input@P1(i))) <> exp(g,b(j1))).
     simpl.
     nosimpl(apply P1_charac to i).
     nosimpl(split).
     assumption.
     assumption.
  fa 0. fa 1.
  expand output@P1(i).
  (* PRF ? *)
  admit.
    
  expand frame@S1(j).
  expand output@S1(j).
  expand exec@S1(j).
  expand cond@S1(j).
  (* Symmetric case of A, to handle similarly. *)
  admit.

  admit.

Qed.
