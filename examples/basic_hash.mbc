hash h

abstract ok:message
abstract ko:message

name key : index->message

channel cT
channel cR

process tag(i:index) =
  new nT;
  out(cT, <nT, h(nT,key(i))>)

process reader(j:index) =
  in(cT,x);
  try find i such that snd(x) = h(fst(x),key(i)) in
    out(cR,ok)
  else
    out(cR,ko)

system ((!_j R: reader(j)) | (!_i !_k T: tag(i))).

(* TODO In the next lemma, it would be more natural to write
 * something like happens(ACTION) rather than ACTION=ACTION. *)
goal wa :
  forall (i:index, j:index),
  happens(R(j,i)) =>
  exists (ii:index,k:index),
  T(ii,k) <= R(j,i) &&
  fst(input@R(j,i)) = nT(ii,k).
Proof.
 euf 0. 
 exists i, k.
Qed.
