hash h

abstract ok:message
abstract ko:message

name key : index->message

axiom pairs_surj : forall (x:message),
x = <fst(x),snd(x)>

channel cT
channel cR


process tag(i:index) =
  new nT;
  out(cT, <nT, h(nT,key(i))>)

process reader(j:index) =
  in(cT,x);
  try find i such that snd(x) = h(fst(x),key(i)) in
    out(cR,ok)
  else
    out(cR,ko)

system ((!_j R: reader(j)) | (!_i !_k T: tag(i))).

(* TODO In the next lemma, it would be more natural to write
 * something like happens(ACTION) rather than ACTION=ACTION.
 * This could be left implicit since ACTION occurs in the
 * rest of the formula. The only cases I can think of where
 * the implicit treatment might not work is that of unreachability
 * statements: forall k, not(happens(ACTION)). *)
(* TODO we should not get a type error when using an inexistent
 *   action name *)
goal wa :
  forall (i:index, j:index),
  output@R(j,i) = output@R(j,i) =>
  exists (ii:index,k:index),
  T(ii,k) <= R(j,i) &&
  input@R(j,i) = output@T(ii,k).
Proof.
 euf 1. 
 exists i1, k.
 assert (input@R(j,i) =<nT(i1,k),h(nT(i1,k), key(i1))>).
 assert(key(i)=key(i1)).
 admit.
 apply pairs_surj to input@R(j,i).
Qed.

(* pour finir, je veux faire du remplacement d'Ã©galite et du FA *)
(* comment lui dire *)
