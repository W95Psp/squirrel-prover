hash h

abstract ok : message
abstract ko : message

name kP : message
name kS : message

channel cP
channel cS

name a : index -> message
name b : index -> message
name k : index -> index -> message

process P(i:index) =
  out(cP, g^a(i));
  in(cP, t);
  let hash_share = snd(t) in
  let gb = snd(fst(t)) in
  if h(<g^a(i),gb>,kS) = snd(t) then
    out(cP, h(<g^a(i),gb>,kP));
    in(cP, challenge);
    try find j such that gb = g^b(j) in
      out(cP, ok)
    else
      out(cP, diff(ok,ko))
  else null

process S(i:index) =
  in(cS, ga);
  out(cS, < <ga,g^b(i)>, h(<ga,g^b(i)>,kS)>);
  in(cS, hash_shares);
  if hash_shares = h(<ga,g^b(i)>,kP) then
    out(cS,ok);
    in(cS, challenge);
    try find l such that ga = g^a(l) in
      out(cS, ok)
    else
      out(cS, diff(ok,ko))
  else null

system (!_i P(i) | !_j S(j)).

(* We prove several lemmas, characterizing when a action's conditions passes.
   The characterization is expressed as a property of the trace that the attacker
   already has, showing that the condition does not bring him extra knowledge.

   Prove that the condition of A does not give any information to the attacker,
   by proving that it is equivalent to a trivial formula that the attacker can
   compute. It is a bit troublesome, because the formula depends on ks, which needs
   to disappear. We would not have this issue if we used a classical asymmetric
   signature scheme. *)


equiv unreach.
Proof.

induction t.

expandall.
fa 1.
fa 2.
fa 2.
fresh 2.
???

Qed.
