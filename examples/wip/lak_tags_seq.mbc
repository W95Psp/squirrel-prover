hash h

abstract ok:message
abstract ko:message

abstract tag1:message
abstract tag2:message
axiom tags_neq : tag1 <> tag2

name key : index->message
name key': index->index->message

channel cT
channel cR

process tag(i:index,k:index) =
  new nT;
  in(cR,nR);
  let m2 = h(<<nR,nT>,tag1>,diff(key(i),key'(i,k))) in
  out(cT,<nT,m2>);
  in(cR,m3);
  if m3 = h(<<m2,nR>,tag2>,diff(key(i),key'(i,k))) then
    out(cT,ok)
  else
    out(cT,ko)

process reader(j:index) =
  new nR;
  out(cR,nR);
  in(cT,x);
  if exists (i,k:index),
     snd(x) = h(<<nR,fst(x)>,tag1>,diff(key(i),key'(i,k)))
  then
    out(cR, try find i,k such that
              snd(x) = h(<<nR,fst(x)>,tag1>,diff(key(i),key'(i,k)))
            in
              h(<<snd(x),nR>,tag2>,diff(key(i),key'(i,k))))
  else
    out(cR,ko)

system ((!_j R: reader(j)) | (!_i !_k T: tag(i,k))).

goal wa_R1: forall j:index,
  (exists (i,k:index),
   snd(input@R1(j)) =
   h(<<nR(j),fst(input@R1(j))>,tag1>,diff(key(i),key'(i,k))))
  <=>
  (exists (i,k:index),
   T(i,k) < R1(j) &&
   snd(output@T(i,k)) = snd(input@R1(j)) &&
   fst(output@T(i,k)) = fst(input@R1(j)) &&
   R(j) < T(i,k) && input@T(i,k) = output@R(j)).

Proof.
intros; split.
(* cond => wa *)
apply tags_neq; project.
(* LEFT *)
euf M0.
exists i,k1.
assert input@T(i,k1)=nR(j).
fresh M3.
depends R(j),R2(j).
(* RIGHT *)
euf M0.
exists i,k.
assert input@T(i,k)=nR(j).
fresh M3.
depends R(j),R2(j).
(* wa => cond *)
exists i,k.
Qed.

goal wa_R2: forall j:index,
  (exists (i,k:index),
   snd(input@R2(j)) =
   h(<<nR(j),fst(input@R2(j))>,tag1>,diff(key(i),key'(i,k))))
  <=>
  (exists (i,k:index),
   T(i,k) < R2(j) &&
   snd(output@T(i,k)) = snd(input@R2(j)) &&
   fst(output@T(i,k)) = fst(input@R2(j)) &&
   R(j) < T(i,k) && input@T(i,k) = output@R(j)).

Proof.
intros; split.
(* cond => wa *)
apply tags_neq; project.
(* LEFT *)
euf M0.
exists i,k1.
assert input@T(i,k1)=nR(j).
fresh M3.
depends R(j),R1(j).
(* RIGHT *)
euf M0.
exists i,k.
assert input@T(i,k)=nR(j).
fresh M3.
depends R(j),R1(j).
(* wa => cond *)
exists i,k.
Qed.

goal [left] wa_R1_left: forall (i,j:index),
  snd(input@R1(j)) =
  h(<<nR(j),fst(input@R1(j))>,tag1>,key(i))
  <=>
  exists k:index,
  T(i,k) < R1(j) &&
  snd(output@T(i,k)) = snd(input@R1(j)) &&
  fst(output@T(i,k)) = fst(input@R1(j)) &&
  R(j) < T(i,k) && input@T(i,k) = output@R(j).

Proof.
intros.
apply tags_neq.
euf M0.
exists k.
assert input@T(i,k)=nR(j).
fresh M3.
depends R(j),R2(j).
Qed.

goal [right] wa_R1_right: forall (i,j,k:index),
  snd(input@R1(j)) =
  h(<<nR(j),fst(input@R1(j))>,tag1>,key'(i,k))
  <=>
  T(i,k) < R1(j) &&
  snd(output@T(i,k)) = snd(input@R1(j)) &&
  fst(output@T(i,k)) = fst(input@R1(j)) &&
  R(j) < T(i,k) && input@T(i,k) = output@R(j).

Proof.
intros.
apply tags_neq.
euf M0.
assert input@T(i,k)=nR(j).
fresh M3.
depends R(j),R2(j).
Qed.


equiv unlinkability.
Proof.

enrich seq(j -> nR(j)).
enrich seq(i,k -> nT(i,k)).
enrich seq(i,k -> h(<<input@T(i,k),nT(i,k)>,tag1>,diff(key(i),key'(i,k)))).
enrich seq(i,j,k -> h(<<snd(input@R1(j)),nR(j)>,tag2>,diff(key(i),key'(i,k)))).

induction t.

admit. (* TODO lak-prelim *)

(* Case R: OK *)
expand seq(j->nR(j)), j.

(* Case R1: OK *)
expand frame@R1(j); expand exec@R1(j).
expand cond@R1(j); expand output@R1(j).

equivalent
  (exists (i,k:index),
   snd(input@R1(j)) =
   h(<<nR(j),fst(input@R1(j))>,tag1>,diff(key(i),key'(i,k)))),
  (exists (i,k:index),
   T(i,k) < R1(j) &&
   snd(output@T(i,k)) = snd(input@R1(j)) &&
   fst(output@T(i,k)) = fst(input@R1(j)) &&
   R(j) < T(i,k) && input@T(i,k) = output@R(j)).

apply wa_R1 to j.

equivalent
  (if exec@pred(R1(j)) &&
      exists (i,k:index),
      (((T(i,k) < R1(j) && snd(output@T(i,k)) = snd(input@R1(j))) &&
      fst(output@T(i,k)) = fst(input@R1(j))) &&
      R(j) < T(i,k) && input@T(i,k) = output@R(j))
   then (try find i,k such that
           snd(input@R1(j)) =
           h(<<nR(j),fst(input@R1(j))>,tag1>,diff(key(i),key'(i,k)))
         in
           h(<<snd(input@R1(j)),nR(j)>,tag2>,diff(key(i),key'(i,k))))),
  (if exec@pred(R1(j)) &&
      exists (i,k:index),
      (T(i,k) < R1(j) && snd(output@T(i,k)) = snd(input@R1(j)) &&
      fst(output@T(i,k)) = fst(input@R1(j)) &&
      R(j) < T(i,k) && input@T(i,k) = output@R(j))
   then (try find i,k such that
          (exec@pred(R1(j)) &&
	   (T(i,k) < R1(j) && snd(output@T(i,k)) = snd(input@R1(j)) &&
	    fst(output@T(i,k)) = fst(input@R1(j)) &&
	    R(j) < T(i,k) && input@T(i,k) = output@R(j)))
         in
	   if exec@pred(R1(j))
	   then h(<<snd(input@R1(j)),nR(j)>,tag2>,diff(key(i),key'(i,k))))).
fa.
exists i,k.
exists i,k.
project.
(* LEFT *)
fa.
apply wa_R1_left to i1,j.
apply H1.
exists k.
yesif.
(* RIGHT *)
fa.
apply wa_R1_right to i1,j,k1.
apply H1.
yesif.

fa 5. fadup 4.
fa 6. fadup 6.
fa 6. fadup 6.
expand seq(i,j,k->h(<<snd(input@R1(j)),nR(j)>,tag2>,
                         diff(key(i),key'(i,k)))), i,j,k.

(* Case R2: OK *)
expand frame@R2(j); expand exec@R2(j).
expand cond@R2(j); expand output@R2(j).

equivalent
  (exists (i,k:index),
   snd(input@R2(j)) =
   h(<<nR(j),fst(input@R2(j))>,tag1>,diff(key(i),key'(i,k)))),
  (exists (i,k:index),
   T(i,k) < R2(j) &&
   snd(output@T(i,k)) = snd(input@R2(j)) &&
   fst(output@T(i,k)) = fst(input@R2(j)) &&
   R(j) < T(i,k) && input@T(i,k) = output@R(j)).

apply wa_R2 to j.

fadup 4.

(* Case T: OK *)
expand seq(i,k->nT(i,k)),i,k.
expand seq(i,k->h(<<input@T(i,k),nT(i,k)>,tag1>,diff(key(i),key'(i,k)))),i,k.

(* Case T1: TODO *)
expand frame@T1(i,k); expand exec@T1(i,k).
equivalent exec@pred(T1(i,k)) && cond@T1(i,k),
  exec@pred(T1(i,k)) &&
  exists j:index,
  R1(j) < T1(i,k) &&
  input@T1(i,k) = output@R1(j) &&
  T(i,k) < R1(j) &&
  fst(input@R1(j)) = fst(output@T(i,k)) &&
  snd(input@R1(j)) = snd(output@T(i,k)) &&
  R(j) < T(i,k) &&
  input@T(i,k) = output@R(j).

expand cond@T1(i,k); split.

(* cond => honest *)
expand m2(i,k)@T1(i,k).
apply tags_neq; project.
(* LEFT *)
euf M0.
assert R1(j) < T1(i,k).
  case H1.
  depends T(i,k),T1(i,k).
assert cond@R1(j).
  executable pred(T1(i,k)).
  apply H2 to R1(j).
  expand exec@R1(j).
assert snd(input@R1(j)) = h(<<input@T(i,k),nT(i,k)>,tag1>,key(i)).
assert nR(j) = input@T(i,k).
expand cond@R1(j).
euf M5.
(* ??? *)
admit.
(* RIGHT *)
admit.

(* honest => cond *)
case output@R1(j).
expand m2(i,k)@T1(i,k).
project; euf M4.
false_left. false_left.
apply H1 to i,k.

fa 5. fa 6. 
fadup 4.

(* Case T2: TODO *)
expand frame@T2(i,k); expand exec@T2(i,k).
equivalent exec@pred(T2(i,k)) && cond@T2(i,k),
  exec@pred(T2(i,k)) &&
  exists j:index,
  R1(j) < T2(i,k) &&
  input@T2(i,k) = output@R1(j) &&
  T(i,k) < R1(j) &&
  fst(input@R1(j)) = fst(output@T(i,k)) &&
  snd(input@R1(j)) = snd(output@T(i,k)) &&
  R(j) < T(i,k) &&
  input@T(i,k) = output@R(j).

expand cond@T2(i,k); split.

(* cond => honest *)
expand m2(i,k)@T2(i,k).
apply tags_neq; project.
(* LEFT *)
admit.
(* RIGHT *)
admit.

(* honest => cond *)
admit.

fa 5. fa 6. 
fadup 4.
Qed.
