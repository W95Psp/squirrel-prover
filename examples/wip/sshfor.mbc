(* Second part of the proof of ssh with a modified agent forwarding. It
corresponds to the security a the forwarded SSH key exchange, but with oracles
that allow to simulate all other forwarded SSH login and previous SSH logins.
*)

abstract ok : message
abstract ko : message
abstract forwarded : message
abstract reqsign : message
abstract anssign : message

name kP : message
name kS : message

mutable keyS : index -> message
mutable keyP : index -> message

channel cP
channel cS

name ake1 : index -> message
name bke1 : index -> message
name ake11 : message
name bke11 : message
name k11 : message


name a1 : message
name b1 : message
name c11 : message
name a : index -> message
name b : index -> message
name k : index -> index -> message

signature enc,checkdec,pke
abstract dec : message -> message -> message

axiom [none,auth] encdec : forall (x1:message), dec(enc(x1,k11),pke(k11)) =x1

abstract h : message -> message

axiom [none,auth] collres : forall (x1,x2:message), h(x1) = h(x2) => x1 = x2
axiom [none,auth] hashnotfor : forall (x1,x2:message), h(x1) <> <forwarded,x2>


axiom DDHinj : forall (x1,x2:message), x1 <> x2 => g^x1 <> g^x2
axiom DDHcommut : forall (x1,x2:message), g^x1^x2 = g^x2^x1


signature sign,checksign,pk with oracle forall (m:message,sk:message)
(sk <> kP
 || exists (i:index, x1:message, x2:message) m=<forwarded, h(<<g^a(i),x1>,x2>)> (* O_FPS *)
 || exists (i:index, x1:message, x2:message) m=h(<<g^ake1(i),x1>,x2>) (* O_KE1 *)
 )
  &&
(sk <> kS
 || exists (i:index, x1:message, x2:message) m=<forwarded, h(<<x1,g^b(i)>,x2>)> (* O_FPS *)
 || exists (i:index, x1:message, x2:message) m=h(<<x1,g^bke1(i)>,x2>) (* O_KE1 *)
)


(** We first present the general ssh process. *)

 process P1FA =
  in(cP,gB);
  out(cP,ok);
 (* begin P1 *)
  in(cP,t);
  let sidP = h(<<g^ake11,gB>,pke(k11)>) in
  let pkS = fst(t) in
  if pkS = pk(kS) && checksign(snd(t),pkS) = sidP then
       out(cP, enc(sign(sidP,kP),pke(k11)));
           (* end P1 *)

           (* begin FA *)
           !_i (
                 in(cP,y);
                 let x = dec(y,pke(k11)) in
                 if checkdec(y,pke(k11)) = x then
                 if fst(x) = reqsign then
                 out(cP, enc(<anssign, sign(<forwarded,snd(x)>,kP)>,pke(k11)))
               )

process PDIS =
 (* begin S0 *)
  in(cS, gP0);
  out(cS, g^bke11);
  (* end S0 *)
  (* begin S1 *)
  in(cS,garbage);
  let sidS0 = h(<<gP0,g^bke11>,pke(k11)>) in
  out(cS, <<pk(kS),g^bke11>,sign(sidS0, kS)>);
  in(cS, encP );
  if checksign(dec(encP,gP0^bke11),pk(kP)) = sidS0 then
      out(cS,ok);
  (* end S1 *)
 (* begin Pdis0 *)
      out(cP, g^a1);
      in(cP, gB);
 (* end Pdis0 *)
      out(cP,ok);
 (* begin Pdis1 *)

      in(cP,t);
      let sidP = h(<<g^a1,gB>,gB^a1>) in
      let pkS = fst(t) in
      if pkS = pk(kS) && checksign(snd(t),pkS) = sidP then
          out(cP, enc( <reqsign, sidP>,k11));
		in(cP, signans);
  		  let y = dec(signans,pke(k11)) in
                if checkdec(signans,pke(k11)) = y then
	          if fst(y) = anssign then
                 Pok: out(cP, enc(snd(y),gB^a1))


process SDIS =
 (* begin SDIS0 *)
  in(cS, gP);
  out(cS, g^b1);
 (* end SDIS0 *)

  (* begin SDIS1 *)
  in(cS,garbage);
  let sidS = h(<<gP,g^b1>,gP^b1>) in
  out(cS, <<pk(kS),g^b1>,sign(sidS, kS)>);
  in(cS, encP );
  if checksign(dec(encP,gP^b1),pk(kP)) = <forwarded,sidS> then
    Sok : out(cS,ok)

system [fullSSH] ( P1FA | SDIS | PDIS).

(* Now the process for the secrecy *)

 process P1FADDH =
  in(cP,gB);
  out(cP,ok);
 (* begin P1 *)
  in(cP,t);
  let sidP = h(<<g^ake11,gB>,pke(k11)>) in
  let pkS = fst(t) in
  if pkS = pk(kS) && checksign(snd(t),pkS) = sidP then
       out(cP, enc(sign(sidP,kP),k11));
           (* end P1 *)

           (* begin FA *)
           !_i (
                in(cP,y);
                 let x2= dec(y,pke(k11)) in
                 if checkdec(y,pke(k11)) = x2 then
                 if fst(x2) = reqsign then
                 out(cP, enc(<anssign, sign(<forwarded,snd(x2)>,kP)>,k11))
               )

process PDISDDH =
 (* begin S0 *)
  in(cS, gP0);
  out(cS, g^bke11);
  (* end S0 *)
  (* begin S1 *)
  in(cS,garbage);
  let sidS0 = h(<<gP0,g^bke11>,pke(k11)>) in
  out(cS, <<pk(kS),g^bke11>,sign(sidS0, kS)>);
  in(cS, encP );
  if checksign(dec(encP,gP0^bke11),pk(kP)) = sidS0 then
      out(cS,ok);
  (* end S1 *)
 (* begin Pdis0 *)
      out(cP, g^a1);
      in(cP, gB);
 (* end Pdis0 *)
     if gB = g^b1 then
        out(cP,diff(g^a1^b1,g^c11))


process SDISDDH =
 (* begin SDIS0 *)
  in(cS, gP);
  out(cS, g^b1);
 (* end SDIS0 *)

  (* begin SDIS1 *)
  if gP = g^a1 then
     out(cP,diff(g^a1^b1,g^c11))

system [secret] ( P1FADDH | SDISDDH | PDISDDH).


equiv [left,secret] [right,secret] secret.
Proof.
   ddh a1, b1, c11.
Qed.


(** And now the authentication process. *)

 process P1FAauth =
  in(cP,gB);
  out(cP,ok);
 (* begin P1 *)
  in(cP,t);
  let sidPa = h(<<g^ake11,gB>,pke(k11)>) in
  let pkSa = fst(t) in
  if pkSa = pk(kS) && checksign(snd(t),pkS) = sidPa then
       out(cP, enc(sign(sidPa,kP),k11));
           (* end P1 *)

           (* begin FA *)
           !_i (
                in(cP,y3);
                 let x3 = dec(y3,pke(k11)) in
                 if checkdec(y3,pke(k11)) = x3 then
                 if fst(x3) = reqsign then
                 out(cP, enc(<anssign, sign(<forwarded,snd(x3)>,kP)>,k11))
               )

process PDISauth =
 (* begin S0 *)
  in(cS, gP0);
  out(cS, g^bke11);
  (* end S0 *)
  (* begin S1 *)
  in(cS,garbage);
  let sidS0a = h(<<gP0,g^bke11>,pke(k11)>) in
  out(cS, <<pk(kS),g^bke11>,sign(sidS0a, kS)>);
  in(cS, encP );
  if checksign(dec(encP,gP0^bke11),pk(kP)) = sidS0a then
      out(cS,ok);
  (* end S1 *)
 (* begin Pdis0 *)
      out(cP, g^a1);
      in(cP, gB);
 (* end Pdis0 *)
      out(cP,ok);
 (* begin Pdis1 *)

      in(cP,t);
      let sidPa = h(<<g^a1,gB>,gB^a1>) in
      let pkSa = fst(t) in
      if pkSa = pk(kS) && checksign(snd(t),pkSa) = sidPa then
          out(cP, enc( <reqsign, sidPa>,k11));
         in(cP, signans);
	 let ya = dec(signans,pke(k11)) in
          if checkdec(signans,pke(k11)) = ya then
      	      if fst(ya) = anssign then
                 out(cP, enc(snd(ya),gB^a1));
                 in(cP,challenge);
                 try find i such that gB = g^b(i) || gB = g^b1 in
                   out(cP,ok)
                 else
		    Pfail : out(cP,diff(ok,ko))


process SDISauth =
 (* begin SDIS0 *)
  in(cS, gP);
  out(cS, g^b1);
 (* end SDIS0 *)

  (* begin SDIS1 *)
  in(cS,garbage);
  let sidSa = h(<<gP,g^b1>,gP^b1>) in
  out(cS, <<pk(kS),g^b1>,sign(sidSa, kS)>);
  in(cS, encP );
  if checksign(dec(encP,gP^b1),pk(kP)) = <forwarded,sidSa> then
     out(cS,ok);
     in(cS,challenge);
     try find i such that gP = g^a(i) || gP = g^a1 in
         out(cS,ok)
     else
       Sfail :  out(cS,diff(ok,ko))

system [auth] ( P1FAauth | SDISauth | PDISauth).


goal [none, auth] P_charac :
  cond@Pok => (cond@Pfail => False) .
  Proof.
  expand cond@Pok; expand cond@Pfail.
  euf M1.
