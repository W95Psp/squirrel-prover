hash h

abstract exp : message -> message -> message
abstract g : message

abstract ok : message

name kP : message
name kS : message

mutable keyS : index -> message
mutable keyP : index -> message

channel cP
channel cS

name a : index -> message
name b : index -> message

process P(i:index) =
  out(cP, exp(g,a(i)));
  in(cP, t);
  let sS = fst(t) in
  let hash_share = snd(t) in
  if h(<exp(g,a(i)),fst(t)>,kS) = snd(t) then
    (keyP(i) := <exp(g,a(i)),fst(t)>;
    out(cP, h(<exp(g,a(i)),fst(t)>,kP)))
  else
     null

process S(i:index) =
  in(cS, sP);
  out(cS, < <sP,exp(g,b(i))>, h(<sP,exp(g,b(i))>,kS)>);
  in(cS, hash_shares);
  if hash_shares = h(<sP,exp(g,b(i))>,kP) then
    (keyS(i) := <sP,exp(g,b(i))>;
     out(cS,ok))
   else null


system (!_i P(i) | !_j S(j)).

goal wa :
forall (i:index),
happens(S1(i) )
 =>  S(i)<S1(i) =>
  exists (j:index),
P1(j) <= S1(i) &&
keyP(j)@P1(j) = keyS(i)@S1(i).
Proof.
simpl.
euf C0.
case H0.
exists i1.
exists i1.

Qed.
