(* Protocol MW                          *)
(* R -> T: nr                           *)
(* T -> R: nt, id + H(<c0, nr, nt>,k)   *)
(* R -> T: id + H(<c1, nr, nt>,k)       *)
(* TODO: the last check done by T is not modelled *)

hash H

abstract id : index->message
abstract id':index -> index ->message

name key : index->message
name key':index -> index -> message

abstract error : message
abstract tag0 : message
abstract tag1 : message
axiom tags_neq : tag0 <> tag1

channel c


process tag(i:index, t:index)=
  in(c,x);
  new nt;
  out(c,<nt,xor(diff(id(i),id'(i,t)),H(<tag0,<x,nt>>,diff(key(i),key'(i,t))))>);
  in(c,y);
  if y = xor(diff(id(i),id'(i,t)),H(<tag1,<x,nt>>,diff(key(i),key'(i,t)))) then
  out(c,zero)

process reader =
  new nr;
  out(c,nr);
  in(c,m);
  if exists (i,t:index), xor(diff(id(i),id'(i,t)),snd(m))
               = H(<tag0,<nr,fst(m)>>,diff(key(i),key'(i,t))) then
    out(c, try find i,t such that
           xor(diff(id(i),id'(i,t)),snd(m)) = H(<tag0,<nr,fst(m)>>,diff(key(i),key'(i,t))) in
          xor(diff(id(i),id'(i,t)),H(<tag1,<nr,fst(m)>>,diff(key(i),key'(i,t)))))
  else
    out(c,error)

system (!_r R: reader | !_i !_t T: tag(i,t)).


equiv unlinkability.
Proof.
induction t.
(* Case R - Done *)
expand frame@R(r); expand exec@R(r).
expand cond@R(r);expand output@R(r).
fa 1.
fa 2.
fresh 2.
yesif 2.
repeat split.
depends R(r1), R2(r1).
depends R(r1), R1(r1).

(* Case R1  WIP *)
expand frame@R1(r); expand exec@R1(r).
expand cond@R1(r); expand output@R1(r).

equivalent
(exists (i,t:index), xor(diff(id(i),id'(i,t)),snd(input@R1(r))) =
                 H(<tag0,<nr(r),fst(input@R1(r))>>,diff(key(i),key'(i,t)))),
(exists (i,t:index), T(i,t) < R1(r) &&
 snd(output@T(i,t)) = snd(input@R1(r)) &&
 fst(output@T(i,t)) = fst(input@R1(r)) &&
 input@T(i,t) = output@R(r) &&   R(r) < T(i,t)).

apply tags_neq.
split.
(* proof of lemma: Cond => WA *)
project.
(* left *)
euf M1.
exists i,t1.
assert (input@T(i,t1) = nr(r)).
fresh M3.
depends R(r), R2(r).
(* right *)
euf M1.
exists i,t.
assert (input@T(i,t) = nr(r)).
fresh M3.
depends R(r), R2(r).

(* proof of lemma: WA => Cond *)
exists i,t.

(* BEGIN (tests to work around PRF under context with bounded variables) *)
fa 1. fadup 0.

ifcond 2, exec@pred(R1(r)).
fa 2.
fadup 2.
fafind 2.
prf 2.
ifcond_deep 2, exec@pred(R1(r)).
fa 2.
yesif 2.

project.

(* left *)
(* TODO Why don't we need to prove anything here ?
        I expected the else branch (T1) to be a problem! *)
apply tags_neq. (* repeat split.

admit. (* branche else, similaire then *)

assert cond@T1(i,t1).
executable pred(R1(r)). apply H1 to T1(i,t1).
expand exec@T1(i,t1). expand cond@T1(i,t1).
assert (H(<tag1,<input@T(i,t1),nt(i,t1)>>,key(i)) = xor(input@T1(i,t1),id(i))).
euf M3.
substitute. case H1.
depends T(i,t1), T1(i,t1). *)

(* right *)
apply tags_neq. (* repeat split.

assert cond@T1(i,t).
executable pred(R1(r)). apply H1 to T1(i,t).
expand exec@T1(i,t). expand cond@T1(i,t).
assert (H(<tag1,<input@T(i,t),nt(i,t)>>,key'(i,t)) = xor(input@T1(i,t),id'(i,t))).
euf M3.
substitute. case H1.
depends T(i,t), T1(i,t).

admit. (* branche else, similaire then *) *)

xor 2,n_PRF. (* TODO I don't understand this use of xor *)
(* END *)

(* Case R2  - WIP *)
expand frame@R2(r); expand exec@R2(r).
expand cond@R2(r); expand output@R2(r).


equivalent
(exists (i,t:index), xor(diff(id(i),id'(i,t)),snd(input@R2(r))) =
                 H(<tag0,<nr(r),fst(input@R2(r))>>,diff(key(i),key'(i,t)))),
(exists (i,t:index), T(i,t) < R2(r) &&
 snd(output@T(i,t)) = snd(input@R2(r)) &&
 fst(output@T(i,t)) = fst(input@R2(r)) &&
 input@T(i,t) = output@R(r) &&   R(r) < T(i,t)).


apply tags_neq.
split.
(* proof of lemma: Cond => WA *)
project.
(* left *)
euf M1.
exists i,t1.
assert (nr(r) = input@T(i,t1)).
fresh M3.
depends R(r), R1(r).
(* right *)
euf M1.
exists i,t.
assert (nr(r) = input@T(i,t)).
fresh M3.
depends R(r), R1(r).

(* proof of lemma: WA => Cond *)
exists i,t.
fadup 0.

(* Case T - DONE *)
expand frame@T(i,t); expand exec@T(i,t).
expand cond@T(i,t);expand output@T(i,t).
fa 1.
fa 2.
fa 2.

prf 3. (* we apply PRF inside XOR to be able to use XOR tactic later on *)
yesif 3.
apply tags_neq.
project.
assert (fst(input@R1(r)) = nt(i,t)).
fresh M2.
assert (fst(input@R1(r)) = nt(i,t)).
fresh M2.
admit. (* TODO new cases since merge *)
admit.
admit.
admit.
xor 3, n_PRF. (* we now have a fresh name instead of a hash in the XOR biterm *)
fresh 2. yesif 2.
Qed.
