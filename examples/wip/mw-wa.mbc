(* Protocol MW                          *)
(* R -> T: nr                           *)
(* T -> R: nt, id + H(<c0, nr, nt>,k)   *)
(* R -> T: id + H(<c1, nr, nt>,k)       *)


hash H


(* TODO abstract would be more natural but index->message not allowed *)
name id':index -> index ->message

name key':index -> index -> message


abstract error : message
abstract ok: message
abstract ko: message
abstract tag0 : message
abstract tag1 : message
axiom tags_neq : tag0 <> tag1

channel c

process tag(i:index, t:index)=
  in(c,x);
  new nt;
  out(c,<nt,xor(id'(i,t),H(<tag0,<x,nt>>,key'(i,t)))>);
  in(c,y);
  if y = xor(id'(i,t),H(<tag1, <x,nt>>,key'(i,t))) then out(c,ok)
  else out(c,ko)

process reader =
  new nr;
  out(c,nr);
  in(c,m);
  try find i,t such that xor(id'(i,t),snd(m)) = H(<tag0,<nr,fst(m)>>,key'(i,t)) in
   out(c,xor(id'(i,t),H(<tag1,<nr,fst(m)>>,key'(i,t))))
  
 else
    out(c,error) 

system (!_r R: reader | !_i !_t T: tag(i,t)).



goal wa_R:
  forall (r,i,t:index),
  cond@R1(r,i,t) =>
  T(i,t) < R1(r,i,t) &&
  fst(input@R1(r,i,t)) = fst(output@T(i,t)) &&
  snd(input@R1(r,i,t)) = snd(output@T(i,t)) &&
  R(r) < T(i,t) && 
  input@T(i,t) = output@R(r).
 
Proof.
  intros.
  expand cond@R1(r,i,t).
  euf M0.
  assert(input@T(i,t) = nr(r)).
  fresh M2.
  case H0.
  depends R(r), R2(r). 
  depends R(r), R1(r,i1,t1).
Qed.


goal wa_T:
 forall (i,t:index),
 exec@T1(i,t) => ( exists (r:index), 
      R1(r,i,t) < T1(i,t) &&  output@R1(r,i,t) = input@T1(i,t) &&
 fst(output@T(i,t)) = fst(input@R1(r,i,t)) && 
              snd(output@T(i,t)) = snd(input@R1(r,i,t)) &&       T(i,t) < R1(r,i,t) && 
     R(r) < T(i,t) &&  output@R(r) = input@T(i,t)). 

Proof.
intros.
assert cond@T1(i,t).
expand exec@T1(i,t).
expand cond@T1(i,t).
apply tags_neq.
assert (H(<tag1,<input@T(i,t),nt(i,t)>>,key'(i,t)) = xor(input@T1(i,t),id'(i,t))).
euf M2.
exists r.
case H1.
nosimpl(repeat split); simpl.

assert cond@R1(r,i,t).
 assert exec@R1(r,i,t).
 executable T1(i,t).
 apply H1 to R1(r,i,t).
 expand exec@R1(r,i,t).
expand cond@R1(r,i,t).

assert (nt(i,t) = fst(input@R1(r,i,t))).
fresh M4.
case H1.
depends T(i,t), T2(i,t).

assert (nr(r) = input@T(i,t)).
fresh M4. 
case H1.
depends R(r), R2(r).
substitute r1, r.
depends R(r), R1(r,i1,t1).

nosimpl(repeat split); simpl.

depends T(i,t), T1(i,t).

assert exec@R1(r,i,t).
executable T(i,t).
apply H1 to R1(r,i,t).
assert cond@R1(r,i,t).
expand exec@R1(r,i,t).
expand cond@R1(r,i,t).

assert (nt(i,t) = fst(input@R1(r,i,t))).
fresh M4.
case H1.
substitute i2, i.
substitute t2,t.
depends T(i,t), T1(i,t).
substitute i1, i.
substitute t1,t.
depends T(i,t), T2(i,t).
depends R(r), R1(r,i,t).
Qed.



