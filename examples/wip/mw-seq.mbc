(* Protocol MW                          *)
(* R -> T: nr                           *)
(* T -> R: nt, id + H(<c0, nr, nt>,k)   *)
(* R -> T: id + H(<c1, nr, nt>,k)       *)
(* TODO: the last check done by T is not modelled *)

hash H

abstract id : index->message
abstract id':index->index->message

name key : index->message
name key':index->index->message

abstract error : message
abstract tag0 : message
abstract tag1 : message
axiom tags_neq : tag0 <> tag1

channel c

process tag(i:index, t:index)=
  in(c,x);
  new nt;
  out(c,<nt,xor(diff(id(i),id'(i,t)),H(<tag0,<x,nt>>,diff(key(i),key'(i,t))))>)

process reader =
  new nr;
  out(c,nr);
  in(c,m);
  if exists (i,t:index),
     xor(diff(id(i),id'(i,t)),snd(m)) = 
     H(<tag0,<nr,fst(m)>>,diff(key(i),key'(i,t)))
  then
    out(c, try find i,t such that 
             xor(diff(id(i),id'(i,t)),snd(m)) =
             H(<tag0,<nr,fst(m)>>,diff(key(i),key'(i,t)))
           in
             xor(diff(id(i),id'(i,t)),
                 H(<tag1,<nr,fst(m)>>,diff(key(i),key'(i,t)))))
  else
    out(c,error)

system (!_r R: reader | !_i !_t T: tag(i,t)).

(* Well-authentication for R1's condition, formulated in an imprecise
   way with respect to the involved indices. *)
goal wa_R1 : forall r:index,
  (exists (i,t:index),
   xor(diff(id(i),id'(i,t)),snd(input@R1(r))) = 
   H(<tag0,<nr(r),fst(input@R1(r))>>,diff(key(i),key'(i,t))))
  <=>
  (exists (i,t:index),
   T(i,t) < R1(r) && 
   snd(output@T(i,t)) = snd(input@R1(r)) &&
   fst(output@T(i,t)) = fst(input@R1(r)) &&  
   R(r) < T(i,t) &&
   output@R(r) = input@T(i,t)).
Proof.

  intros; split.

  (* Cond => WA *)
  project.
  (* left *)
  euf M0.
  exists i,t1.
  assert (input@T(i,t1) = nr(r)).
  fresh M2.
  depends R(r), R2(r).
  (* right *)
  euf M0.
  exists i,t.
  assert (input@T(i,t) = nr(r)).
  fresh M2.
  depends R(r), R2(r).

  (* WA => Cond *)
  exists i,t.

Qed.

(** Same as before, but more precise wrt i, for the left process.
    There has to remain an existential quantification on t,
    because it is not involved in the condition. *)
goal [left] wa_R1_left : forall (i,r:index),
  xor(id(i),snd(input@R1(r))) = 
  H(<tag0,<nr(r),fst(input@R1(r))>>,key(i))
  <=>
  exists t:index,
  T(i,t) < R1(r) && 
  snd(output@T(i,t)) = snd(input@R1(r)) &&
  fst(output@T(i,t)) = fst(input@R1(r)) &&  
  R(r) < T(i,t) &&
  output@R(r) = input@T(i,t).
Proof.
  intros.
  euf M0.
  exists t.
  assert input@T(i,t) = nr(r).
  fresh M2.
  depends R(r), R2(r).
Qed.

(** Precise version of wa_R1 on the right: no more existentials. *)
goal [right] wa_R1_right : forall (i,t,r:index),
  xor(id'(i,t),snd(input@R1(r))) = 
  H(<tag0,<nr(r),fst(input@R1(r))>>,key'(i,t))
  <=>
  T(i,t) < R1(r) && 
  snd(output@T(i,t)) = snd(input@R1(r)) &&
  fst(output@T(i,t)) = fst(input@R1(r)) &&
  R(r) < T(i,t) &&
  output@R(r) = input@T(i,t).
Proof.
  intros.
  euf M0.
  assert input@T(i,t) = nr(r).
  fresh M2.
  depends R(r), R2(r).
Qed.

equiv unlinkability.
Proof.

enrich seq(r -> nr(r)).
enrich seq(i,t -> nt(i,t)).
enrich seq(i,t -> diff(id(i),id'(i,t)) XOR
                  H(<tag0,<input@T(i,t),nt(i,t)>>,diff(key(i),key'(i,t)))).
enrich seq(i,r,t -> diff(id(i),id'(i,t)) XOR
                    H(<tag1,<nr(r),nt(i,t)>>,diff(key(i),key'(i,t)))).
induction t.

(* Init case *)
admit. (* see mw-prelim *)

(* Case R - Done *)
expand seq(r->nr(r)), r.

(* Case R1  WIP *)
expand frame@R1(r); expand exec@R1(r).
expand cond@R1(r); expand output@R1(r).

equivalent
  (exists (i,t:index), xor(diff(id(i),id'(i,t)),snd(input@R1(r))) = 
                       H(<tag0,<nr(r),fst(input@R1(r))>>,diff(key(i),key'(i,t)))),
  (exists (i,t:index), T(i,t) < R1(r) &&
   snd(output@T(i,t)) = snd(input@R1(r)) &&
   fst(output@T(i,t)) = fst(input@R1(r)) &&
   R(r) < T(i,t) &&
   output@R(r) = input@T(i,t)).
apply wa_R1 to r.

fa 5. fadup 4.
fa 6. fadup 6.
equivalent
  try find i,t such that
    xor(diff(id(i),id'(i,t)),snd(input@R1(r))) =
    H(<tag0,<nr(r),fst(input@R1(r))>>,diff(key(i),key'(i,t)))
  in
    xor(diff(id(i),id'(i,t)),
        H(<tag1,<nr(r),fst(input@R1(r))>>,diff(key(i),key'(i,t)))),
  try find i,t such that
    T(i,t) < R1(r) && 
    snd(output@T(i,t)) = snd(input@R1(r)) &&
    fst(output@T(i,t)) = fst(input@R1(r)) &&  
    R(r) < T(i,t) &&
    output@R(r) = input@T(i,t)
  in
    xor(diff(id(i),id'(i,t)),
        H(<tag1,<nr(r),fst(input@R1(r))>>,diff(key(i),key'(i,t)))).
(* TODO macro definitions under binders => _variables appear *)
project.
  nosimpl(fa); apply wa_R1_left to i,r.
  nosimpl(fa); apply wa_R1_right to i,t,r.
(* TODO findeq to rewrite fst(input@R1(r)) into nt(i,t) *)
fa 6.
admit 6. (* TODO extend fadup *)

expand seq(i,r,t->xor((diff(id(i),id'(i,t))),
                  H(<tag1,<nr(r),nt(i,t)>>,(diff(key(i),key'(i,t)))))),
       i,r,t.
admit 7. (* this is a dup, modulo the rewrite above *)

(* Case R2 *)
expand frame@R2(r); expand exec@R2(r).
expand cond@R2(r); expand output@R2(r).

(* Same as wa_R1 but with @R2 instead of @R1,
   and the equivalence is used under a negation. *)
equivalent
(exists (i,t:index), xor(diff(id(i),id'(i,t)),snd(input@R2(r))) = 
                 H(<tag0,<nr(r),fst(input@R2(r))>>,diff(key(i),key'(i,t)))),
(exists (i,t:index), T(i,t) < R2(r) && 
 snd(output@T(i,t)) = snd(input@R2(r)) &&
 fst(output@T(i,t)) = fst(input@R2(r)) &&  
 input@T(i,t) = output@R(r) &&   R(r) < T(i,t)).

apply tags_neq.
split.
(* proof of lemma: Cond => WA *)
project.
(* left *)
euf M1.
exists i,t1.
assert (nr(r) = input@T(i,t1)).
fresh M3.
depends R(r), R1(r).
(* right *)
euf M1.
exists i,t.
assert (nr(r) = input@T(i,t)).
fresh M3.
depends R(r), R1(r).

(* proof of lemma: WA => Cond *)
exists i,t.

fadup 4.

(* Case T *)
expand seq(i,t->nt(i,t)),i,t.
expand seq(i,t->xor((diff(id(i),id'(i,t))),
                H(<tag0,<input@T(i,t),nt(i,t)>>,(diff(key(i),key'(i,t)))))),i,t.

Qed.

