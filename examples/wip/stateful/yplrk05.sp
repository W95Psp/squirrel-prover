(*******************************************************************************
YPLRK05

T. van Deursen and S. Radomirović, ‘Attacks on RFID Protocols’,
Cryptology ePrint Archive, vol. 2008, no. 310, pp. 1–56, Aug. 2009.

The reader and tag share secrets k, k1, k2.
The reader initiates the protocol by challenging the tag with a nonce r1.
The tag responds with h(k1 XOR r1 XOR k).
The reader then replies with h(k2) and both tag and reader update secrets k1 and
k2.

In this model we use 2 different keyed hash functions, instead of a single (not
keyed) hash function as in the specification.

R -> T : r1
T -> R : h(kT1+r1+k)
         kT1 := k1+h(k2)
         kT2 := k2+h(k1+r1+k)
R -> T : h(kR2)
         kR1 := k1+h(k2)
         kR2 := k2+h(k1+r1+k)
*******************************************************************************)

hash h1
hash h2

abstract ok : message
abstract error : message

name key1 : index->message
name key2 : index->message
name k : index->message
name r1 : index->message

name k1init : index->message
name k2init : index->message

mutable kT(i:index) : message = <k1init(i),k2init(i)>
mutable kR(ii:index) : message = <k1init(ii),k2init(ii)>

channel cT
channel cR

(* i = tag's identity, j = tag's session for identity i *)
process tag(i:index,j:index) =
  in(cR, xr1);
  out(cT, h1(fst(kT(i)) XOR xr1 XOR k(i), key1(i)));
  in(cR, xh2);
  if xh2 = h2(snd(kT(i)), key2(i)) then
    kT(i) := < fst(kT(i)) XOR h2(snd(kT(i)), key2(i)),
               snd(kT(i)) XOR h1(fst(kT(i)) XOR xr1 XOR k(i), key1(i)) >;
    out(cT, ok)
  else
    out(cT, error)

(* jj = generic reader's session *)
process reader(jj:index) =
  out(cR, r1(jj));
  in(cT, xh1);
  try find ii such that xh1 = h1(fst(kR(ii)) XOR r1(jj) XOR k(ii), key1(ii)) in
    let m = h2(snd(kR(ii)),key2(ii)) in
    kR(ii) := < fst(kR(ii)) XOR h2(snd(kR(ii)), key2(ii)),
                snd(kR(ii)) XOR h1(fst(kR(ii)) XOR r1(jj) XOR k(ii), key1(ii)) >;
    out(cT, m)
  else
    out(cT, error)

system ((!_jj R: reader(jj)) | (!_i !_j T: tag(i,j))).

(* Minimal sequentiality assumption needed for the proofs *)
axiom sequentiality :
  forall (t:timestamp), forall (i,j:index),
    happens(T(i,j),t,T1(i,j)) =>
    (T(i,j) < t && t < T1(i,j) => not(exists (j':index), t = T1(i,j') && j <> j')).

goal updateTag :
forall (t:timestamp), forall (i,j:index), 
  happens(T(i,j),t,T1(i,j)) =>
  (t >= T(i,j) && t < T1(i,j)) => kT(i)@T(i,j) = kT(i)@t.
Proof.
nosimpl(induction; intro IH0).
case t.

by use IH0 with pred(R(jj)),i,j as H0 ; use H0 with i,j.
by use IH0 with pred(R1(jj,ii)),i,j as H0; use H0 with i,j.
by use IH0 with pred(R2(jj)),i,j as H0; use H0 with i,j.

assert T(i1,j1) = T(i,j) || T(i1,j1) > T(i,j) as H0.
case H0.
by use IH0 with pred(T(i1,j1)),i,j as H0; use H0 with i,j.

assert i=i1 || i<>i1 as H0.
case H0.
assert j=j1 || j<>j1 as H0.
case H0.
(* case i=i1 && j<>j1 *)
by use sequentiality with t,i,j; exists j1.
(* case i<>i1 *)
use IH0 with pred(T1(i1,j1)),i,j as M1.
assert kT(i)@T1(i1,j1) = kT(i)@pred(T1(i1,j1)).
by case (if i = i1 then
       <xor(fst(kT(i1)@pred(T1(i1,j1))),
            h2(snd(kT(i1)@pred(T1(i1,j1))),key2(i1))),
        xor(snd(kT(i1)@pred(T1(i1,j1))),
            h1(xor(xor(fst(kT(i1)@pred(T1(i1,j1))),input@T(i1,j1)),k(i1)),
               key1(i1)))>
       else kT(i)@pred(T1(i1,j1))).

by use IH0 with pred(T2(i1,j1)),i,j as H0; use H0 with i,j.
Qed.

goal readerUpdateTerm :
  forall (jj,ii:index),
  happens(R1(jj,ii))
  => 
  kR(ii)@R1(jj,ii) =
    < fst(kR(ii)@pred(R1(jj,ii))) XOR h2(snd(kR(ii)@pred(R1(jj,ii))), key2(ii)),
      snd(kR(ii)@pred(R1(jj,ii)))
        XOR h1(fst(kR(ii)@pred(R1(jj,ii))) XOR r1(jj) XOR k(ii), key1(ii)) >.
Proof.
auto.
Qed.


goal auth_R1_weak :
forall (jj,ii:index),
  happens(R1(jj,ii)) =>
    (cond@R1(jj,ii) =>
      (exists (j:index), T(ii,j) < R1(jj,ii) && output@T(ii,j) = input@R1(jj,ii))).
Proof.
intro jj ii H.
expand cond@R1(jj,ii).
euf H0.

  (* case 1/3: equality with hashed message in update@R1 *)
  (* this case is easily handled in the version with induction
  (see auth_R1_induction_weak) because the induction hypothesis
  allows to conclude using only the fact that R1(jj1,ii) < R1(jj,ii),
  we do not have to exploit the equality hypothesis generated by the
  euf tactic *)
  (* here, without the induction, we have to find another way to conclude *)

  assert
    input@R1(jj,ii) =
      h1(xor(xor(fst(kR(ii)@pred(R1(jj1,ii))),r1(jj1)),k(ii)),key1(ii))
    as M2.
  euf M2. (* here again, we have 3 different cases *)

    (* case 1/3: equality with hashed message in update@R1 *)
    admit. (* TODO ??? *)

    (* case 2/3: equality with hashed message in output@T *)
    (* honest case *)
    by exists j; case H1.

    (* case 3/3: equality with hashed message in update@T1 *)
    (* if there is an update@T1, then action T happened before *)
    use updateTag with pred(T1(ii,j)),ii,j as H2.

    (* TODO: adrien, this should work*)
    (* depends T(ii,j),T1(ii,j); 1: by auto  *)

    exists j. split.
    case H1.
    assert happens(T1(ii,j)).
    by depends T(ii,j),T1(ii,j). 
    assert happens(T1(ii,j)).
    by depends T(ii,j),T1(ii,j).
    case H1. 
    assert happens(T1(ii,j)).
    by depends T(ii,j),T1(ii,j).
    assert happens(T1(ii,j)).
    by depends T(ii,j),T1(ii,j).
    case H1.
    assert happens(T1(ii,j)).
    by depends T(ii,j),T1(ii,j).
    assert happens(T1(ii,j)).
    by depends T(ii,j),T1(ii,j).
    case H1.
    assert happens(pred(T1(ii,j))).
    by depends T(ii,j),T1(ii,j).
    assert happens(pred(T1(ii,j))).
    by depends T(ii,j),T1(ii,j).
  (* case 2/3: equality with hashed message in output@T *)
  (* honest case *)
  by exists j.

  (* case 3/3: equality with hashed message in update@T1 *)
  (* if there is an update@T1, then action T happened before *)
  use updateTag with pred(T1(ii,j)),ii,j as H1.
  depends T(ii,j),T1(ii,j).
  by exists j.
  assert happens(T1(ii,j)). depends T(ii,j),T1(ii,j).
  assert happens(pred(T1(ii,j))).
  depends T(ii,j),T1(ii,j).
  
  (* QUESTION SOLENE - In this proof, it seems that there could be some 
  automated reasoning to avoid all the assert happens / depends *)
Qed.

goal auth_R1_induction_weak :
forall (t:timestamp), forall (jj,ii:index),
  happens(R1(jj,ii)) =>
  ((t = R1(jj,ii) && exec@t) (* exec@t (not only cond@t) is needed in the proof *)
    =>
    (exists (j:index), T(ii,j) < t && output@T(ii,j) = input@t)).
Proof.
nosimpl(induction; intro IH0).
intro jj ii.
subst t,R1(jj,ii).
expand exec@R1(jj,ii). expand cond@R1(jj,ii).
euf H0.

  (* case 1/3: equality with hashed message in update@R1 *)
  use IH0 with R1(jj1,ii),jj1,ii.
  executable pred(R1(jj,ii)).
  use H1 with R1(jj1,ii).
  expand exec@R1(jj1,ii). expand cond@R1(jj1,ii).
  by exists j.
  executable pred(R1(jj,ii)).
  use H1 with R1(jj1,ii).

  (* case 2/3: equality with hashed message in output@T *)
  (* honest case *)
  by exists j.

  (* case 3/3: equality with hashed message in update@T1 *)
  (* if there is an update@T1, then action T happened before *)
  use updateTag with pred(T1(ii,j)),ii,j as H1.
  depends T(ii,j),T1(ii,j).
  by exists j.
  assert happens(T1(ii,j)).
  by depends T(ii,j),T1(ii,j).
  assert happens(pred(T1(ii,j))).
  by depends T(ii,j),T1(ii,j).
Qed.

goal auth_T1_induction_weak :
forall (t:timestamp), forall (i,j:index),
  happens(t) =>
  ((t = T1(i,j) && exec@t) (* exec@t (not only cond@t) is needed in the proof *)
   =>
   (exists (jj:index),
    R1(jj,i) < t &&
    output@R1(jj,i) = input@t)).
Proof.
nosimpl(induction).
intro IH0 i j.
subst t,T1(i,j).
expand exec@T1(i,j). expand cond@T1(i,j).
euf H0.

  (* case 1/2: equality with hashed message in output@R1 *)
  (* honest case *)
  by exists jj.

  (* case 2/2: equality with hashed message in update@T1 *)
  use IH0 with T1(i,j1),i,j1.
  executable pred(T1(i,j)).
  use H1 with T1(i,j1).
  expand exec@T1(i,j1). expand cond@T1(i,j1).
  by exists jj.
  executable pred(T1(i,j)).
  by use H1 with T1(i,j1).
Qed.
