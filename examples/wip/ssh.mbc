(** Example of signed DDH key exchange. It corresponds to the ISO 9798-3
protocol.  We leverage the composition result, to prove a single session in the
presence of an adversary with access to a "backdoor" about the signature
function, which allows him to about signatures of some specific messages.

The proof is split into two systems, one modelling the authentication property,
and the other the strong secrecy. Put together, they allow to derive very simply
the actual assumption needed to apply the composition theorem.  **)

abstract ok : message
abstract ko : message

name kP : message
name kS : message

mutable keyS : index -> message
mutable keyP : index -> message

channel cP
channel cS

name a1 : message
name b1 : message
name k11 : message
name a : index -> message
name b : index -> message
name k : index -> index -> message

abstract enc : message -> message -> message
abstract dec : message -> message -> message

axiom encdec : forall (x1,x2:message), dec(enc(x1,x2),x2) =x1

hash h
name kh : message

axiom DDHinj : forall (x1,x2:message), x1 <> x2 => g^x1 <> g^x2
axiom DDHcommut : forall (x1,x2:message), g^x1^x2 = g^x2^x1


signature sign,checksign,pk with oracle forall (m:message,sk:message)
 (sk <> kP || exists (i:index, x1:message, x2:message) m=h(<<g^a(i),x1>,x2>,kh) )
  &&
 (sk <> kS || exists (i:index, x1:message, x2:message) m=h(<<x1,g^b(i)>,x2>,kh))


(** We first present the general ssh process. *)

process P =
 (* begin P0 *)
  out(cP, g^a1);
  in(cP, gB);
 (* end P0 *)
  out(cP,ok);
 (* begin P1 *)

  in(cP,t);
  let sid = h(<<g^a1,gB>,gB^a1>,kh) in
  let pkS = fst(t) in
  let sidS = snd(t) in
  if checksign(snd(t),pkS) = h(sid,kh) then
     out(cP, enc(sign(sid,kP),gB^a1))


process S =
 (* begin S0 *)
  in(cS, gP);
  out(cS, g^b1);
 (* end S0 *)

  (* begin S1 *)
  in(cS,garbage);
  let sid = h(<<gP,g^b1>,gP^b1>,kh) in
  out(cS, <<pk(kS),g^b1>,sign(sid, kS)>);
  in(cS, encP );
  if checksign(dec(encP,gP^b1),pk(kP)) = h(sid,kh) then
     out(cS,ok)

system [fullSSH] ( P | S).

(* The secret is expected to hold at the end of P0 *)

process PDDH =
 (* begin P0 *)
  out(cP, g^a1);
  in(cP, gB);
 (* end P0 *)
  if gB = g^b1 then
     out(cP,diff(g^a1^b1,g^k11))

process SDDH =
 (* begin S0 *)
  in(cS, gP);
  out(cS, g^b1);
 (* end S0 *)
  if gP = g^a1 then
     out(cP,diff(g^a1^b1,g^k11))


system [secrect] ( PDDH | SDDH).


(** The strong secrecy is directly obtained through ddh. *)
equiv [left,secret] [right,secret] secret.
Proof.
   ddh a1, b1, k11.
Qed.


(** The authentication says that the key confirmation must fail in case of misauthentication *)

process Pauth =
 (* begin P0 *)
  out(cP, g^a1);
  in(cP, gB);
 (* end P0 *)
  out(cP,ok);
 (* begin P1 *)

  in(cP,t);
  let sid = h(<<g^a1,gB>,gB^a1>,kh) in
  let pkS = fst(t) in
  let sidS = snd(t) in
  if checksign(snd(t),pkS) = h(sid,kh) then
     out(cP, enc(sign(sid,kP),gB^a1));
     in(cP,challenge);
     try find i such that gB = g^b(i) || gB = g^b1 in
         out(cP,ok)
     else
         out(cP,diff(ok,ko))

process Sauth =
 (* begin S0 *)
  in(cS, gP);
  out(cS, g^b1);
 (* end S0 *)

  (* begin S1 *)
  in(cS,garbage);
  let sid = h(<<gP,g^b1>,gP^b1>,kh) in
  out(cS, <<pk(kS),g^b1>,sign(sid, kS)>);
  in(cS, encP );
  if checksign(dec(encP,gP^b1),pk(kP)) = h(sid,kh) then
      out(cS,ok);
     in(cS,challenge);
     try find i such that gP = g^a(i) || gP = g^a1 in
         out(cS,ok)
     else
         out(cS,diff(ok,ko))

system [auth] ( P | S).



(** Prove that the condition above the only diff term inside S is never true. **)
goal [none, auth] S1_charac :
  cond@S1 => (cond@A2 => False) .
  Proof.
 print.
  simpl.
  expand cond@S1.
  expand cond@A2.
  expand pkP@S1.
  substitute fst(input@S), pk(kP).
  euf M1.

  case H2.
  apply H1 to i.

  notleft H0.
Qed.

(** Prove that the condition above the only diff term inside P is never true. **)
goal [none, auth] P1_charac :
   cond@P1 => (cond@P4 => False).
Proof.
  simpl.
  expand cond@P1; expand cond@P4.
  substitute pkS@P1,pk(kS).
  euf M1.

  case H3.
  apply H1 to i.

  notleft H0.
Qed.

(** The strong secrecy is directly obtained through ddh. *)
equiv [left,secret] [right,secret] secret.
Proof.
   ddh a1, b1, k11.
Qed.

(** The equivalence for authentication is obtained by using the unreachability
proofs over the two actions. The rest of the protocol can be handled through
some simple enriching of the induction hypothesis, and then dup applications. *)

equiv [left, auth] [right, auth] auth.
Proof.
   enrich kP; enrich g^a1; enrich g^b1; enrich kS.
   enrich seq(i-> g^b(i)).    enrich seq(i-> g^a(i)).

   induction t.

   expandall.
   fa 7.

   expand seq(i->g^b(i)),j.

   expand frame@P4; expand exec@P4.
   fa 7.

   equivalent cond@P4,False.
   simpl.
   executable pred(P4). depends P1, P4. apply H1 to P1. apply P1_charac.

   noif 8. simpl.

   expandall.
   fa 7.

   expand seq(i->g^a(i)),l.

   expand frame@S4; expand exec@S4.

   equivalent cond@S4,False.
   simpl.
   executable pred(S4). depends S1, S4. apply H1 to S1. apply S1_charac.

   fa 7. noif 8.
Qed.
