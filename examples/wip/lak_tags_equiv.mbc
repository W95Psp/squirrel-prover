hash h


abstract ok:message
abstract ko:message

abstract tag1:message
abstract tag2:message
axiom tags_neq : tag1 <> tag2

(* Constant used in conditional branches that should never be reached. *)
abstract absurd:message

name key : index->message
name key': index->index->message
channel cT
channel cR

process tag(i:index,k:index) =
  new nT;
  in(cR,nR);
  let m2 = h(<<nR,nT>,tag1>,diff(key(i),key'(i,k))) in
  out(cT,<nT,m2>);
  in(cR,m3);
  if m3 = h(<<m2,nR>,tag2>,diff(key(i),key'(i,k))) then
    out(cT,ok)
  else
    out(cT,ko)

process reader(j:index) =
  new nR;
  out(cR,nR);
  in(cT,x);
  if exists (i,k:index), snd(x) = h(<<nR,fst(x)>,tag1>,diff(key(i),key'(i,k))) then
    out(cR, try find i,k such that snd(x) = h(<<nR,fst(x)>,tag1>,diff(key(i),key'(i,k))) in
              h(<<snd(x),nR>,tag2>,diff(key(i),key'(i,k)))
            else absurd)
  else
    out(cR,ko)

system ((!_j R: reader(j)) | (!_i !_k T: tag(i,k))).


equiv foo.
Proof.
induction t.


(* Case R: OK *)
admit.

(* 
expand frame@R(j); expand exec@R(j).
expand cond@R(j); expand output@R(j).
fa 1; fa 2.
fresh 2; yesif 2.
repeat split.
depends R(j),R2(j).
depends R(j),R1(j).
*)

(* Case R1: WIP *)

expand frame@R1(j).
expand exec@R1(j).

equivalent cond@R1(j),
  (exists (i,k:index),
   T(i,k) < R1(j) &&
   snd(output@T(i,k)) = snd(input@R1(j)) &&
   fst(output@T(i,k)) = fst(input@R1(j)) &&
   input@T(i,k) = output@R(j)).
expand cond@R1(j).

split.
(* cond => honest *) 
apply tags_neq; project.
euf M0.
exists i,k1.
euf M0.
exists i,k.
(* honest => cond *)
exists i,k.

fa 1. fa 2.
fa 0.
 admit 1. (* TODO fa/dup *)
expand output@R1(j).

admit 2. (* TODO PRF under try-find et TODO try-find va marcher car =cond@R1(j) *)



(* Case R2 *)

admit.

(*
expand frame@R2(j).
expand exec@R2(j).


equivalent cond@R2(j),
  (forall (i,k:index),
   not(T(i,k) < R2(j)) ||
   not(snd(output@T(i,k)) = snd(input@R2(j))) ||  
   not(fst(output@T(i,k)) = fst(input@R2(j))) || 
    not(output@R(j) = input@T(i,k))).


split.

(* cond => honest *)
apply tags_neq.
expand cond@R2(j).
expand output@T(i,k).
project.
expand m2(i,k)@T(i,k).
notleft H0.
apply H0 to i,k.
help.
left.
right.
assert (fst(input@R2(j)) = nT(i,k)).

right.

euf M1.

*)

(* Case T OK *)
admit.

(*
expand frame@T(i,k).
expand exec@T(i,k).
expand cond@T(i,k).
expand output@T(i,k).
fa 1.
fa 2.
fa 2.
expand m2(i,k)@T(i,k).
prf 3.
yesif 3.
apply tags_neq.
project.

(* left *)
repeat (split+intro).
depends T(i,k),T2(i,k).
assert fst(input@R1(j))=nT(i,k). fresh M2.
case H0. depends T(i,k),T1(i,k). depends T(i,k),T2(i,k).
assert fst(input@R1(j))=nT(i,k). fresh M2.
case H0. depends T(i,k),T1(i,k). depends T(i,k),T2(i,k). depends T(i,k),T1(i,k).
assert fst(input@R2(j))=nT(i,k). fresh M2.
case H0. depends T(i,k),T1(i,k). depends T(i,k),T2(i,k).

(* right *)
repeat (split+intro).
depends T(i,k),T2(i,k).
assert fst(input@R2(j))=nT(i,k). fresh M2.
case H0. depends T(i,k),T1(i,k). depends T(i,k),T2(i,k). depends T(i,k),T1(i,k).
assert fst(input@R1(j))=nT(i,k). fresh M2.
case H0. depends T(i,k),T1(i,k). depends T(i,k),T2(i,k).
assert fst(input@R1(j))=nT(i,k). fresh M2.
case H0. depends T(i,k),T1(i,k). depends T(i,k),T2(i,k). depends T(i,k),T2(i,k).

fresh 2.
yesif 2.
repeat split.
depends T(i1,k1),T1(i1,k1).
depends T(i1,k1),T2(i1,k1).

*)


(* Case T1 *)
expand frame@T1(i,k).
expand exec@T1(i,k).


equivalent cond@T1(i,k),
( exists (j:index), (R1(j) < T1(i,k) && 
  input@T1(i,k) = output@R1(j) && input@R1(j) = output@T(i,k)) && input@T(i,k) = output@R(j)).

expand cond@T1(i,k).
split.
(* cond => honest *) 
apply tags_neq; project.
euf M0.
exists j. 
split.
case H0.
depends T(i,k), T1(i,k).
expand output@R1(j).
expand m2(i,k)@T1(i,k).
assert (input@T(i,k) = nR(j)).
simpl.
assert (snd(input@R1(j)) = h(<<nR(j),nT(i,k)>,tag1>,key(i))).
assert (fst(input@R1(j)) = nT(i,k)).
euf M2.

yestry.

(* Case T2 *)
admit.
Qed.






goal [left] wa_left :
  forall (i:index, j:index, k:index),
  cond@R1(j,i,k) =>
  exists (ii:index,kk:index),
  T(ii,kk) <= R1(j,i,k) && i =ii && 
  fst(input@R1(j,i,k)) = fst(output@T(ii,kk)) &&
  snd(input@R1(j,i,k)) = snd(output@T(ii,kk)).
Proof.
simpl.
expand cond@R1(j,i,k).
apply tags_neq.
euf M0.
exists i,k1.
Qed.

goal [right] wa_right:
  forall (i:index, j:index, k:index),
  cond@R1(j,i,k) =>
  exists (ii:index,kk:index),
  T(ii,kk) <= R1(j,i,k) && i = ii && k = kk &&
  fst(input@R1(j,i,k)) = fst(output@T(ii,kk)) &&
  snd(input@R1(j,i,k)) = snd(output@T(ii,kk)).
Proof.
simpl.
expand cond@R1(j,i,k).
apply tags_neq.
euf M0.
exists i,k.
Qed.

goal wa_both:
 forall (i:index, j:index, k:index),
  cond@R1(j,i,k) =>
  exists (ii:index,kk:index),
  T(ii,kk) <= R1(j,i,k) && i =ii && 
  fst(input@R1(j,i,k)) = fst(output@T(ii,kk)) &&
  snd(input@R1(j,i,k)) = snd(output@T(ii,kk)).
Proof.
simpl.
expand cond@R1(j,i,k).
apply tags_neq.
project.
euf M0.
exists i, k1.
euf M0.
exists i, k.
Qed.

goal wa_inv:
 forall (i:index, j:index, k:index),
( exists (ii:index,kk:index),
  T(ii,kk) <= R1(j,i,k) && i =ii && 
  fst(input@R1(j,i,k)) = fst(output@T(ii,kk)) &&
  snd(input@R1(j,i,k)) = snd(output@T(ii,kk))) => cond@R1(j,i,k).
Proof.
simpl.
expand cond@R1(j,i,k).
project.
substitute ii, i.
expand output@T(i,kk).
euf D0.
simpl.
case H0.
substitute k1, kk.
