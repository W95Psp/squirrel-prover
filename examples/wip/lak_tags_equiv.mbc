hash h

abstract ok:message
abstract ko:message

abstract tag1:message
abstract tag2:message
axiom tags_neq : tag1 <> tag2

name key : index->message
name key': index->index->message
channel cT
channel cR

process tag(i:index,k:index) =
  new nT;
  in(cR,nR);
  let m2 = h(<<nR,nT>,tag1>,diff(key(i),key'(i,k))) in
  out(cT,<nT,m2>);
  in(cR,m3);
  if m3 = h(<<m2,nR>,tag2>,diff(key(i),key'(i,k))) then
    out(cT,ok)
  else
    out(cT,ko)

process reader(j:index) =
  new nR;
  out(cR,nR);
  in(cT,x);
  try find i,k such that snd(x) = h(<<nR,fst(x)>,tag1>,diff(key(i),key'(i,k))) in
    out(cR,h(<<snd(x),nR>,tag2>,diff(key(i),key'(i,k))))
  else
    out(cR,ko)

system ((!_j R: reader(j)) | (!_i !_k T: tag(i,k))).




goal [left] wa_left :
  forall (i:index, j:index, k:index),
  cond@R1(j,i,k) =>
  exists (ii:index,kk:index),
  T(ii,kk) <= R1(j,i,k) && i =ii && 
  fst(input@R1(j,i,k)) = fst(output@T(ii,kk)) &&
  snd(input@R1(j,i,k)) = snd(output@T(ii,kk)).
Proof.
simpl.
expand cond@R1(j,i,k).
apply tags_neq.
euf M0.
exists i,k1.
Qed.

goal [right] wa_right:
  forall (i:index, j:index, k:index),
  cond@R1(j,i,k) =>
  exists (ii:index,kk:index),
  T(ii,kk) <= R1(j,i,k) && i = ii && k = kk &&
  fst(input@R1(j,i,k)) = fst(output@T(ii,kk)) &&
  snd(input@R1(j,i,k)) = snd(output@T(ii,kk)).
Proof.
simpl.
expand cond@R1(j,i,k).
apply tags_neq.
euf M0.
exists i,k.
Qed.

goal wa_both:
 forall (i:index, j:index, k:index),
  cond@R1(j,i,k) =>
  exists (ii:index,kk:index),
  T(ii,kk) <= R1(j,i,k) && i =ii && 
  fst(input@R1(j,i,k)) = fst(output@T(ii,kk)) &&
  snd(input@R1(j,i,k)) = snd(output@T(ii,kk)).
Proof.
simpl.
expand cond@R1(j,i,k).
apply tags_neq.
project.
euf M0.
exists i, k1.
euf M0.
exists i, k.
Qed.

goal wa_inv:
 forall (i:index, j:index, k:index),
( exists (ii:index,kk:index),
  T(ii,kk) <= R1(j,i,k) && i =ii && 
  fst(input@R1(j,i,k)) = fst(output@T(ii,kk)) &&
  snd(input@R1(j,i,k)) = snd(output@T(ii,kk))) => cond@R1(j,i,k).
Proof.
simpl.
expand cond@R1(j,i,k).
project.
substitute ii, i.
expand output@T(i,kk).
euf D0.
simpl.
case H0.
substitute k1, kk.


equiv foo.
Proof.
induction t.
(* Case R: OK *)
expand frame@R(j); expand exec@R(j).
expand cond@R(j); expand output@R(j).
fa 1; fa 2.
fresh 2; yesif 2.
repeat split.
depends R(j1), R1(j1,i,k).
depends R(j1), R2(j1).

(* Case R1 *)
expand frame@R1(j,i,k); expand exec@R1(j,i,k).
(*expand cond@R1(j,i,k);*) 
expand output@R1(j,i,k).

fa 0.
fa 2.
fa 3.

equivalent   cond@R1(j,i,k),
  (exists (ii:index,kk:index),
  T(ii,kk) <= R1(j,i,k) && i = ii &&
  fst(input@R1(j,i,k)) = fst(output@T(ii,kk)) &&
  snd(input@R1(j,i,k)) = snd(output@T(ii,kk))).
split.
intros.
project.
expand cond@R1(j,i,k).
apply tags_neq.
euf M0.
exists i, k1.
expand cond@R1(j,i,k).
apply tags_neq.
exists i,k.
split.
split.
euf M0.
euf M0.
euf M0.
simpl.
substitute ii,i.
expand output@T(i,kk).
expand m2(i,kk)@T(i,kk).
expand cond@R1(j,i,k).
assert(k=kk).
admit.
substitute kk, k.
project.
help.
assert (input@T(i,k) = nR(j)).
admit.
assert (input@T(i,k) = nR(j)).
admit.
prf 3.
yesif 3.
apply tags_neq.
project.
repeat split.

apply M1.
simpl M0.

dup D2.
project.
refl M2.
expand cond@R1(k,i,k).

intro.
expand cond@R1(k,i,k).


exists i,k.
project.
expand cond@R1(j,i,k).
expand output@T(ii,kk).
expand m2(ii,kk)@T(ii,kk).

intro.
admit.

prf 3.
yesif 3.
apply tags_neq.


project.
repeat split.
case H0.

intro.

help.
intro.
*)
(*
assert( forall (i,j,k:index),  (cond@R1(j,i,k)) =>
  (exists (ii:index,kk:index),
  T(ii,kk) <= R1(j,i,k) &&
  fst(input@R1(j,i,k)) = fst(output@T(ii,kk))) &&
  snd(input@R1(j,i,k)) = snd(output@T(ii,kk))).
*)

(* Case R2 *)
admit.

(*expand frame@R2(j).
expand exec@R2(j).
expand cond@R2(j).
expand output@R2(j).
prf 0.

admit.
*)

(* Case T *)
expand frame@T(i,k).
expand exec@T(i,k).
expand cond@T(i,k).
expand output@T(i,k).
fa 1.
fa 2.
fa 2.
expand m2(i,k)@T(i,k).
prf 3.
yesif 3.
apply tags_neq.
project.

repeat split.
case H0.
case H0.
depends T(i1,k1),T1(i1,k1).
depends T(i1,k1),T1(i1,k1).
case H0.
depends T(i1,k1),T2(i1,k1).
depends T(i1,k1),T2(i1,k1).
assert (nT(i,k) = fst(input@R2(j))).
case H0.
admit. (* TODO fresh M2 *)
admit. (* TODO fresh M2 *)
assert (nT(i,k) = fst(input@R1(j,i1,k1))).
case H0.
admit.  (* TODO fresh M3 *)
admit. (* TODO fresh M3 *)

repeat split.
assert (nT(i,k) = fst(input@R1(j,i1,k1))).
case H0.
admit. (* TODO fresh ? *)
admit. 
assert (nT(i,k) = fst(input@R2(j))).
case H0.
admit. (* TODO fresh ? *)
admit. (* TODO fresh ? *)
depends T(i1,k1), T2(i1,k1).
case H0.
depends T(i1,k1), T1(i1,k1).
case H0.
depends T(i1,k1), T1(i1,k1).
case H0.
fresh 2.
yesif 2.
repeat split.
depends T(i1,k1), T2(i1,k1).
depends T(i1,k1), T1(i1,k1).
depends T(i1,k1), T2(i1,k1).
depends T(i1,k1), T1(i1,k1).


(* Case T1 *)
admit.
(* Case T2 *)
admit.
Qed.





(*
apply T0.
help.
admit.
expand frame@R1(j,k,i).
fa 1.
expand exec@R1(j,k,i).
help.
expand output@R1(j,k,i).
help.
noif 2.
intros.
expand cond@R1(j,k,i).
help.
prf M0.

euf M0.
fresh 2.

assumption.

intros.

simpl.


    expand cond@R(j);
expand output@R(j).
  fa 0.
  equivalent
    (exists (i,k:index), snd(input@R(j))=h(fst(input@R(j)),diff(key(i),key'(i,k)))),
    (exists (i,k:index), T(i,k)<R(j) &&
       fst(output@T(i,k))=fst(input@R(j)) &&
       snd(output@T(i,k))=snd(input@R(j))).
  split; intros.
  project; euf M0.
  exists i,k1.
  exists i,k.
  exists i,k.
  admit 1. (* TODO fa/dup *)



  expand frame@R1(j); expand exec@R1(j);
    expand cond@R1(j); expand output@R1(j).
  fa 0.
  equivalent
    (exists (i,k:index),
       snd(input@R1(j))=h(fst(input@R1(j)),diff(key(i),key'(i,k)))),
    (exists (i,k:index),
       T(i,k)<R1(j) &&
       fst(output@T(i,k))=fst(input@R1(j)) &&
       snd(output@T(i,k))=snd(input@R1(j))).
  split; intros.
  project.
  euf M0.
  exists i,k1.
  euf M0.
  exists i,k.
  exists i,k.
     admit 1. (* TODO fa/dup *)


  expand frame@T(i,k); expand exec@T(i,k);
  expand cond@T(i,k); expand output@T(i,k).
  fa 1. fa 2. fa 2.

  prf 3.
  yesif 3.
  split.

  (* Left. *)
  (* nT(i,k) is fresh for each tag session so input@R(j) cannot contain
  nT(i,k) if R(j) happens before T(i,k).  *)
  split.
  assert (forall (i,j,k:index), R(j) <= pred(T(i,k)) => fst(input@R(j)) <> nT(i,k)).
  admit.
  apply H0 to i,j,k.
  assert (forall (i,j,k:index), R1(j) <= pred(T(i,k)) => fst(input@R1(j)) <> nT(i,k)).
  admit.
  apply H0 to i,j,k.

  (* Right. *)
  (* Same remark. *)
  split.
  assert (forall (i,j,k:index), R(j) <= pred(T(i,k)) => fst(input@R(j)) <> nT(i,k)).
  admit.
  apply H0 to i,j,k.
  assert (forall (i,j,k:index), R1(j) <= pred(T(i,k)) => fst(input@R1(j)) <> nT(i,k)).
  admit.
  apply H0 to i,j,k.

  fresh 2.
  yesif 2.
  split.

Qed.


*)

