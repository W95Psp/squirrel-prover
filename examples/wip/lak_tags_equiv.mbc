hash h

abstract ok:message
abstract ko:message

abstract tag1:message
abstract tag2:message
axiom tags_neq : tag1 <> tag2

name key : index->message
name key': index->index->message
channel cT
channel cR

process tag(i:index,k:index) =
  new nT;
  in(cR,nR);
  let m2 = h(<<nR,nT>,tag1>,diff(key(i),key'(i,k))) in
  out(cT,<nT,m2>);
  in(cR,m3);
  if m3 = h(<<m2,nR>,tag2>,diff(key(i),key'(i,k))) then
    out(cT,ok)
  else
    out(cT,ko)

process reader(j:index) =
  new nR;
  out(cR,nR);
  in(cT,x);
  try find i,k such that snd(x) = h(<<nR,fst(x)>,tag1>,diff(key(i),key'(i,k))) in
    out(cR,h(<<snd(x),nR>,tag2>,diff(key(i),key'(i,k))))
  else
    out(cR,ko)

system ((!_j R: reader(j)) | (!_i !_k T: tag(i,k))).



goal [left] wa_left :
  forall (i:index, j:index, k:index),
  cond@R1(j,i,k) =>
  exists (ii:index,kk:index),
  T(ii,kk) <= R1(j,i,k) &&
  fst(input@R1(j,i,k)) = fst(output@T(ii,kk)) &&
  snd(input@R1(j,i,k)) = snd(output@T(ii,kk)).
Proof.
simpl.
expand cond@R1(j,i,k).
apply tags_neq.
euf M0.
exists i,k1.
Qed.

goal [right] wa_right:
  forall (i:index, j:index, k:index),
  cond@R1(j,i,k) =>
  exists (ii:index,kk:index),
  T(ii,kk) <= R1(j,i,k) &&
  fst(input@R1(j,i,k)) = fst(output@T(ii,kk)) &&
  snd(input@R1(j,i,k)) = snd(output@T(ii,kk)).
Proof.
simpl.
expand cond@R1(j,i,k).
apply tags_neq.
euf M0.
exists i,k.
Qed.


equiv foo.
Proof.
induction t.
(* Case R: OK *)
expand frame@R(j); expand exec@R(j).
expand cond@R(j); expand output@R(j).
fa 1; fa 2.
fresh 2; yesif 2.
repeat split.
depends R(j1), R1(j1,i,k).
depends R(j1), R2(j1).

(* Case R1 *)
admit.

(*expand frame@R1(j,i,k); expand exec@R1(j,i,k).
expand cond@R1(j,i,k); expand output@R1(j,i,k).
fa 0.
fa 2.
fa 3.
prf 3.
yesif 3.
intro.

help.
intro.
*)
(*
assert( forall (i,j,k:index),  (cond@R1(j,i,k)) =>
  (exists (ii:index,kk:index),
  T(ii,kk) <= R1(j,i,k) &&
  fst(input@R1(j,i,k)) = fst(output@T(ii,kk))) &&
  snd(input@R1(j,i,k)) = snd(output@T(ii,kk))).
*)

(* Case R2 *)
admit.

(*expand frame@R2(j).
expand exec@R2(j).
expand cond@R2(j).
expand output@R2(j).
prf 0.

admit.
*)

(* Case T *)
expand frame@T(i,k).
expand exec@T(i,k).
expand cond@T(i,k).
expand output@T(i,k).
fa 1.
fa 2.
fa 2.
expand m2(i,k)@T(i,k).
prf 3.
yesif 3.
apply tags_neq.
help.
project.

repeat split.
case H0.
assert (nT(i,k) = fst(left(input@R2(j)))).
admit. (* TODO fresh M2 *)
admit.
admit.
case H0.
admit. (* TODO fresh ? *)
admit. (* TODO fresh ? *)
case H0.
admit.
admit.
fresh 2.
yesif 2.
split.
split.
depends T(i1,k1),T1(i1,k1).
depends T(i1,k1),T2(i1,k1).
split.
depends T(i1,k1),T1(i1,k1).
depends T(i1,k1),T2(i1,k1).

(* Case T1 *)
admit.
(* Case T2 *)
admit.
Qed.





(*
apply T0.
help.
admit.
expand frame@R1(j,k,i).
fa 1.
expand exec@R1(j,k,i).
help.
expand output@R1(j,k,i).
help.
noif 2.
intros.
expand cond@R1(j,k,i).
help.
prf M0.

euf M0.
fresh 2.

assumption.

intros.

simpl.


    expand cond@R(j);
expand output@R(j).
  fa 0.
  equivalent
    (exists (i,k:index), snd(input@R(j))=h(fst(input@R(j)),diff(key(i),key'(i,k)))),
    (exists (i,k:index), T(i,k)<R(j) &&
       fst(output@T(i,k))=fst(input@R(j)) &&
       snd(output@T(i,k))=snd(input@R(j))).
  split; intros.
  project; euf M0.
  exists i,k1.
  exists i,k.
  exists i,k.
  admit 1. (* TODO fa/dup *)



  expand frame@R1(j); expand exec@R1(j);
    expand cond@R1(j); expand output@R1(j).
  fa 0.
  equivalent
    (exists (i,k:index),
       snd(input@R1(j))=h(fst(input@R1(j)),diff(key(i),key'(i,k)))),
    (exists (i,k:index),
       T(i,k)<R1(j) &&
       fst(output@T(i,k))=fst(input@R1(j)) &&
       snd(output@T(i,k))=snd(input@R1(j))).
  split; intros.
  project.
  euf M0.
  exists i,k1.
  euf M0.
  exists i,k.
  exists i,k.
     admit 1. (* TODO fa/dup *)


  expand frame@T(i,k); expand exec@T(i,k);
  expand cond@T(i,k); expand output@T(i,k).
  fa 1. fa 2. fa 2.

  prf 3.
  yesif 3.
  split.

  (* Left. *)
  (* nT(i,k) is fresh for each tag session so input@R(j) cannot contain
  nT(i,k) if R(j) happens before T(i,k).  *)
  split.
  assert (forall (i,j,k:index), R(j) <= pred(T(i,k)) => fst(input@R(j)) <> nT(i,k)).
  admit.
  apply H0 to i,j,k.
  assert (forall (i,j,k:index), R1(j) <= pred(T(i,k)) => fst(input@R1(j)) <> nT(i,k)).
  admit.
  apply H0 to i,j,k.

  (* Right. *)
  (* Same remark. *)
  split.
  assert (forall (i,j,k:index), R(j) <= pred(T(i,k)) => fst(input@R(j)) <> nT(i,k)).
  admit.
  apply H0 to i,j,k.
  assert (forall (i,j,k:index), R1(j) <= pred(T(i,k)) => fst(input@R1(j)) <> nT(i,k)).
  admit.
  apply H0 to i,j,k.

  fresh 2.
  yesif 2.
  split.

Qed.


*)

