hash h

abstract ok:message
abstract ko:message


name key : index->message
name key': index->index->message
channel cT
channel cR

process tag(i:index,k:index) =
  new nT;
  in(cR,nR);
  let m2 = h(<nR,nT>,diff(key(i),key'(i,k))) in
  out(cT,<nT,m2>)

process reader(j:index) =
  new nR;
  out(cR,nR);
  in(cT,x);
  try find i,k such that snd(x) = h(<nR,fst(x)>,diff(key(i),key'(i,k))) in
    out(cR,ok)
  else
    out(cR,ko)

system ((!_j R: reader(j)) | (!_i !_k T: tag(i,k))).



equiv foo.
Proof.
induction t.
(* Case R *)
expand frame@R(j); expand exec@R(j).
expand cond@R(j); expand output@R(j).
fa 1; fa 2.
fresh 2; yesif 2.
repeat split.
depends R(j1), R1(j1,i,k).
depends R(j1), R2(j1).


(* Case R1 *)
expand frame@R1(j,i,k);expand exec@R1(j,i,k).
expand cond@R1(j,i,k);expand output@R1(j,i,k).
fa 0.

equivalent 
(snd(input@R1(j,i,k)) = h(<nR(j),fst(input@R1(j,i,k))>,(diff(key(i), key'(i,k))))),
(T(i,k) < R1(j,i,k) &&
snd(output@T(i,k)) = snd(input@R1(j,i,k)) &&
 fst(output@T(i,k)) = fst(input@R1(j,i,k)) &&  input@T(i,k) = output@R(j)
&&  (input@T(i,k) = output@R(j) => R(j) < T(i,k))
  ).

split.


(* cond ==> WA *)
project.
(* left *)
euf M0.
repeat split.
assert (input@T(i,k1) = nR(j)).
admit. (* FAUX - lemma states in equivalent tactic is too strong on its left projection *)
admit.
admit.
admit.

(* right *)
euf M0.
assert (input@T(i,k) = nR(j)).
admit. (* nR(j) is a fresh nonce necessary to fill the input of T(i1,k1) *)

(* WA ==> cond *)
(* nothing to do - automatic ?*)

admit. (*fadup*)



(* Case R2 *)

expand frame@R2(j);expand exec@R2(j).
expand cond@R2(j);expand output@R2(j).
fa 0.


equivalent 
(exists  (i,k:index), snd(input@R2(j)) =
   h(<nR(j),fst(input@R2(j))>,(diff(key(i), key'(i,k))))),
(exists (i,k:index), T(i,k) < R2(j) &&
snd(output@T(i,k)) = snd(input@R2(j)) &&
 fst(output@T(i,k)) = fst(input@R2(j)) &&  input@T(i,k) = output@R(j)
&&  (input@T(i,k) = output@R(j) => R(j) < T(i,k))
  )
.

split.
(* cond => WA *)
project.
(* left *)
euf M0.
exists i,k1.
assert (input@T(i,k1) = nR(j)).
admit. (* legitime - frehsness *)

(* right *)
euf M0.
exists i,k.
assert (input@T(i,k) = nR(j)).
admit. (* legitime - freshness *)

(* WA => cond *)
exists i,k.
admit. (*replace thanks to the lemma proved in equivalent tactic *)

(* Case T *)
expand frame@T(i,k);expand exec@T(i,k).
expand cond@T(i,k);expand output@T(i,k).


fa 1.
fa 2.
fa 2.
expand m2(i,k)@T(i,k).
prf 3.
yesif 3.
project.

(* left *)
repeat split.
assert (nT(i,k) = fst(input@R2(j))).
admit. (* TODO fresh *)
assert (nT(i,k) = fst(input@R1(j,i1,k1))).
admit. (* TODO fresh *)

(* right *)
repeat split.
assert (nT(i,k) = fst(input@R1(j,i1,k1))).
admit. (* TODO fresh *)
assert (nT(i,k) = fst(input@R2(j))).
admit. (* TODO fresh *)

fresh 2.
yesif 2.
Qed.

