hash h

abstract ok:message
abstract ko:message

name key : index->message

channel cT
channel cR

(* TODO when macro support is complete, use the definitions
 * of m2, x1, and x2 which are currently inlined below *)

process tag(i:index) =
  new nT;
  in(cR,nR);
  let m2 = h(<nR,nT>,key(i)) in
  out(cT,<nT,h(<nR,nT>,key(i))>);
  in(cR,m3);
  if m3@nT = h(<h(<nR,nT>,key(i)),nR>,key(i)) then
    out(cT,ok)
  else
    out(cT,ko)

process reader(j:index) =
  new nR;
  out(cR,nR);
  in(cT,x);
  (* TODO let <x1,x2> = x in *)
  let x1 = fst(x) in
  let x2 = snd(x) in
  try find i such that snd(x) = h(<nR,fst(x)>,key(i)) in
    out(cR,h(<snd(x),nR>,key(i)))
  else
    out(cR,ko)

system ((!_j R: reader(j)) | (!_i !_k T: tag(i))).

(* TODO In the next lemma, it would be more natural to write
 * something like happens(ACTION) rather than ACTION=ACTION.
 * This could be left implicit since ACTION occurs in the
 * rest of the formula. The only cases I can think of where
 * the implicit treatment might not work is that of unreachability
 * statements: forall k, not(happens(ACTION)). *)
(* TODO we should not get a type error when using an inexistent
 *   action name *)
goal wa :
  forall (i:index, j:index),
  output@R1(j,i) = output@R1(j,i) =>
  exists (ii:index,k:index) such that
  R1(j,i) > T1(ii,k),
  input@R1(j,i) = output@T1(ii,k).
Proof.
  euf 1.
  (* TODO at this point eqnames should allow to conclude
   * (perhaps after an assert, which will only work when reasoning
   * on pairs and projections is completed) because we have
   *   snd(input@..) = h(..) = nR(..)
   * where the name does not occur in the hash. *)
  assert(fst(<snd(input@R1(j5,i1)), nR(j5)>) =
         fst(<nR(j), fst(input@R1(j,i))>)).
  (* TODO this assert is so obvious
       that the addition of the fact is cancelled *)
  assert(h(<nR(j5), fst(input@R1(j5,i1))>, key(i1)) = nR(j)).
  admit. (* need full support of fst(_) *)

  eqnames. (* should add j = j 5 *)
  assert(nR(j) = nR(j5)). (* TODO cannot simply write j=j5 *)
  admit.
