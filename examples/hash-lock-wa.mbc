hash h

abstract ok:message
abstract ko:message


name key': index->index->message
channel cT
channel cR


process tag(i:index,k:index) =
  new nT;
  in(cR,nR);
  out(cT,<nT,h(<nR,nT>,key'(i,k))>)

process reader(j:index) =
  new nR;
  out(cR,nR);
  in(cT,x);
   if exists (i,k:index), snd(x) = h(<nR,fst(x)>,key'(i,k)) then 
    out(cR,ok)
   else 
    out(cR,ko) 

system ((!_j R:reader(j)) | (!_i !_k T: tag(i,k))).

goal wa:
forall (j:index), cond@R1(j) => (exists (i,k:index), T(i,k) < R1(j) && 
 snd(output@T(i,k)) = snd(input@R1(j)) &&
 fst(output@T(i,k)) = fst(input@R1(j)) &&  
 input@T(i,k) = output@R(j) &&   R(j) < T(i,k)).

Proof.
intro.
expand cond@R1(j).
euf M0.
exists i, k.
assert (input@T(i,k) = nR(j)).
fresh M2.
case H0.
depends R(j), R2(j).
Qed.

