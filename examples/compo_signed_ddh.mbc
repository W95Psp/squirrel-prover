(** Example of signed DDH key exchange. It corresponds to the  ISO 9798-3 protocol. **)

abstract ok : message
abstract ko : message

name kP : message
name kS : message

mutable keyS : index -> message
mutable keyP : index -> message

channel cP
channel cS


name a1 : message
name b1 : message
name k11 : message
name a : index -> message
name b : index -> message
name k : index -> index -> message

axiom DDHgroup : forall (x1,x2:message), x1 <> x2 => g^x1 <> g^x2

signature sign,checksign,pk with oracle forall (m:message,sk:message)
 (sk <> kP || exists (i:index, x1:message, x2:message) m=<<x1,g^a(i)>,x2> )
  &&
 (sk <> kS || exists (i:index, x1:message, x2:message) m=<<x1,g^b(i)>,x2>)

hash h

process P =
  out(cP, <pk(kP),g^a1>);
  in(cP, t);
  let gS = snd(fst(t)) in
  let pkS = fst(fst(t)) in
  if checksign(snd(t),pkS) = <<g^a1,gS>,pk(kP)> then
    out(cP,sign(<<gS,g^a1>,pkS>,kP));
    in(cP, challenge);
    if pkS= pk(kS) then
      if snd(fst(t)) = g^b1 then
        out(cP, g^a1^b1)
      else
      (try find j such that snd(fst(t)) = g^b(j) in
        out(cP, ok)
      else
       out(cP, diff(ok,ko))
       )


process S =
  in(cS, sP);
  let gP = snd(sP) in
  let pkP = fst(sP) in
  out(cS, < <pk(kS),g^b1>, sign(<<gP,g^b1>,pkP>,kS)>);
  in(cS, signed);
  if checksign(signed,pkP) = <<g^b1,gP>,pk(kS)> then
    out(cS,ok);
    in(cS, challenge);
    if pkP=pk(kP) then
     (if gP = g^a1 then
      out(cS, g^a1^b1)
      else
       (try find l such that gP = g^a(l) in
        out(cS, ok)
	else
	out(cS, diff(ok,ko))
	 )
      )
	  else null

system [auth] ( P | S).


process P2 =
  out(cP, <pk(kP),g^a1>);
  in(cP, t);
  let gS = snd(fst(t)) in
  let pkS = fst(fst(t)) in

  if checksign(snd(t),pkS) = <<g^a1,gS>,pk(kP)> then
    out(cP,sign(<<gS,g^a1>,pkS>,kP));

  in(cP, challenge);
  if pkS= pk(kS) then
    if snd(fst(t)) = g^b1 then
      out(cP, diff(g^a1^b1,g^k11))

process S2 =
	in(cS, sP);
	let gP = snd(sP) in
	let pkP = fst(sP) in
	out(cS, < <pk(kS),g^b1>, sign(<<gP,g^b1>,pkP>,kS)>);
	in(cS, signed);
        if checksign(signed,pkP) = <<g^b1,gP>,pk(kS)> then
	out(cS,ok);
	in(cS, challenge);
	if pkP=pk(kP) then

     if gP = g^a1 then
      out(cS, diff(g^a1^b1,g^k11))

system [secret] ( P2 | S2).


(* We prove several lemmas, characterizing when a action's conditions passes.
   The characterization is expressed as a property of the trace that the attacker
   already has, showing that the condition does not bring him extra knowledge.

   Prove that the condition of A does not give any information to the attacker,
   by proving that it is equivalent to a trivial formula that the attacker can
   compute. It is a bit troublesome, because the formula depends on ks, which needs
   to disappear. We would not have this issue if we used a classical asymmetric
   signature scheme. *)

(* Show that conditio *)
goal [none, auth] S1_charac :
  cond@S1 => (cond@S4 => False) .
Proof.
  simpl.
  expand cond@S1; expand cond@S4.
  expand pkP@S1.
  substitute fst(input@S), pk(kP).
  introsleft H0.
  euf M1.

  case H2.
  apply H1 to i.

  notleft H0.
Qed.

(* Show that condition S1 implies the next one. *)
goal [none, auth] P1_charac :
   cond@P1 => (cond@P4 => False).
Proof.
  simpl.
  expand cond@P1; expand cond@P4.
  introsleft H0.
  substitute pkS@P1,pk(kS).
  euf M1.

  case H3.
  apply H1 to i.

  notleft H0.
Qed.

equiv [left,secret] [right,secret] secret.
Proof.
   ddh a1, b1, k11.
Qed.

equiv [left, auth] [right, auth] auth.
Proof.
       enrich kP; enrich g^a1; enrich g^b1; enrich kS; enrich g^a1^b1.
   enrich seq(i-> g^b(i)).    enrich seq(i-> g^a(i)).
   induction t.

   expandall.
   fa 8.

   expand seq(i->g^b(i)),j.

       expand frame@P4; expand exec@P4.
       fa 8.  equivalent cond@P4,False.
       simpl.
       executable pred(P4). depends P1, P4. apply H1 to P1. apply P1_charac.
       noif 9. simpl.

    expandall.
    fa 8.

        expand seq(i->g^a(i)),l.

       expand frame@S4; expand exec@S4.
       equivalent cond@S4,False.
       simpl.
       executable pred(S4). depends S1, S4. apply H1 to S1. apply S1_charac.
       fa 8.   noif 9. simpl.
Qed.
