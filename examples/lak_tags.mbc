hash h

abstract ok:message
abstract ko:message

abstract tag1:message
abstract tag2:message
axiom tags_neq : tag1 <> tag2

name key : index->message

channel cT
channel cR

process tag(i:index) =
  new nT;
  in(cR,nR);
  let m2 = h(<<nR,nT>,tag1>,key(i)) in
  out(cT,<nT,m2>);
  in(cR,m3);
  if m3@nT = h(<<m2,nR>,tag2>,key(i)) then
    out(cT,ok)
  else
    out(cT,ko)

process reader(j:index) =
  new nR;
  out(cR,nR);
  in(cT,x);
  try find i such that snd(x) = h(<<nR,fst(x)>,tag1>,key(i)) in
    out(cR,h(<<snd(x),nR>,tag2>,key(i)))
  else
    out(cR,ko)

system ((!_j R: reader(j)) | (!_i !_k T: tag(i))).

goal wa :
  forall (i:index, j:index),
  happens(R1(j,i)) =>
  exists (ii:index,k:index),
  T(ii,k) <= R1(j,i) &&
  fst(input@R1(j,i)) = fst(output@T(ii,k)) &&
  snd(input@R1(j,i)) = snd(output@T(ii,k)).
Proof.
  euf C0.
  apply tags_neq.
  exists i,k.
Qed.
