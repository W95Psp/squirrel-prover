hash h

abstract ok:message
abstract ko:message

name key : index->message
name key' : index->index->message

channel cT
channel cR

process tag(i:index,k:index) =
  new nT;
  out(cT, <nT, h(nT,diff(key(i),key'(i,k)))>)

process reader(j:index) =
  in(cT,x);
  if exists (i,k:index), snd(x) = h(fst(x),diff(key(i),key'(i,k))) then
    out(cR,ok)
  else
    out(cR,ko)

system ((!_j R: reader(j)) | (!_i !_k T: tag(i,k))).

(* Preliminary trace properties: well-authentication
 *
 * This needs to be proved separately for each projection of the biprocess,
 * because the euf tactic requires atomic keys.
 *
 * These goals are here for testing/illustration purposes: in the final
 * diff-equivalence proof we do not explicitly invoke them but reprove
 * them as well as variants (e.g. for action R1 rather than R). *)

goal [left] wa_R_left :
  forall (j:index),
  exec@R(j) =>
  exists (i:index,k:index),
  T(i,k) < R(j) &&
  fst(input@R(j)) = nT(i,k).
Proof.
  intros.
  expand exec@R(j); expand cond@R(j).
  euf M0.
  exists i, k1.
Qed.

goal [right] wa_R_right :
  forall (j:index),
  happens(R(j)) =>
  exists (i:index,k:index),
  T(i,k) < R(j) &&
  fst(input@R(j)) = nT(i,k).
Proof.
 intros.
 euf M0.
 exists i, k.
Qed.

(* Diff-equivalence of the system bi-process. *)

equiv foo.
Proof.
  induction t.


  expand frame@R(j); expand exec@R(j);
    expand cond@R(j); expand output@R(j).
  equivalent
    (exists (i,k:index), snd(input@R(j))=h(fst(input@R(j)),diff(key(i),key'(i,k)))),
    (exists (i,k:index), T(i,k)<R(j) &&
       fst(output@T(i,k))=fst(input@R(j)) &&
       snd(output@T(i,k))=snd(input@R(j))).
  split; intros.
  project; euf M0.
  exists i,k1.
  exists i,k.
  exists i,k.
  (* TODO fa/dup should be able to to remove the right part
   * of the conjunction, leaving only the exec part -- however,
   * without the "exec && ..." part it seems hard to justify the
   * erasure of outputs. *)
  fa 0.
  admit 1. (* TODO fa/dup *)


  expand frame@R1(j); expand exec@R1(j);
    expand cond@R1(j); expand output@R1(j).
  equivalent
    (exists (i,k:index),
       snd(input@R1(j))=h(fst(input@R1(j)),diff(key(i),key'(i,k)))),
    (exists (i,k:index),
       T(i,k)<R1(j) &&
       fst(output@T(i,k))=fst(input@R1(j)) &&
       snd(output@T(i,k))=snd(input@R1(j))).
  split; intros.
  project.
  euf M0.
  exists i,k1.
  euf M0.
  exists i,k.
  exists i,k.
  (* TODO fa/dup as above *)
  fa 0.
  admit 1.


  expand frame@T(i,k); expand exec@T(i,k);
  expand cond@T(i,k); expand output@T(i,k).
  fa 1. fa 2. fa 2.
  prf 3.
  yesif 3.
  project.

  (* Left. *)
  split.
  (* nT(i,k) is fresh for each tag session so input@R(j) cannot contain
     nT(i,k) if R(j) happens before T(i,k).  *)
  assert (forall (i,j,k:index), R1(j) <= pred(T(i,k)) => fst((input@R1(j))) <> nT(i,k)).
  admit.
  apply H0 to i,j,k.
  assert (forall (i,j,k:index), R(j) <= pred(T(i,k)) => fst((input@R(j))) <> nT(i,k)).
  admit.
  apply H0 to i,j,k.

  (* Right. *)
  (* Same remark. *)
  split.
  assert (forall (i,j,k:index), R(j) <= pred(T(i,k)) => fst((input@R(j))) <> nT(i,k)).
  admit.
  apply H0 to i,j,k.
  assert (forall (i,j,k:index), R1(j) <= pred(T(i,k)) => fst((input@R1(j))) <> nT(i,k)).
  admit.
  apply H0 to i,j,k.

  fresh 2. yesif 2.

Qed.
