hash h
name k:message
name cst:message

channel c

name na : index -> message
name nb : index -> message
name nc : index -> message
name mc : index -> message


axiom name_not_pair :
forall (ma : message, mb : message, a:index) :
na(a) <>  <ma, mb>

system  out(c,cst);
(
  (!_a out(c,h(na(a),k)))
  | (!_b out(c,h(<nb(b),nb(b)>,k)))
  | (!_c out(c,h(<nc(c),mc(c)>,k)))
 ).


goal dummy :
  forall (tau1 : timestamp, tau2 : timestamp, a : index, a: message)
  such that tau1 = tau2:
  output@tau1= output@tau2.
Proof.
Qed.

goal unforgeable_1 :
  forall (a : index, b : index)
  such that b <> a:
  output@0_0[b] = h(na(a),k) => exists () : false.

Proof.
  collision.
Qed.

goal unforgeable_2 :
  forall (a : index, b : index)
  such that b <> a:
  output@0_1[b] = h(na(a),k) => exists () : false.

Proof.
  collision.

  apply name_not_pair to
  nb(b),
  nb(b),
  a.
Qed.


goal unforgeable_3 :
  forall (a : index, b : index)
  such that b <> a:
  output@0_2[b] = h(na(a),k) => exists () : false.

Proof.
  collision.

  apply name_not_pair to
  nc(b),
  mc(b),
  a.
Qed.
