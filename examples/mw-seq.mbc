(* Protocol MW                          *)
(* R -> T: nr                           *)
(* T -> R: nt, id + H(<c0, nr, nt>,k)   *)
(* R -> T: id + H(<c1, nr, nt>,k)       *)

hash H

abstract id : index->message
abstract id': index->index->message

name key : index->message
name key': index->index->message

abstract ok : message
abstract ko : message
abstract error : message
abstract tag0 : message
abstract tag1 : message
axiom tags_neq : tag0 <> tag1

channel c

process tag(i:index, t:index)=
  in(c,x);
  new nt;
  out(c,<nt,xor(diff(id(i),id'(i,t)),H(<tag0,<x,nt>>,diff(key(i),key'(i,t))))>);
  in(c,y);
  if y = xor(diff(id(i),id'(i,t)),H(<tag1,<x,nt>>,diff(key(i),key'(i,t)))) then out(c,ok)
  else out(c,ko)

process reader =
  new nr;
  out(c,nr);
  in(c,m);
  if exists (i,t:index),
     xor(diff(id(i),id'(i,t)),snd(m)) =
     H(<tag0,<nr,fst(m)>>,diff(key(i),key'(i,t)))
  then
    out(c, try find i,t such that
             xor(diff(id(i),id'(i,t)),snd(m)) =
             H(<tag0,<nr,fst(m)>>,diff(key(i),key'(i,t)))
           in
             xor(diff(id(i),id'(i,t)),
                 H(<tag1,<nr,fst(m)>>,diff(key(i),key'(i,t)))))
  else
    out(c,error)

system (!_r R: reader | !_i !_t T: tag(i,t)).

(* Well-authentication for R1's condition, formulated in an imprecise
   way with respect to the involved indices. *)
goal wa_R1 : forall r:index,
  (exists (i,t:index),
   xor(diff(id(i),id'(i,t)),snd(input@R1(r))) =
   H(<tag0,<nr(r),fst(input@R1(r))>>,diff(key(i),key'(i,t))))
  <=>
  (exists (i,t:index),
   T(i,t) < R1(r) &&
   snd(output@T(i,t)) = snd(input@R1(r)) &&
   fst(output@T(i,t)) = fst(input@R1(r)) &&
   R(r) < T(i,t) &&
   output@R(r) = input@T(i,t)).
Proof.

  intros; split.

  (* Cond => WA *)
  project.
  (* left *)
  euf M0.
  exists i,t1.
  assert (input@T(i,t1) = nr(r)).
  fresh M2.
  depends R(r), R2(r).
  (* right *)
  euf M0.
  exists i,t.
  assert (input@T(i,t) = nr(r)).
  fresh M2.
  depends R(r), R2(r).

  (* WA => Cond *)
  exists i,t.

Qed.

(** Same as before, but more precise wrt i, for the left process.
    There has to remain an existential quantification on t,
    because it is not involved in the condition. *)
goal [left] wa_R1_left : forall (i,r:index),
  xor(id(i),snd(input@R1(r))) =
  H(<tag0,<nr(r),fst(input@R1(r))>>,key(i))
  <=>
  exists t:index,
  T(i,t) < R1(r) &&
  snd(output@T(i,t)) = snd(input@R1(r)) &&
  fst(output@T(i,t)) = fst(input@R1(r)) &&
  R(r) < T(i,t) &&
  output@R(r) = input@T(i,t).
Proof.
  intros.
  euf M0.
  exists t.
  assert input@T(i,t) = nr(r).
  fresh M2.
  depends R(r), R2(r).
Qed.

(** Precise version of wa_R1 on the right: no more existentials. *)
goal [right] wa_R1_right : forall (i,t,r:index),
  xor(id'(i,t),snd(input@R1(r))) =
  H(<tag0,<nr(r),fst(input@R1(r))>>,key'(i,t))
  <=>
  T(i,t) < R1(r) &&
  snd(output@T(i,t)) = snd(input@R1(r)) &&
  fst(output@T(i,t)) = fst(input@R1(r)) &&
  R(r) < T(i,t) &&
  output@R(r) = input@T(i,t).
Proof.
  intros.
  euf M0.
  assert input@T(i,t) = nr(r).
  fresh M2.
  depends R(r), R2(r).
Qed.

equiv unlinkability.
Proof.

(* Before starting the proof by induction we enrich the biframe.
   The following sequences over-approximate the messages that the
   attacker may learn during protocol executions. Note that the
   hashes using tag0 contain an arbitrart input@T(i,t) because
   no authentication can be guaranteed at this point, while
   hashes using tag1 contain a fixed message <nr(r),nt(i,t)>
   since past execution conditions can guarantee that only
   this content can be hashed.

   Due to the addition of these sequences the cases where tau is
   some action of the protocol are eased (we can use dup) and some
   of the difficulty is moved to the base case (tau = init).
   The biframe in that base case only contains these sequences.
   We cannot formally prove that it is indistinguishable, because
   we lack a notion of induction on sequences. However, the essence
   of the proof is simple:
   - we can get rid of tag1 hashes using prf and fresh
     because these hashed messages are distinct from the tag0 messages
     by tags_neq, and pairwise distinct thanks to the nonces nr(r) and
     nt(i,t);
   - we can then get rid of tag0 hashes using prf and fresh
     because the nonce nt(i,t) guarantees that the hashed messages
     are pairwise distinct;
   - we can finally get rid of the nonces nr and nt in the first
     two sequences using fresh.
   The essence of this proof is formalized in mw-prelim.mbc. *)
enrich seq(r -> nr(r)).
enrich seq(i,t -> nt(i,t)).
enrich seq(i,t -> diff(id(i),id'(i,t)) XOR
                  H(<tag0,<input@T(i,t),nt(i,t)>>,diff(key(i),key'(i,t)))).
enrich seq(i,r,t -> diff(id(i),id'(i,t)) XOR
                    H(<tag1,<nr(r),nt(i,t)>>,diff(key(i),key'(i,t)))).
induction t.

(* Init case *)
admit. (* see mw-prelim *)

(* Case R - Done *)
expand seq(r->nr(r)), r.

(* Case R1  WIP *)
expand frame@R1(r); expand exec@R1(r).
expand cond@R1(r); expand output@R1(r).

equivalent
  (exists (i,t:index), xor(diff(id(i),id'(i,t)),snd(input@R1(r))) =
                       H(<tag0,<nr(r),fst(input@R1(r))>>,diff(key(i),key'(i,t)))),
  (exists (i,t:index), T(i,t) < R1(r) &&
   snd(output@T(i,t)) = snd(input@R1(r)) &&
   fst(output@T(i,t)) = fst(input@R1(r)) &&
   R(r) < T(i,t) &&
   output@R(r) = input@T(i,t)).
apply wa_R1 to r.

fa 5. fadup 4.

equivalent
  (if
      (exec@pred(R1(r)) &&
       exists (i,t:index),
       ((((T(i,t) < R1(r) && snd(output@T(i,t)) = snd(input@R1(r))) &&
          fst(output@T(i,t)) = fst(input@R1(r)))
         && R(r) < T(i,t))
        && output@R(r) = input@T(i,t)))
    then
      (try find i,t such that
         xor(diff(id(i),id'(i,t)),snd(input@R1(r))) =
         H(<tag0,<nr(r),fst(input@R1(r))>>,diff(key(i),key'(i,t))) in
         xor(diff(id(i),id'(i,t)),
             H(<tag1,<nr(r),fst(input@R1(r))>>,diff(key(i),key'(i,t)))))),
  (if
      (exec@pred(R1(r)) &&
       exists (i,t:index),
       ((((T(i,t) < R1(r) && snd(output@T(i,t)) = snd(input@R1(r))) &&
          fst(output@T(i,t)) = fst(input@R1(r)))
         && R(r) < T(i,t))
        && output@R(r) = input@T(i,t)))
      then
      (try find i,t such that
         exec@pred(R1(r)) &&
	 (T(i,t) < R1(r) &&
          snd(output@T(i,t)) = snd(input@R1(r)) &&
          fst(output@T(i,t)) = fst(input@R1(r)) &&
          R(r) < T(i,t) &&
          output@R(r) = input@T(i,t)) in
         xor(diff(id(i),id'(i,t)),
             H(<tag1,<nr(r),nt(i,t)>>,diff(key(i),key'(i,t)))))).

project.
  (* Left *)
  fa; try exists i,t.
  fa. apply wa_R1_left to i1,r. apply H1. exists t.
  (* Right *)
  fa; try exists i,t.
  fa. apply wa_R1_right to i1,t1,r. apply H1.

fa 6.
fadup 6.
fa 6.
expand seq(i,r,t->xor((diff(id(i),id'(i,t))),
                  H(<tag1,<nr(r),nt(i,t)>>,(diff(key(i),key'(i,t)))))),
       i,r,t.
fadup 6.

(* Case R2 *)
expand frame@R2(r); expand exec@R2(r).
expand cond@R2(r); expand output@R2(r).

(* Same as wa_R1 but with @R2 instead of @R1,
   and the equivalence is used under a negation. *)
equivalent
  (exists (i,t:index), xor(diff(id(i),id'(i,t)),snd(input@R2(r))) =
                 H(<tag0,<nr(r),fst(input@R2(r))>>,diff(key(i),key'(i,t)))),
  (exists (i,t:index), T(i,t) < R2(r) &&
    snd(output@T(i,t)) = snd(input@R2(r)) &&
    fst(output@T(i,t)) = fst(input@R2(r)) &&
    input@T(i,t) = output@R(r) &&   R(r) < T(i,t)).

apply tags_neq.
split.
(* proof of lemma: Cond => WA *)
project.
(* left *)
euf M1.
exists i,t1.
assert (nr(r) = input@T(i,t1)).
fresh M3.
depends R(r), R1(r).
(* right *)
euf M1.
exists i,t.
assert (nr(r) = input@T(i,t)).
fresh M3.
depends R(r), R1(r).

(* proof of lemma: WA => Cond *)
exists i,t.

fadup 4.

(* Case T *)
expand seq(i,t->nt(i,t)),i,t.
expand seq(i,t->xor((diff(id(i),id'(i,t))),
                H(<tag0,<input@T(i,t),nt(i,t)>>,(diff(key(i),key'(i,t)))))),i,t.

(* Case T1 *)
expand frame@T1(i,t); expand exec@T1(i,t).
equivalent exec@pred(T1(i,t)) && cond@T1(i,t),
  exec@pred(T1(i,t)) &&
  exists r:index,
  R1(r) < T1(i,t) &&
  input@T1(i,t) = output@R1(r) &&
  T(i,t) < R1(r) &&
  fst(input@R1(r)) = fst(output@T(i,t)) &&
  snd(input@R1(r)) = snd(output@T(i,t)) &&
  R(r) < T(i,t) &&
  input@T(i,t) = output@R(r).
expand cond@T1(i,t); split.
  (* Cond => Honest *)
  assert input@T1(i,t) XOR diff(id(i),id'(i,t)) =
         H(<tag1,<input@T(i,t),nt(i,t)>>,diff(key(i),key'(i,t))).
  apply tags_neq; project.
  (* Left *)
  euf M1.
  assert R1(r) < T1(i,t).
    case H1.
    depends T(i,t),T1(i,t).
  assert cond@R1(r).
    executable pred(T1(i,t)).
    apply H2 to R1(r); expand exec@R1(r).
  expand cond@R1(r).
  euf M4.
  exists r; split.
  case output@R1(r).
  euf M6.
  apply H2 to i,t.
  assert nr(r) = input@T(i,t).
  fresh M6.
  depends R(r),R2(r).
  (* Right *)
  euf M1.
  assert R1(r) < T1(i,t).
    case H1; depends T(i,t),T1(i,t).
  assert cond@R1(r).
    executable pred(T1(i,t)); apply H2 to R1(r); expand exec@R1(r).
  expand cond@R1(r).
  euf M4.
  exists r; split.
  case output@R1(r).
  euf M6.
  apply H2 to i,t.
  assert nr(r) = input@T(i,t).
  fresh M6.
  depends R(r),R2(r).
  (* Honest => Cond *)
  case output@R1(r).
  project; euf M4.
  apply H1 to i,t.

fa 5. fa 6.
fadup 4.

(* Case T2 *)
expand frame@T2(i,t); expand exec@T2(i,t); expand cond@T2(i,t).
equivalent
  (exec@pred(T2(i,t)) &&
   not(input@T2(i,t) =
       diff(id(i),id'(i,t)) XOR H(<tag1,<input@T(i,t),nt(i,t)>>,diff(key(i),key'(i,t))))),
  exec@pred(T2(i,t)) &&
  not(exists r:index,
      R1(r) < T2(i,t) &&
      input@T2(i,t) = output@R1(r) &&
      T(i,t) < R1(r) &&
      fst(input@R1(r)) = fst(output@T(i,t)) &&
      snd(input@R1(r)) = snd(output@T(i,t)) &&
      R(r) < T(i,t) &&
      input@T(i,t) = output@R(r)).
split; apply H1.
  (* Honest => Cond *)
  case output@R1(r).
  project; euf M4.
  apply H2 to i,t.
  (* Cond => Honest *)
  assert input@T2(i,t) XOR diff(id(i),id'(i,t)) =
         H(<tag1,<input@T(i,t),nt(i,t)>>,diff(key(i),key'(i,t))).
  apply tags_neq; project.
  (* Left *)
  euf M1.
  assert R1(r) < T2(i,t).
    case H2.
    depends T(i,t),T2(i,t).
  assert cond@R1(r).
    executable pred(T2(i,t)).
    apply H3 to R1(r); expand exec@R1(r).
  expand cond@R1(r).
  euf M4.
  exists r; split.
  case output@R1(r).
  euf M6.
  apply H3 to i,t.
  assert nr(r) = input@T(i,t).
  fresh M6.
  depends R(r),R2(r).
  (* Right *)
  euf M1.
  assert R1(r) < T2(i,t).
    case H2; depends T(i,t),T2(i,t).
  assert cond@R1(r).
    executable pred(T2(i,t)); apply H3 to R1(r); expand exec@R1(r).
  expand cond@R1(r).
  euf M4.
  exists r; split.
  case output@R1(r).
  euf M6.
  apply H3 to i,t.
  assert nr(r) = input@T(i,t).
  fresh M6.
  depends R(r),R2(r).

fa 5. fa 6.
fadup 4.

Qed.
