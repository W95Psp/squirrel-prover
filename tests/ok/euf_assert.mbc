hash h
name k:message
name cst:message

axiom fst : forall (m:message, n:message),
  fst(<m,n>) = m

channel c

name na : index -> message
name nb : index -> message
name nc : index -> message
name mc : index -> message
mutable input : message

axiom name_not_pair :
forall (ma : message, mb : message, a:index),
na(a) <>  <ma, mb>

system  out(c,cst);
(
  (!_a out(c,<h(na(a),k),na(a)>))
  |  (in(c,m1); out(c,m1); in(c,m2); if m1=<h(m2,k),m2> then input := m1)
 ).

goal unforgeable :
  forall (tau : timestamp, m : message, b:index),
  input@tau = <h(m,k),m> => exists (a:index),  m = na(a).
Proof.
    assert(fst(input@tau)=h(m,k)).
    cycle 1.
    euf 1.
    existsintro a_1.
    apply fst to h(m,k), m.
Qed.
