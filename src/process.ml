type pkind = (string * Sorts.esort) list

type id = string

type term = Theory.term
type formula = Theory.formula

(* TODO add parsing positions *)
type process =
  | Null
  | New of string * process
  | In of Channel.t * string * process
  | Out of Channel.t * term * process
  | Set of string * string list * term * process
  | Parallel of process * process
  | Let of string * term * process
  | Repl of string * process
  | Exists of string list * formula * process * process
  | Apply of id * term list
  | Alias of process * id

let rec pp_process ppf process =
  let open Fmt in
  let open Utils in
  match process with
  | Null ->  (styled `Blue (styled `Bold ident)) ppf "null"

  | Apply (s,l) ->
      pf ppf "@[<hov>%a@ %a@]"
        (styled `Bold (styled `Blue ident)) s
        (Fmt.list ~sep:(fun ppf () -> pf ppf "@ ") Theory.pp) l

  | Alias (p,a) ->
      pf ppf "@[%s:@ %a@]"
        a
        pp_process p

  | Repl (s, p) ->
    pf ppf "@[<hov 2>!_%s@ @[%a@]@]"
      s pp_process p

  | Set (s, indices, t, p) ->
    pf ppf "@[<hov 2>%s%a %a@ %a.@;@[%a@]@]"
      s
      (Utils.pp_list Fmt.string) indices
      (kw `Bold) ":="
      Theory.pp t
      pp_process p

  | New (s, p) ->
    pf ppf "@[<hov>%a %a;@ @[%a@]@]"
      (kw `Red) "new"
      (kw `Magenta) s
      pp_process p

  | In (c, s, p) ->
    pf ppf "@[<hov>%a(%a,@,%a);@ %a@]"
      (kw `Bold) "in"
      Channel.pp_channel c
      (styled `Magenta (styled `Bold ident)) s
      pp_process p

  | Out (c, t, p) ->
    pf ppf "@[<hov>%a(%a,@,%a);@ %a@]"
      (kw `Bold) "out"
      Channel.pp_channel c
      Theory.pp t
      pp_process p

  | Parallel (p1, p2) ->
    pf ppf "@[<hv>@[(%a)@] |@ @[(%a)@]@]"
      pp_process p1
      pp_process p2

  | Let (s, t, p) ->
    pf ppf "@[<v>@[<2>%a %a =@ @[%a@] %a@]@ %a@]"
      (kw `Bold) "let"
      (styled `Magenta (styled `Bold ident)) s
      Theory.pp t
      (styled `Bold ident) "in"
      pp_process p

  | Exists (ss, f, p1, p2) ->
    if ss = [] then
      pf ppf "@[<hov>%a %a %a@;<1 2>%a"
        (styled `Red (styled `Underline ident)) "if"
        Theory.pp f
        (styled `Red (styled `Underline ident)) "then"
        pp_process p1
    else
      pf ppf "@[<hov>%a %a %a %a %a@;<1 2>%a"
        (styled `Red (styled `Underline ident)) "find"
        (list Fmt.string) ss
        (styled `Red (styled `Underline ident)) "such that"
        Theory.pp f
        (styled `Red (styled `Underline ident)) "in"
        pp_process p1 ;
    if p2 <> Null then
      pf ppf "@ %a@;<1 2>%a@]"
      (styled `Red (styled `Underline ident)) "else"
      pp_process p2
    else
      pf ppf "@]"


(** Table of declared (bi)processes with their types.
  * TODO use Symbols ? *)
let pdecls : (string,pkind*process) Hashtbl.t = Hashtbl.create 97

let pkind_of_pname name = Hashtbl.find pdecls name

(** Type checking for processes *)
let rec check_proc env = function
  | Null -> ()
  | New (x, p) -> check_proc ((x, Sorts.emessage)::env) p
  | In (_,x,p) -> check_proc ((x, Sorts.emessage)::env) p
  | Out (_,m,p) ->
    Theory.check ~local:true env m Sorts.emessage ;
    check_proc env p
  | Set (s, l, m, p) ->
    let k = Theory.check_state s (List.length l) in
    Theory.check ~local:true env m k ;
    List.iter
      (fun x ->
         Theory.check ~local:true env (Theory.Var x) Sorts.eindex) l ;
    check_proc env p
  | Parallel (p, q) -> check_proc env p ; check_proc env q
  | Let (x, t, p) ->
    Theory.check ~local:true env t Sorts.emessage ;
    check_proc ((x, Sorts.emessage)::env) p
  | Repl (x, p) -> check_proc ((x, Sorts.eindex)::env) p
  | Exists (vars, test, p, q) ->
    check_proc env q ;
    let env =
      List.rev_append
        (List.map (fun x -> x, Sorts.eindex) vars)
        env
    in
    Theory.check ~local:true env test Sorts.eboolean ;
    check_proc env p
  | Apply (id, ts) ->
    begin
      try
        let kind,_ = pkind_of_pname id in
        if List.length kind <> List.length ts then
          raise @@
          Theory.(Conv (Arity_error (id, List.length ts, List.length kind)));
        List.iter2
          (fun (_, k) t -> Theory.check ~local:true env t k)
          kind ts
      with
      | Not_found -> raise @@ Theory.(Conv (Undefined id))
    end
  | Alias (p,_) -> check_proc env p

let declare id args proc =
  if Hashtbl.mem pdecls id then raise @@ Symbols.Multiple_declarations id;
  check_proc args proc ;
  Hashtbl.add pdecls id (args, proc)

(** Prepare a process for the generation of actions:
  *
  *  - the resulting process does not feature New and Let constructs,
  *    which have been transformed into global declarations of
  *    names and macros, properly refreshed;
  *
  *  - it satisfies the Barendregt convention for index variables;
  *
  *  - its outputs are decorated with unique aliases that will be
  *    used to identify the corresponding actions.
  *
  * The returned process is intended to be read by the user
  * to understand the actions generated by the system. *)
let prepare : process -> process =

  (* We start with an environment containing a special variable for
   * talking about the current timestamp, which is used in the translation
   * to terms. *)
  let env,ts_var = Vars.make_fresh Vars.empty_env Sorts.Timestamp "ts" in

  (** Transducer recognizing the processes that can be turned
    * into actions, updating at each state the list of
    * input variables corresponding to currently opened actions.
    *
    * This should correspond "sufficiently" to what [parse_proc] does:
    * the important point is that [update] should maintain a list of
    * input variables that corresponds exactly to the action descriptions
    * that will be produced by [parse_proc].
    * The current [update] is a bit more general (e.g. TODO allow
    * aliases in p_cond below, and do not make Alias end the p_in
    * phase) which is not a big deal. It also does not reflect the
    * intermediate [p_cond] phase and in that sense it may consider
    * as a single action some processes that are two actions for
    * [parse_proc], e.g. Exists (Update (Exists (Update _))) TODO. *)
  let update (state:[`Start|`Input]) env invars p = match state,p with

    | _, (Apply _ | Let _ | New _ | Alias _) -> state, env, invars

    | `Start, (Null | Parallel _ | Repl _) -> `Start, env, invars
    | `Start, In (_,x,_) ->
        let env,x = Vars.make_fresh env Sorts.Message x in
        `Input, env, x::invars
    | `Start, (Exists _ | Set _) ->
        let env,x = Vars.make_fresh env Sorts.Message "_" in
        `Input, env, x::invars
    | `Start, Out _ ->
        let env,x = Vars.make_fresh env Sorts.Message "_" in
        `Start, env, x::invars

    | `Input, Exists _ -> `Input, env, invars
    | `Input, Set _ -> `Input, env, invars

    | `Input, Out _ -> `Start, env, invars
    | `Input, Null -> `Start, env, invars

    | `Input, _ ->
        failwith "cannot prepare system process"

  in

  (* Convert a Theory.term to Term.term using the special sort
   * of substitution maintained by the preparation function. *)
  let convert isubst msubst t : Term.message =
    let subst =
      (List.map
        (fun (x,_,tm) ->
           match tm with
             | Term.Var v -> Theory.ESubst (x,Term.Var v)
             |  _ -> assert false
         )
        isubst)
      @
      (
       List.map
        (fun (x,_,tm) -> Theory.ESubst (x,tm))
        msubst
      )
    in
    Theory.convert ~at:(Term.Var ts_var) subst t Sorts.Message
  in

  let list_assoc v l =
    let _,th,tm = List.find (fun (x,_,_) -> x = v) l in
    th,tm
  in
  let to_tsubst subst = List.map (fun (x,y,_) -> x,y) subst in

  let rec prep
    (env : Vars.env)
    (indices : Vars.index list)
    (isubst : (string*Theory.term*(Sorts.index Term.term)) list)
    (msubst : (string*Theory.term*Term.message) list)
    (invars : Vars.message list)
    prep_state
    (a : string)
    p =

  (* TODO re-indent when code is stabilized *)
  let prep_state,env,invars = update prep_state env invars p in
  let prep ?(env=env) ?(indices=indices) ?(isubst=isubst) ?(msubst=msubst) ?(a=a) p =
    prep env indices isubst msubst invars prep_state a p
  in
  match p with

    | Null -> Null

    | Parallel (p,q) ->
        let p = prep p in
        let q = prep q in
          Parallel (p,q)

    | Repl (i,p) ->
        (* make_fresh avoid confusions with other bound variables,
         * TODO we probably also want to avoid conflicts with
         * globally declared symbols *)
        let env,i' = Vars.make_fresh env Sorts.Index i in
        let isubst =
          (i, Theory.Var (Vars.name i'), Term.Var i') :: isubst in
        Repl (Vars.name i', prep ~env ~indices:(i'::indices) ~isubst p)

    | New (n,p) ->
        (* TODO getting a globally fresh symbol for the name
         * does not prevent conflicts with variables bound in
         * the process (in Repl, Let, In...) *)
        let n' = Symbols.Name.declare n (List.length indices) in
        let n'_th =
          Theory.Name
            (Symbols.to_string n',
             List.rev_map (fun i -> Theory.Var (Vars.name i)) indices)
        in
        let msubst =
          (n,n'_th,Term.Name (n',List.rev indices)) :: msubst in
          prep ~msubst p

    | Let (x,t,p) ->
        let body = convert isubst msubst t in
        let x' =
          Macros.declare_global x ~inputs:invars
            ~indices:(List.rev indices) ~ts:ts_var body
        in
        let x'_th =
          Theory.Fun
            (Symbols.to_string x',
             List.rev_map (fun i -> Theory.Var (Vars.name i)) indices,
             None)
        in
        let x'_tm =
          Term.Macro ((x', Sorts.Message, List.rev indices), [],
                      Term.Var ts_var)
        in
        let msubst = (x,x'_th,x'_tm) :: msubst in
          prep ~msubst p

    | In (c,x,p) ->
        let x' = List.hd invars in
        let msubst =
          (x,
           Theory.Var (Vars.name x'),
           Term.Var x') :: msubst in
        In (c, Vars.name x', prep ~env ~msubst p)

    | Out (c,t,p) ->
        let t = Theory.subst t (to_tsubst isubst@to_tsubst msubst) in
        let a' = Action.fresh_symbol a in
          Alias
            (Out (c, t, prep p),
             Symbols.to_string a')

    | Apply (id,args) | Alias (Apply (id,args), _) ->
        (* Keep explicit alias if there is one,
         * otherwise use id as the new alias. *)
        let a = match p with Alias (_,a) -> a | _ -> id in
        let t,p = Hashtbl.find pdecls id in
        let isubst, msubst =
          (* TODO avoid or handle conflicts with variables already
           * in domain of subst, i.e. variables bound above the apply *)
          let tsubst = (to_tsubst isubst@to_tsubst msubst) in
          List.fold_left2
            (fun (iacc,macc) (x,k) v ->
               match k,v with
                 | Sorts.ESort Sorts.Message,_ ->
                      iacc, (x, Theory.subst v tsubst,
                     convert isubst msubst v)::macc
                 | Sorts.ESort Sorts.Index, Theory.Var i ->
                     let _,i' = list_assoc i isubst in
                     (x, Theory.subst v tsubst, i')::iacc, macc
                 | _ -> assert false)
            (isubst,msubst) t args
        in
          (* Even if input variables are not going to be
           * accessed by p, we need to pass them so that
           * the list has the expected length wrt the
           * actions that will eventually be generated. *)
          prep ~a ~isubst ~msubst p

    | Set (s,l,t,p) ->
        let t' = Theory.subst t (to_tsubst isubst@to_tsubst msubst) in
        let l' =
          List.map
            (fun i ->
               match list_assoc i isubst with
                 | Theory.Var i',_ -> i'
                 | _ -> assert false)
            l
        in
        Set (s, l', t', prep p)

    | Exists (l,f,p,q) ->
        let env,s =
          List.fold_left
            (fun (env,s) i ->
               let env,i' = Vars.make_fresh env Sorts.Index i in
                 env, (i,i')::s)
            (env,[]) l
        in
        let l' = List.map (fun (_,x) -> Vars.name x) s in
        let indices' =
          List.rev_append
            (List.map snd s)
            indices
        in
        let isubst =
          List.map
            (fun (i,i') -> i, Theory.Var (Vars.name i'), Term.Var i')
            s
          @ isubst in
        let f' = Theory.subst f (to_tsubst isubst @ to_tsubst msubst) in
        let p' = prep ~env ~indices:indices' ~isubst:isubst p in
        let q' = prep q in
          Exists (l',f',p',q')

    | Alias (p,a) ->
        prep ~a p

  in fun p -> prep env [] [] [] [] `Start "A" p

(* Environment for parsing the final process, i.e. the system to study,
 * to break it into action descriptions suitable for the analysis.
 *
 * While the process is traversed, some constructs are removed/translated:
 *  - the current set of indices is maintained, as it will be used
 *    to create actions and instantiate action symbols;
 *  - a substitution mapping input variables to Term.Input values
 *    indexed by the corresponding actions is computed;
 *  - a substitution mapping index variables (string) to index variables
 *    (Action.Index.t) for technical reasons only, since we have ensured
 *    the Barendregt convention on indices.
 * All this information is stored in a record of type [p_env].
 * It also stores the current action. *)
type p_env = {
  action : Action.action ;
  p_indices : Vars.index list ;
  subst : (string * Term.message) list ;
    (** substitution for input variables *)
  isubst : (string * Vars.index) list
}

(** The extraction of actions from the system process
  * has blocked on some sub-process. *)
exception Cannot_parse of process

(** Parse a prepared process to extract its actions. *)
let parse_proc proc : unit =
  let var_env = ref Vars.empty_env in
  (** Convert given some environment and the current action symbol a. *)
  let conv_term ?(pred=false) env a t =
    let ts = Term.Action (a, List.rev env.p_indices) in
    let ts = if pred then Term.Pred ts else ts in
    let subst =
      List.map (fun (x,t) -> Theory.ESubst (x,t)) env.subst @
      List.map (fun (x,i) -> Theory.ESubst (x,Term.Var i)) env.isubst
    in
    Theory.convert ~at:ts subst t Sorts.Message
  in
  let conv_formula env a t =
    let ts = Term.Action (a, List.rev env.p_indices) in
    let subst =
      List.map (fun (x,t) -> Theory.ESubst (x,t)) env.subst @
      List.map (fun (x,i) -> Theory.ESubst (x,Term.Var i)) env.isubst
    in
    Theory.convert ~at:ts subst t Sorts.Boolean
  in
  let conv_indices env l =
    List.map (fun x -> List.assoc x env.isubst) l
  in

  (** Parse the process and accumulate parts of the new action:
    * [pos] is the position in parallel compositions,
    * [pos_indices] is the list of accumulated indices
    * for the parallel choice part of the action item.
    * Return the next position in parallel compositions. *)
  let rec p_in ~env ~pos ~(pos_indices:Vars.index list) = function
    | Apply _ | Let _ | New _ -> assert false
    | Null -> pos
    | Parallel (p, q) ->
      let pos = p_in ~env ~pos ~pos_indices p in
      p_in ~env ~pos ~pos_indices q
    | Repl (i, p) ->
      let i' = Vars.make_fresh_and_update var_env Sorts.Index i in
      let env =
        { env with
          isubst = (i,i') :: env.isubst ;
          p_indices = i' :: env.p_indices }
      in
      let pos_indices = i'::pos_indices in
      p_in ~env ~pos ~pos_indices p
    | In _ | Exists _ | Set _ | Alias _ | Out _ as proc ->
      let input,p =
        (* Get the input data,
         * or a dummy value if the input is missing. *)
        match proc with
        | In (c, x, p) -> (c, x), p
        | _ -> (Channel.dummy, "_"), proc
      in
      let par_choice = pos, List.rev pos_indices in
      let _ : int =
        p_cond
          ~env ~par_choice ~input
          ~pos:0 ~vars:[] ~facts:[]
          p
      in
      pos + 1

  (** Similar to [p_in] but with an [input] and [par_choice] already known,
    * a conjonction of [facts] in construction, and [pos] and [vars] indicating
    * the position in existential conditions and the associated
    * bound index variables. We cannot convert facts to Term.fact yet,
    * since we do not know for which action they should be converted. *)
  and p_cond ~env ~par_choice ~input ~pos ~vars ~facts = function
  | Apply _ | Let _ | New _ -> assert false
  | Exists (evars, cond, p, q) ->
      let facts_p = cond::facts in
      let newsubst = List.map (fun i ->
          i, Vars.make_fresh_and_update var_env Sorts.Index i) evars
      in
      let facts_q =
        match List.map (fun x -> x, Sorts.eindex) evars with
        | [] -> Theory.Not cond :: facts
        | qvars ->  Theory.ForAll(qvars, Theory.Not cond) :: facts
      in
      let new_env =
        { env with
          isubst = List.rev_append newsubst env.isubst ;
          p_indices =
            List.rev_append (List.map snd newsubst) env.p_indices }
      in
      let pos =
        p_cond
          ~env:new_env
          ~par_choice ~input
          ~pos ~vars:(List.rev_append evars vars) ~facts:facts_p
          p
      in
      p_cond
        ~env ~par_choice ~input
        ~pos ~vars ~facts:facts_q
        q
  | p ->
      (* We are done processing conditionals, let's prepare
       * for the next step, i.e. updates and output.
       * At this point we know which action will be used,
       * but we don't have the action symbol yet. *)
      let rec conj = function
        | [] -> Theory.True
        | [f] -> f
        | f::fs -> Theory.And (f, conj fs)
      in
      let condition = vars, conj facts in
      let action = Action.
        { par_choice ;
          sum_choice = pos, conv_indices env vars } :: env.action in
      let env =
        { env with
          action = action }
      in
      p_update
        ~env ~input ~condition
        ~updates:[]
        p ;
      pos + 1

  (** Similar to previous functions, with [sum_choice] and [facts] finalized,
    * and now accumulating a list of [updates] until an output is reached,
    * at which point the completed action and corresponding description
    * are registered. *)
  and p_update ~env ~input ~condition ~updates = function
  | Apply _ | Let _ | New _ | Out _ -> assert false

  | Set (s, l, t, p) ->
      let updates = (s,l,t)::updates in
      p_update ~env ~input ~condition ~updates p

  | Alias _ | Null as proc ->
      let output,a,p =
        (* Get output data, or dummy value if output is missing. *)
        match proc with
        | Alias (Out (c,t,p),a) -> Some (c,t), a, p
        | Alias _ -> assert false
        | Null ->
            (* Generate description anyway, since it may contain important
             * state updates. The problem is that we don't have an
             * alias setup by the preparation phase.
             * TODO aliases on "interesting" null processes *)
            let a = Action.fresh_symbol "A" in
            None,
            Symbols.to_string a,
            proc
        | _ -> assert false
      in
      (* TODO temporary Obj.magic, I suspect it will disappear
       *   by merging prepare and parse_proc, which makes sense anyway *)
      let a = Obj.magic a in
      let indices = List.rev env.p_indices in
      let in_tm =
        Term.Macro (Term.in_macro, [], Term.Action (Obj.magic a,indices)) in
      let env = { env with subst = (snd input, in_tm) :: env.subst } in
      let output =
       match output with
         | Some (c,t) -> c, conv_term env a t
         | None -> Channel.dummy, Term.dummy
      in
      let condition =
        let vars, facts = condition in
        conv_indices env vars,
        conv_formula env a facts
      in
      let updates =
        List.map
          (fun (s,l,t) ->
             (Symbols.Macro.of_string s, Sorts.Message, conv_indices env l),
             conv_term ~pred:true env a t)
          updates
      in
      let action = List.rev env.action in
      let action_descr =
        Action.{ action; input; indices; condition; updates; output } in
      Action.register (Obj.magic a) indices action action_descr ;
      ignore (p_in ~env ~pos:0 ~pos_indices:[] p)

  | p ->
      raise (Cannot_parse p)
  in

  let env =
    { action = [] ; p_indices = [] ;
      subst = [] ; isubst = [] }
  in
  let _ : int = p_in ~pos:0 ~env ~pos_indices:[] proc in
  ()

let declare_system proc =
  Printer.pr "@[<v 2>Un-processed system:@;@;@[%a@]@]@.@." pp_process proc ;
  check_proc [] proc ;
  let proc = prepare proc in
  Printer.pr "@[<v 2>Pre-processed system:@;@;@[%a@]@]@.@." pp_process proc ;
  parse_proc proc

let reset () =
  Hashtbl.clear pdecls ;
  Action.reset ()
